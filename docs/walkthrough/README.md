# An Eve Walkthrough

This walkthrough will introduce you to the principles and coding style for using Eve to create interactive visualizations in the [Elm](http://elm-lang.org) language.
It is based on the talk given by [Wongsuphasawat et al at the 2017 Open Vis Conf](https://youtu.be/9uaHRWj04D4).
If you wish to follow along with their talk, timings are given by each section.


## A Grammar of Graphics (0:30)

Eve is a wrapper for the [Vega-Lite visualization grammar](https://vega.github.io) which itself is based on Leland Wilkinson's [Grammar of Graphics](http://www.springer.com/gb/book/9780387245447).
The grammar provides an expressive way to define how data are represented graphically.
The six key elements of that grammar are


* **Data**: The input to visualize. _Example Eve functions:_ `dataFromUrl`, `dataFromColumns`.
* **Transform**: Functions to change the data before they are visualized. _Example Eve functions:_ `filter`, `calculate`, `bin`.
* **Mark**: The visual symbol(s) that represent the data. _Example Eve types:_ `Line`, `Circle`, `Bar`.
* **Encoding**: The specification of which data elements are mapped to which mark characteristics (known as _channels_). _Example Eve functions:_ `position`, `shape`, `size`.
* **Scale**: Descriptions of the way encoded marks represent the data. _Example Eve types:_ `SDomain`, `SPadding`, `SInterpolate`.
* **Guides**: Supplementary visual elements that support interpreting the visualization. _Example Eve types:_ `Axis`, `Legend`.


In common with other languages that build upon a grammar of graphics such as D3 and Vega, this grammar allows fine grain control of visualization design.
But unlike those languages, Vega-Lite and Eve provide sensible default specifications for most of the grammar, allowing for a much more compact high-level form of expression.


## A Single View specification (3:03)

Let's start with a simple table of data representing time-stamped weather data for Seattle:

| date | precipitation | temp_max | temp_min | wind | weather |
| ---- | ------------- | -------- | -------- | ---- | ------- |
|2012/01/01 | 0.0 | 12.8 | 5.0 | 4.7 | drizzle|
|2012/01/02 | 10.9 | 10.6 | 2.8 | 4.5 | rain|
|2012/01/03 | 0.8 | 11.7 | 7.2 | 2.3 | rain|
| ... | ... | ... | ... | ... | ... |

### A Strip plot (3:26)

We could encode one of the numeric data fields as a _strip plot_ where the horizontal position of a tic mark is determined by the magnitude of the data item:


![Strip plot of Seattle daily maximum temperature](images/stripPlot.png)


In Eve, to create this visualization expression:

```elm
toVegaLite
    [ dataFromUrl "data/seattle-weather.csv" []
    , mark Tick []
    , encoding (position X [ PName "temp_max", PmType Quantitative ] [])
    ]
```

Notice how there is no explicit definition of the axis details, colour choice or size.
These can be customised, but the default values are designed to follow good practice in visualization design.


The function `toVegaLite` takes a list of grammar specifications and creates a single JSON object that encodes the entire design.
This can be sent to the Vega-Lite runtime to generate the Canvas or SVG output.


Three grammar elements are represented by the three functions `dataFromUrl`, `mark` and `encoding`.


The `encoding` function takes as a single parameter, a list of specifications that are themselves generated by other functions.
In this case we use the function `position` to provide an encoding of the `temp_max` field to the x-position in our plot.
The precise way in which temperature is mapped to the x-position will depend on the type of data we are encoding.
We can provide a clue as to how that might occur by identifying the _measurement type_ of the data field, here `Quantitative` indicating a numeric measurement type.
The final parameter of `position` is a list of any other encodings in our specification.
Here, with only one encoding, we provide an empty list.


As we build up more complex visualizations we will use many more encodings. To keep the coding clear, the idiomatic way to do this in Eve is to chain encoding functions using point-free style. The example above coded in this way would be

```elm
let
    enc =
        encoding << position X [ PName "temp_max", PmType Quantitative ]
in
toVegaLite
    [ dataFromUrl "data/seattle-weather.csv" []
    , mark Tick []
    , enc []
    ]
```


### Simple Histogram (5:02)

While the strip plot shows the range of temperatures, it is hard to see how many days have which temperatures. To see that, we need to show the distribution more explicitly. We can do this by _binning_ the temperatures and then aggregating the data in each bin into counts. If we encode those counts by the y-position and change our mark from _tick_ to _bar_ we have our frequency histogram:

![Histogram of Seattle daily maximum temperature](images/histogram1.png)

```elm
let
    enc =
        encoding
            << position X [ PName "temp_max", PmType Quantitative, PBin [] ]
            << position Y [ PAggregate Count, PmType Quantitative ]
in
toVegaLite
    [ dataFromUrl "data/seattle-weather.csv" []
    , mark Bar []
    , enc []
    ]
```

The Eve code now contains two chained `position` encodings: one for the x-position, which is now binned, and one for the y-position which is aggregated by providing `PAggregate Count` instead of a data field name.

Notice again that sensible defaults are provided for the parts of the specification we didn't specify such as axis titles, colours and number of bins.


### Stacked Histogram (7:03)

Position isn't the only channel we can use to encode data.
Colour is an important channel in many visualizations, so we can use it here to encode the dominant weather type for each date in our table.
The overall shape of the histogram is the same, but now can get some idea of the separate distributions for each of the recorded weather types.

![Stacked histogram of Seattle daily maximum temperature grouped by dominant weather type](images/histogram2.png)

```elm
let
    enc =
        encoding
            << position X [ PName "temp_max", PmType Quantitative, PBin [] ]
            << position Y [ PAggregate Count, PmType Quantitative ]
            << color [ MName "weather", MmType Nominal ]
in
toVegaLite
    [ dataFromUrl "data/seattle-weather.csv" []
    , mark Bar []
    , enc []
    ]
```

The Eve code to do this is simply to add another channel encoding, this time `color` rather than `position`, and use it to encode the `weather` data field.
Unlike temperature, weather type is _nominal_, that is, categorical with no intrinsic order.
And once again, simply by stating the measurement type, Vega-Lite determines an appropriate colour scheme and legend.

### Stacked Histogram with Customised Colours (7:20)


While the default nominal colour scheme is well chosen for general purposes, we might want to customise the colours to better match the semantics of the data.


Changing the way a channel is encoded involves specifying the _scale_ and in particular the mapping between the _domain_ (the elements of the data to show) and the colour _range_ used to represent them.


![Stacked histogram of Seattle daily maximum temperature grouped by dominant weather type and semantically meaningful colours](images/histogram3.png)


```elm
let
    enc =
        encoding
            << position X [ PName "temp_max", PmType Quantitative, PBin [] ]
            << position Y [ PAggregate Count, PmType Quantitative ]
            << color
                [ MName "weather"
                , MmType Nominal
                , MScale
                    [ SDomain (DStrings [ "sun", "fog", "drizzle", "rain", "snow" ])
                    , SRange (RStrings [ "#e7ba52", "#c7c7c7", "#aec7ea", "#1f77b4", "#9467bd" ])
                    ]
                ]
in
toVegaLite
    [ dataFromUrl "data/seattle-weather.csv" []
    , mark Bar []
    , enc []
    ]
```

Notice how that in Eve we make frequent use of _union types_ (always indicated by names starting with an uppercase letter).
Types used to customise various channels all start with an uppercase letter indicating the type of channel affected.
So the name of the data field use to encode position is `PName`, its measurement type, `PmType` whereas the name of the data field for encoding colour is indicated by the type `MName` (where `M` is short for Mark).
Similar rules apply for nested properties, so that the domain and range of a scale are indicated by `SDomain` and `SRange`.


Notice how we never needed to state explicitly that we wished our bars to be stacked.
This was inferred directly by Vega-Lite based on the combination of bar marks and colour channel encoding.
If we were to change just the mark type from `Bar` to `Line`, Vega-Lite now produces an unstacked series of lines, which makes sense because unlike bars, lines do not occlude one another to the same extent.

![Unstacked distributions of Seattle daily maximum temperature grouped by dominant weather type](images/lineChart.png)

```elm
let
    enc =
        encoding
            << position X [ PName "temp_max", PmType Quantitative, PBin [] ]
            << position Y [ PAggregate Count, PmType Quantitative ]
            << color
                [ MName "weather"
                , MmType Nominal
                , MScale
                    [ SDomain (DStrings [ "sun", "fog", "drizzle", "rain", "snow" ])
                    , SRange (RStrings [ "#e7ba52", "#c7c7c7", "#aec7ea", "#1f77b4", "#9467bd" ])
                    ]
                ]
in
toVegaLite
    [ dataFromUrl "data/seattle-weather.csv" []
    , mark Line []
    , enc []
    ]
```

The stacked bar chart version is better at showing the overall distribution of all weather types but more difficult to to compare distributions of anything other than sun as all other weather types lack a common baseline.
To compare distributions of all categories we can move from a single view to a multi-view composition.


## Layered and Multi-view Composition (8:28)

To show our weather distributions next to each other rather than stacked on top of each other, we simply encode column position in a row of small multiples to the weather data field:

![Small multiples of temperature distributions by weather type](images/multiBar.png)

```elm
let
    enc =
        encoding
            << position X [ PName "temp_max", PmType Quantitative, PBin [] ]
            << position Y [ PAggregate Count, PmType Quantitative ]
            << column [ FName "weather", FmType Nominal ]
            << color
                [ MName "weather"
                , MmType Nominal
                , MLegend []
                , MScale
                    [ SDomain (DStrings [ "sun", "fog", "drizzle", "rain", "snow" ])
                    , SRange (RStrings [ "#e7ba52", "#c7c7c7", "#aec7ea", "#1f77b4", "#9467bd" ])
                    ]
                ]
in
toVegaLite
    [ dataFromUrl "data/seattle-weather.csv" []
    , mark Bar []
    , enc []
    ]
```
There are only two additions to the Eve specification to create these small multiples.
Firstly we have an extra encoding with the `column` function specifying the `weather` data field as the one to determine which column each data item gets mapped to.
Note that the `F` prefix for `FName` and `FmType` refers to _facet_ â€“ a form of data selection and grouping standard in data visualization.


The second, minor change, is to include an `MLegend` specification in the colour encoding, but here by providing an empty list, we are stating we do not wish the default legend to appear (the arrangement into columns with colour encoding and default column labels make the legend redundant).
