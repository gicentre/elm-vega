[
  {
    "name": "Vega",
    "comment": " Create full Vega specifications in Elm. The module can generate JSON specs\nthat may be passed to the Vega runtime library to activate the visualization.\n\n\n# Creating A Vega Specification\n\n@docs toVega\n@docs combineSpecs\n\n@docs VProperty\n\n\n# Passing Values into a Vega Specification\n\nData types such as numbers, strings and Booleans are generated by functions, for\nexample, _expressions_ that generate new values based on operations applied to\nexisting ones, _fields_ that reference a column of a data table or _signals_\nthat can respond dynamically to data or interaction.\n\n\n## Numeric Values\n\n@docs num\n@docs nums\n@docs numSignal\n@docs numSignals\n@docs numExpr\n@docs numList\n@docs numNull\n\n\n## String Values\n\n@docs str\n@docs strs\n@docs strSignal\n@docs strSignals\n@docs strExpr\n@docs strNull\n\n\n## Boolean Values\n\n@docs true\n@docs false\n@docs boos\n@docs booSignal\n@docs booSignals\n@docs booExpr\n\n\n## Generic Values\n\nUsed by functions that expect values of mixed types.\n\n@docs vNum\n@docs vNums\n@docs vStr\n@docs vStrs\n@docs vTrue\n@docs vFalse\n@docs vBoos\n@docs vSignal\n@docs vField\n@docs vColor\n@docs vBand\n@docs vObject\n@docs keyValue\n@docs vValues\n@docs ifElse\n@docs vNull\n@docs vMultiply\n@docs vExponent\n@docs vOffset\n@docs vRound\n@docs vScale\n@docs vScaleField\n\n\n## Indirect References\n\nSee the\n[Vega field value documentation](https://vega.github.io/vega/docs/types/#FieldValue).\n\n@docs field\n@docs fSignal\n@docs fExpr\n@docs fDatum\n@docs fGroup\n@docs fParent\n@docs expr\n@docs exField\n\n\n## Thematic Data Types\n\n@docs TimeUnit\n@docs timeUnitSignal\n@docs cHCL\n@docs cHSL\n@docs cLAB\n@docs cRGB\n\n\n# Creating an Input Data Specification\n\nSee the [Vega data](https://vega.github.io/vega/docs/data) and the\n[Vega data reference](https://vega.github.io/vega/docs/scales/#dataref) documentation.\n\n@docs dataSource\n@docs data\n\n@docs dataFromColumns\n@docs dataColumn\n\n@docs dataFromRows\n@docs dataRow\n@docs DataProperty\n\n@docs daUrl\n@docs daFormat\n@docs daSource\n@docs daSources\n@docs daValue\n@docs daOn\n\n@docs daDataset\n@docs daField\n@docs daFields\n@docs daValues\n@docs daSignal\n@docs daReferences\n\n\n## Data Sorting\n\nSee the\n[Vega sort documentation](https://vega.github.io/vega/docs/scales/#sort).\n\n@docs daSort\n@docs SortProperty\n@docs sortPropertySignal\n@docs soOp\n@docs soByField\n\n@docs Order\n@docs orderSignal\n\n\n## Data Parsing and Formatting\n\n@docs FormatProperty\n@docs dsv\n@docs jsonProperty\n@docs topojsonMesh\n@docs topojsonFeature\n@docs formatPropertySignal\n\n@docs DataType\n@docs parse\n@docs foDate\n@docs foUtc\n\n\n# Transforming Data\n\nApplying a transform to a data stream can filter or generate new fields in the\nstream, or derive new data streams. Pipe (`|>`) the stream into the `transform`\nfunction and specify the type of transform to apply via one or more of these functions.\nSee the [Vega transform documentation](https://vega.github.io/vega/docs/transforms).\n\n@docs transform\n\n\n## Basic Transforms\n\n\n### Aggregation\n\nSee the\n[Vega aggregate transform documentation](https://vega.github.io/vega/docs/transforms/aggregate/)\n\n@docs trAggregate\n@docs agGroupBy\n@docs agFields\n@docs agOps\n@docs agAs\n@docs agCross\n@docs agDrop\n@docs agKey\n\n@docs Operation\n@docs operationSignal\n\n\n### Join Aggregation\n\nSee the\n[Vega join aggregation documentation](https://vega.github.io/vega/docs/transforms/joinaggregate/).\n\n@docs trJoinAggregate\n@docs jaGroupBy\n@docs jaFields\n@docs jaOps\n@docs jaAs\n\n\n### Binning\n\nSee the\n[Vega bin transform documentation](https://vega.github.io/vega/docs/transforms/bin/)\n\n@docs trBin\n@docs bnAnchor\n@docs bnMaxBins\n@docs bnBase\n@docs bnStep\n@docs bnSteps\n@docs bnMinStep\n@docs bnDivide\n@docs bnNice\n@docs bnSignal\n@docs bnAs\n\n\n### Collection\n\nSee the\n[Vega collect transform documentation](https://vega.github.io/vega/docs/transforms/collect/).\n\n@docs trCollect\n\n\n### Text Pattern Counting\n\nSee the\n[Vega count pattern transform documentation](https://vega.github.io/vega/docs/transforms/countpattern/).\n\n@docs trCountPattern\n@docs cpPattern\n@docs cpCase\n@docs Case\n@docs cpStopwords\n@docs cpAs\n\n\n### Cross Product\n\nSee the\n[Vega cross-product transform documentation](https://vega.github.io/vega/docs/transforms/cross/).\n\n@docs trCross\n@docs crFilter\n@docs crAs\n\n\n### Probability Density Function Calculation\n\nSee the\n[Vega density transform documentation](https://vega.github.io/vega/docs/transforms/density/).\n\n@docs trDensity\n@docs dnExtent\n@docs dnMethod\n@docs DensityFunction\n@docs densityFunctionSignal\n@docs dnSteps\n@docs dnAs\n\n@docs diNormal\n@docs diUniform\n@docs diKde\n@docs diMixture\n\n\n### Range calculation\n\nSee the\n[Vega extent transform documentation](https://vega.github.io/vega/docs/transforms/extent/).\n\n@docs trExtent\n@docs trExtentAsSignal\n\n\n### Filtering\n\nSee the Vega [filter](https://vega.github.io/vega/docs/transforms/filter/) and\nand [crossfilter](https://vega.github.io/vega/docs/transforms/crossfilter/)\ntransform documentation.\n\n@docs trFilter\n@docs trCrossFilter\n@docs trCrossFilterAsSignal\n@docs trResolveFilter\n\n\n### Flattening\n\n@docs trFlatten\n@docs trFlattenAs\n\n\n### Folding and Pivoting\n\nSee the Vega [fold](https://vega.github.io/vega/docs/transforms/fold/) and\n[pivot](https://vega.github.io/vega/docs/transforms/pivot/) transform documentation.\n\n@docs trFold\n@docs trFoldAs\n@docs trPivot\n@docs piGroupBy\n@docs piLimit\n@docs piOp\n\n\n### Deriving New Fields\n\nSee the Vega [formula](https://vega.github.io/vega/docs/transforms/formula),\n[lookup](https://vega.github.io/vega/docs/transforms/lookup/),\n[identifier](https://vega.github.io/vega/docs/transforms/identifier/),\n[project](https://vega.github.io/vega/docs/transforms/project/) and\n[window](https://vega.github.io/vega/docs/transforms/window/) transform documentation.\n\n@docs trFormula\n@docs trFormulaInitOnly\n\n@docs trLookup\n@docs luAs\n@docs luValues\n@docs luDefault\n\n@docs trIdentifier\n@docs trProject\n\n@docs trWindow\n@docs wnAggOperation\n@docs wnOperation\n@docs wnOperationOn\n@docs WOperation\n@docs wOperationSignal\n@docs wnSort\n@docs wnGroupBy\n@docs wnFrame\n@docs wnIgnorePeers\n\n\n### Handling Missing Values\n\nSee the\n[Vega impute transform documentation](https://vega.github.io/vega/docs/transforms/impute/).\n\n@docs trImpute\n@docs imKeyVals\n@docs imMethod\n@docs ImputeMethod\n@docs imGroupBy\n@docs imValue\n\n\n### Sampling\n\nSee the\n[Vega sample transform documentation](https://vega.github.io/vega/docs/transforms/sample/).\n\n@docs trSample\n\n\n### Data Generation\n\nSee the\n[Vega sequence transform documentation](https://vega.github.io/vega/docs/transforms/sequence/).\n\n@docs trSequence\n@docs trSequenceAs\n\n\n## Geographic Transforms\n\n\n### Contouring\n\nSee the\n[Vega contour transform documentation](https://vega.github.io/vega/docs/transforms/contour/)\n\n@docs trContour\n@docs cnValues\n@docs cnX\n@docs cnY\n@docs cnCellSize\n@docs cnBandwidth\n@docs cnSmooth\n@docs cnThresholds\n@docs cnCount\n@docs cnNice\n\n\n### GeoJSON transformation\n\nSee the Vega\n[geoJSON](https://vega.github.io/vega/docs/transforms/geojson/),\n[geoPoint](https://vega.github.io/vega/docs/transforms/geopoint/),\n[geoshape](https://vega.github.io/vega/docs/transforms/geoshape/) and\n[geopath](https://vega.github.io/vega/docs/transforms/geopath/) documentation.\n\n@docs trGeoShape\n@docs trGeoPath\n@docs gpField\n@docs gpPointRadius\n@docs gpAs\n@docs trGeoJson\n@docs gjFields\n@docs gjFeature\n@docs gjSignal\n\n@docs trGeoPoint\n@docs trGeoPointAs\n\n\n### Graticule Generation\n\nSee the\n[Vega graticule transform documentation](https://vega.github.io/vega/docs/transforms/graticule/).\n\n@docs trGraticule\n@docs grExtent\n@docs grExtentMajor\n@docs grExtentMinor\n@docs grStep\n@docs grStepMajor\n@docs grStepMinor\n@docs grField\n@docs grPrecision\n\n\n## Layout Transforms\n\n\n### Link Paths\n\nSee the\n[Vega link path transform documentation](https://vega.github.io/vega/docs/transforms/linkpath/).\n\n@docs trLinkPath\n@docs lpSourceX\n@docs lpSourceY\n@docs lpTargetX\n@docs lpTargetY\n@docs lpOrient\n@docs lpShape\n@docs lpAs\n@docs LinkShape\n@docs linkShapeSignal\n\n\n### Angular Layouts\n\nSee the\n[Vega pie transform documentation](https://vega.github.io/vega/docs/transforms/pie/).\n\n@docs trPie\n@docs piField\n@docs piStartAngle\n@docs piEndAngle\n@docs piSort\n@docs piAs\n\n\n### Stacked Layouts\n\nSee the\n[Vega stack transform documentation](https://vega.github.io/vega/docs/transforms/stack/).\n\n@docs trStack\n@docs stField\n@docs stGroupBy\n@docs stSort\n@docs stOffset\n@docs stAs\n@docs StackOffset\n@docs stackOffsetSignal\n\n\n### Force-Generated Layouts\n\nSee the\n[Vega force transform documentation](https://vega.github.io/vega/docs/transforms/force/).\n\n@docs trForce\n\n@docs fsStatic\n@docs fsRestart\n@docs fsIterations\n@docs fsAlpha\n@docs fsAlphaMin\n@docs fsAlphaTarget\n@docs fsVelocityDecay\n@docs fsForces\n@docs fsAs\n\n@docs foCenter\n@docs foCollide\n@docs foNBody\n@docs foLink\n@docs foX\n@docs foY\n\n@docs fpStrength\n@docs fpDistance\n@docs fpIterations\n@docs fpTheta\n@docs fpDistanceMin\n@docs fpDistanceMax\n@docs fpId\n\n\n### Voronoi Diagram\n\nSee the\n[Vega Voronoi transform documentation](https://vega.github.io/vega/docs/transforms/voronoi/).\n\n@docs trVoronoi\n@docs voSize\n@docs voExtent\n@docs voAs\n\n\n### Word Cloud layout\n\nSee the\n[Vega wordcloud transform documentation](https://vega.github.io/vega/docs/transforms/wordcloud/).\n\n@docs trWordcloud\n@docs wcFont\n@docs wcFontStyle\n@docs wcFontWeight\n@docs wcFontSize\n@docs wcFontSizeRange\n@docs wcPadding\n@docs wcRotate\n@docs wcText\n@docs wcSize\n@docs wcSpiral\n@docs Spiral\n@docs spiralSignal\n@docs wcAs\n\n\n## Hierarchy Transforms\n\nSee the Vega\n[nest](https://vega.github.io/vega/docs/transforms/nest/),\n[stratify](https://vega.github.io/vega/docs/transforms/stratify/),\n[pack](https://vega.github.io/vega/docs/transforms/pack/),\n[partition](https://vega.github.io/vega/docs/transforms/partition/),\n[tree](https://vega.github.io/vega/docs/transforms/tree/),\n[tree links](https://vega.github.io/vega/docs/transforms/treelinks/) and\n[treemap](https://vega.github.io/vega/docs/transforms/treemap/) transform documentation.\n\n@docs trNest\n@docs trStratify\n\n@docs trPack\n@docs paField\n@docs paSort\n@docs paSize\n@docs paRadius\n@docs paPadding\n@docs paAs\n\n@docs trPartition\n@docs ptField\n@docs ptSort\n@docs ptPadding\n@docs ptRound\n@docs ptSize\n@docs ptAs\n\n@docs trTree\n@docs teField\n@docs teSort\n@docs teMethod\n@docs TreeMethod\n@docs treeMethodSignal\n@docs teSize\n@docs teNodeSize\n@docs teAs\n\n@docs trTreeLinks\n\n@docs trTreemap\n@docs tmField\n@docs tmSort\n@docs tmMethod\n@docs TreemapMethod\n@docs treemapMethodSignal\n@docs tmPadding\n@docs tmPaddingInner\n@docs tmPaddingOuter\n@docs tmPaddingTop\n@docs tmPaddingLeft\n@docs tmPaddingBottom\n@docs tmPaddingRight\n@docs tmRatio\n@docs tmRound\n@docs tmSize\n@docs tmAs\n\n\n# Signals, Triggers and Interaction Events\n\nSignals are the means by which dynamic data values may be passed around a\nvisualization specification. See the\n[Vega signal documentation](https://vega.github.io/vega/docs/signals)\n\n\n## Signals\n\n@docs signals\n@docs signal\n@docs siName\n@docs siValue\n@docs siBind\n@docs siDescription\n@docs siOn\n@docs siUpdate\n@docs siReact\n@docs siPushOuter\n\n\n## User Interface Inputs\n\nSee the [Vega signal binding documentation](https://vega.github.io/vega/docs/signals/#bind).\n\n@docs iCheckbox\n@docs iText\n@docs iNumber\n@docs iDate\n@docs iDateTimeLocal\n@docs iTime\n@docs iMonth\n@docs iWeek\n@docs iRadio\n@docs iRange\n@docs iSelect\n@docs iTel\n@docs iColor\n\n@docs inDebounce\n@docs inElement\n@docs inOptions\n@docs inMin\n@docs inMax\n@docs inStep\n@docs inPlaceholder\n@docs inAutocomplete\n\n\n## Event Handling\n\nSee the Vega [event stream](https://vega.github.io/vega/docs/event-streams)\nand [event handler](https://vega.github.io/vega/docs/signals/#handlers) documentation.\n\n@docs evHandler\n@docs evUpdate\n@docs evEncode\n@docs evForce\n\n@docs esObject\n@docs esSignal\n@docs esMerge\n@docs esStream\n@docs esSelector\n@docs esSource\n@docs esType\n@docs esBetween\n@docs esConsume\n@docs esFilter\n@docs esDebounce\n@docs esMarkName\n@docs esMark\n@docs esThrottle\n\n@docs evStreamSelector\n@docs EventSource\n\n@docs esDom\n@docs EventType\n\n\n## Triggers\n\nSee the [Vega trigger documentation](https://vega.github.io/vega/docs/triggers).\n\n@docs on\n@docs trigger\n@docs tgInsert\n@docs tgRemove\n@docs tgRemoveAll\n@docs tgToggle\n@docs tgModifyValues\n\n\n# Specifying Scales\n\nScales map between data values and their visual expression (channels) such as\ncolor or position. See the\n[Vega scale documentation](https://vega.github.io/vega/docs/scales).\n\n@docs scales\n@docs scale\n@docs scReverse\n@docs scRound\n@docs scClamp\n@docs scPadding\n@docs scNice\n@docs scZero\n@docs scExponent\n@docs scBase\n@docs scAlign\n@docs scDomainImplicit\n@docs scPaddingInner\n@docs scPaddingOuter\n@docs scRangeStep\n\n@docs ScaleNice\n@docs scaleNiceSignal\n@docs nInterval\n@docs nTickCount\n\n\n## Scale Types\n\n@docs scType\n@docs Scale\n@docs scaleSignal\n@docs scCustom\n\n\n## Scale Domains\n\nThe extent of data that inform a scaling.\n\n@docs scDomain\n@docs scDomainMax\n@docs scDomainMin\n@docs scDomainMid\n@docs scDomainRaw\n@docs doNums\n@docs doStrs\n@docs doSignal\n@docs doSignals\n@docs doData\n\n\n## Scale Ranges\n\nThe extent of scaled values after transformation.\n\n@docs scRange\n@docs ScaleRange\n@docs scaleRangeSignal\n@docs raNums\n@docs raStrs\n@docs raValues\n@docs raSignal\n@docs raScheme\n@docs raData\n@docs raStep\n@docs raCustomDefault\n\n\n## Color Scales\n\nSee the Vega [Vega color scale](https://vega.github.io/vega/docs/scales/#properties)\nand [color scheme](https://vega.github.io/vega/docs/schemes/) documentation.\n\n@docs csScheme\n@docs csCount\n@docs csExtent\n\n@docs scInterpolate\n@docs CInterpolate\n@docs cubeHelix\n@docs cubeHelixLong\n@docs hclLong\n@docs hslLong\n@docs rgb\n\n\n# Specifying Projections\n\nSee the\n[Vega map projection documentation](https://vega.github.io/vega/docs/projections).\n\n@docs projections\n@docs projection\n@docs Projection\n@docs projectionSignal\n@docs projectionValue\n@docs prCustom\n@docs prType\n@docs prClipAngle\n@docs prClipExtent\n@docs prScale\n@docs prTranslate\n@docs prCenter\n@docs prRotate\n@docs prPointRadius\n@docs prPrecision\n@docs prCoefficient\n@docs prDistance\n@docs prFraction\n@docs prLobes\n@docs prParallel\n@docs prRadius\n@docs prRatio\n@docs prSpacing\n@docs prTilt\n@docs prFit\n@docs feName\n@docs featureSignal\n@docs prExtent\n@docs prSize\n\n\n# Specifying Axes\n\nSee the [Vega axis documentation](https://vega.github.io/vega/docs/axes/).\n\n@docs axes\n@docs axis\n@docs axBandPosition\n@docs axDomain\n@docs axDomainColor\n@docs axDomainOpacity\n@docs axDomainWidth\n@docs axEncode\n@docs axFormat\n@docs axGrid\n@docs axGridColor\n@docs axGridOpacity\n@docs axGridDash\n@docs axGridScale\n@docs axGridWidth\n@docs axLabels\n@docs axLabelBound\n@docs axLabelAlign\n@docs axLabelBaseline\n@docs axLabelAngle\n@docs axLabelColor\n@docs axLabelOpacity\n@docs axLabelFont\n@docs axLabelFontSize\n@docs axLabelFontWeight\n@docs axLabelFlush\n@docs axLabelFlushOffset\n@docs axLabelLimit\n@docs axLabelPadding\n@docs axLabelOverlap\n@docs axMinExtent\n@docs axMaxExtent\n@docs axOffset\n@docs axPosition\n@docs axTicks\n@docs axTickCount\n@docs axTemporalTickCount\n@docs axTickColor\n@docs axTickOpacity\n@docs axTickExtra\n@docs axTickOffset\n@docs axTickRound\n@docs axTickWidth\n@docs axTickSize\n@docs axTitle\n@docs axTitleAlign\n@docs axTitleAngle\n@docs axTitleBaseline\n@docs axTitleColor\n@docs axTitleOpacity\n@docs axTitleFont\n@docs axTitleFontSize\n@docs axTitleFontWeight\n@docs axTitleLimit\n@docs axTitlePadding\n@docs axTitleX\n@docs axTitleY\n@docs axValues\n@docs axZIndex\n@docs AxisElement\n@docs Side\n@docs sideSignal\n@docs OverlapStrategy\n@docs overlapStrategySignal\n\n\n# Specifying Legends\n\nSee the\n[Vega legend documentation](https://vega.github.io/vega/docs/legends/)\n\n@docs legends\n@docs legend\n@docs leType\n@docs leDirection\n@docs leOrient\n@docs leFill\n@docs leOpacity\n@docs leShape\n@docs leSize\n@docs leStroke\n@docs leStrokeDash\n@docs leEncode\n@docs leFormat\n@docs leGridAlign\n@docs leClipHeight\n@docs leColumns\n@docs leColumnPadding\n@docs leRowPadding\n@docs leCornerRadius\n@docs leFillColor\n@docs leOffset\n@docs lePadding\n@docs leStrokeColor\n@docs leStrokeWidth\n@docs leGradientOpacity\n@docs leGradientLabelLimit\n@docs leGradientLabelOffset\n@docs leGradientLength\n@docs leGradientThickness\n@docs leGradientStrokeColor\n@docs leGradientStrokeWidth\n@docs leLabelAlign\n@docs leLabelBaseline\n@docs leLabelColor\n@docs leLabelFont\n@docs leLabelFontSize\n@docs leLabelFontWeight\n@docs leLabelLimit\n@docs leLabelOpacity\n@docs leLabelOffset\n@docs leLabelOverlap\n@docs leSymbolFillColor\n@docs leSymbolBaseFillColor\n@docs leSymbolBaseStrokeColor\n@docs leSymbolDirection\n@docs leSymbolOffset\n@docs leSymbolSize\n@docs leSymbolStrokeColor\n@docs leSymbolStrokeWidth\n@docs leSymbolOpacity\n@docs leSymbolType\n@docs leTickCount\n@docs leTemporalTickCount\n@docs leTitle\n@docs leTitleAlign\n@docs leTitleBaseline\n@docs leTitleColor\n@docs leTitleOpacity\n@docs leTitleFont\n@docs leTitleFontSize\n@docs leTitleFontWeight\n@docs leTitleLimit\n@docs leTitlePadding\n@docs leValues\n@docs leZIndex\n@docs LegendType\n@docs legendTypeSignal\n@docs LegendOrientation\n@docs legendOrientationSignal\n@docs enLegend\n@docs enTitle\n@docs enLabels\n@docs enSymbols\n@docs enGradient\n@docs enName\n@docs enInteractive\n\n\n# Specifying Titles\n\nSee the [Vega title documentation](https://vega.github.io/vega/docs/title/)\n\n@docs title\n@docs tiAnchor\n@docs tiAngle\n@docs Anchor\n@docs anchorSignal\n@docs tiAlign\n@docs tiBaseline\n@docs tiColor\n@docs tiEncode\n@docs tiFont\n@docs tiFontSize\n@docs tiFontWeight\n@docs tiFrame\n@docs TitleFrame\n@docs titleFrameSignal\n@docs tiInteractive\n@docs tiLimit\n@docs tiName\n@docs tiOffset\n@docs tiOrient\n@docs tiStyle\n@docs tiZIndex\n\n\n# Specifying Layout\n\nSee the [Vega layout documentation](https://vega.github.io/vega/docs/layout/).\n\n@docs layout\n@docs GridAlign\n@docs gridAlignSignal\n@docs grAlignRow\n@docs grAlignColumn\n@docs BoundsCalculation\n@docs bcSignal\n@docs loAlign\n@docs loBounds\n@docs loColumns\n@docs loPadding\n@docs loPaddingRC\n@docs loOffset\n@docs loOffsetRC\n@docs loHeaderBand\n@docs loHeaderBandRC\n@docs loFooterBand\n@docs loFooterBandRC\n@docs loTitleBand\n@docs loTitleBandRC\n\n\n# Specifying Marks\n\nSee the\n[Vega mark documentation](https://vega.github.io/vega/docs/marks).\n\n##Â Top-Level Marks\n\n@docs marks\n@docs mark\n@docs Mark\n@docs mClip\n@docs mDescription\n@docs mEncode\n@docs mFrom\n@docs mInteractive\n@docs mKey\n@docs mName\n@docs mOn\n@docs mSort\n@docs mTransform\n@docs mStyle\n@docs mGroup\n@docs mZIndex\n\n@docs clEnabled\n@docs clPath\n@docs clSphere\n@docs srData\n\n\n## Faceting\n\nSplit up a data source between group mark items. Each group mark is backed by an\naggregate data value representing the entire group. Facets can be _data-driven_,\nin which partitions are determined by grouping data values by specified attributes\nor _pre-faceted_ when the data source already contains a list of sub-values.\n\n@docs srFacet\n@docs faField\n@docs faGroupBy\n@docs faAggregate\n\n\n## Lower-level Mark Properties\n\nSee the [Vega mark encoding documentation](https://vega.github.io/vega/docs/marks/#encode).\n\n@docs maX\n@docs maX2\n@docs maXC\n@docs maWidth\n@docs maY\n@docs maY2\n@docs maYC\n@docs maHeight\n@docs maOpacity\n@docs maFill\n@docs maFillOpacity\n@docs maStroke\n@docs transparent\n@docs black\n@docs white\n@docs maStrokeOpacity\n@docs maStrokeWidth\n@docs maStrokeCap\n@docs maStrokeDash\n@docs maStrokeDashOffset\n@docs maStrokeJoin\n@docs maStrokeMiterLimit\n@docs maCursor\n@docs maHRef\n@docs maTooltip\n@docs maZIndex\n@docs maAlign\n@docs maBaseline\n@docs maCornerRadius\n@docs maInterpolate\n@docs maTension\n@docs maDefined\n@docs maSize\n@docs maStartAngle\n@docs maEndAngle\n@docs maPadAngle\n@docs maInnerRadius\n@docs maOuterRadius\n@docs maOrient\n@docs maGroupClip\n@docs maUrl\n@docs maAspect\n@docs maPath\n@docs maShape\n@docs maSymbol\n@docs maAngle\n@docs maDir\n@docs maDx\n@docs maDy\n@docs maEllipsis\n@docs maFont\n@docs maFontSize\n@docs maFontWeight\n@docs maFontStyle\n@docs maLimit\n@docs maRadius\n@docs maText\n@docs maTheta\n@docs maCustom\n\n\n## Encoding\n\nSee the [Vega mark encoding documentation](https://vega.github.io/vega/docs/marks/#encode).\n\n@docs enEnter\n@docs enUpdate\n@docs enHover\n@docs enExit\n@docs enCustom\n@docs MarkInterpolation\n@docs markInterpolationValue\n@docs Orientation\n@docs orientationSignal\n@docs orientationValue\n@docs Cursor\n@docs cursorValue\n@docs HAlign\n@docs hAlignSignal\n@docs hLeft\n@docs hCenter\n@docs hRight\n@docs VAlign\n@docs vAlignSignal\n@docs vTop\n@docs vMiddle\n@docs vBottom\n@docs vAlphabetic\n@docs Symbol\n@docs symbolValue\n@docs symbolSignal\n@docs symPath\n@docs StrokeCap\n@docs strokeCapValue\n@docs strokeCapSignal\n@docs StrokeJoin\n@docs strokeJoinSignal\n@docs strokeJoinValue\n@docs textDirectionValue\n@docs TextDirection\n@docs textDirectionSignal\n\n\n# Configuring Visualization Appearance\n\nSee the\n[Vega configuration documentation](https://vega.github.io/vega/docs/config/).\n\n@docs config\n\n\n## View Configuration\n\n@docs cfAutosize\n@docs cfBackground\n@docs cfGroup\n\n\n## Event Configuration\n\n@docs cfEvents\n@docs EventFilter\n\n\n## Mark Configuration\n\n@docs cfMark\n@docs cfMarks\n\n\n## Style Configuration\n\n@docs cfStyle\n\n\n## Axis Configuration\n\n@docs cfAxis\n@docs AxisType\n\n\n## Legend Configuration\n\n@docs cfLegend\n\n\n## Title Configuration\n\n@docs cfTitle\n\n\n## Scale Range Configuration\n\n@docs cfScaleRange\n\n\n# Supplementary Properties\n\nSee the\n[Vega specification documentation](https://vega.github.io/vega/docs/specification/)\n\n@docs autosize\n@docs Autosize\n@docs autosizeSignal\n@docs height\n@docs padding\n@docs paddings\n@docs width\n@docs background\n@docs encode\n\n---\n\n\n# Type Reference\n\nTypes that are not specified directly, porovided here for reference with links\nto the functions that generate them.\n\n@docs AggregateProperty\n@docs AxisProperty\n@docs Bind\n@docs BinProperty\n@docs Boo\n@docs Clip\n@docs ColorSchemeProperty\n@docs ColorValue\n@docs ConfigProperty\n@docs ContourProperty\n@docs CountPatternProperty\n@docs CrossProperty\n@docs Data\n@docs DataColumn\n@docs DataReference\n@docs DataRow\n@docs DataTable\n@docs DensityProperty\n@docs Distribution\n@docs EncodingProperty\n@docs EventHandler\n@docs EventStream\n@docs EventStreamProperty\n@docs Expr\n@docs Facet\n@docs Feature\n@docs Field\n@docs Force\n@docs ForceProperty\n@docs ForceSimulationProperty\n@docs GeoJsonProperty\n@docs GeoPathProperty\n@docs GraticuleProperty\n@docs ImputeProperty\n@docs InputProperty\n@docs JoinAggregateProperty\n@docs LayoutProperty\n@docs LegendEncoding\n@docs LegendProperty\n@docs LinkPathProperty\n@docs LookupProperty\n@docs MarkProperty\n@docs Num\n@docs PackProperty\n@docs PartitionProperty\n@docs PieProperty\n@docs PivotProperty\n@docs ProjectionProperty\n@docs ScaleDomain\n@docs ScaleProperty\n@docs SignalProperty\n@docs Source\n@docs Spec\n@docs StackProperty\n@docs Str\n@docs TitleProperty\n@docs TopMarkProperty\n@docs Transform\n@docs TreemapProperty\n@docs TreeProperty\n@docs Trigger\n@docs TriggerProperty\n@docs Value\n@docs VoronoiProperty\n@docs WindowOperation\n@docs WindowProperty\n@docs WordcloudProperty\n\n",
    "aliases": [
      {
        "name": "Data",
        "comment": " Convenience type annotation label for use with data generation functions.\nGenerated by [dataSource](#dataSource) but is also useful when creating your own\ndata generating functions. For example:\n\n    myData : Int -> Data\n    myData yr =\n        dataSource\n            [ data \"population\" [ daSource \"pop\" ]\n                |> transform [ trFilter (expr (\"datum.year == \" ++ toString yr)) ]\n            ]\n\n",
        "args": [],
        "type": "( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "DataColumn",
        "comment": " A single column of data. Generated when creating inline data with\n[dataColumn](#dataColumn).\n",
        "args": [],
        "type": "List Vega.LabelledSpec"
      },
      {
        "name": "DataRow",
        "comment": " A single row of data. Generated when creating inline data with\n[dataRow](#dataRow).\n",
        "args": [],
        "type": "Vega.Spec"
      },
      {
        "name": "DataTable",
        "comment": " A single table of data (collection of `dataColumn` specifications).\nGenerated by [data](#data), [dataFromColumns](#dataFromColumns),\n[dataFromRows](#dataFromRows), [on](#on) and [transform](#transform).\n",
        "args": [],
        "type": "List Vega.LabelledSpec"
      },
      {
        "name": "Spec",
        "comment": " A Vega specification. Specs can be (and usually are) nested.\nThey can range from a single Boolean value up to the entire Vega specification.\n",
        "args": [],
        "type": "Json.Encode.Value"
      },
      {
        "name": "Trigger",
        "comment": " Generated by [trigger](#trigger).\n",
        "args": [],
        "type": "Vega.Spec"
      }
    ],
    "types": [
      {
        "name": "AggregateProperty",
        "comment": " Generated by [agAs](#agAs),\n[agCross](#agCross), [agDrop](#agDrop), [agFields](#agFields),\n[agGroupBy](#agGroupBy), [agOps](#agOps) and [agKey](#agKey).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Anchor",
        "comment": " An anchor position, as used for example, in placing title text.\n",
        "args": [],
        "cases": [
          [
            "Start",
            []
          ],
          [
            "Middle",
            []
          ],
          [
            "End",
            []
          ]
        ]
      },
      {
        "name": "Autosize",
        "comment": " Auto-sizing characteristics of the visualization such as amount of padding,\nwhether it should fill the parent container etc.\n",
        "args": [],
        "cases": [
          [
            "AContent",
            []
          ],
          [
            "AFit",
            []
          ],
          [
            "AFitX",
            []
          ],
          [
            "AFitY",
            []
          ],
          [
            "ANone",
            []
          ],
          [
            "APad",
            []
          ],
          [
            "APadding",
            []
          ],
          [
            "AResize",
            []
          ]
        ]
      },
      {
        "name": "AxisElement",
        "comment": " Encodable axis element. Used for customising some part of an axis.\n",
        "args": [],
        "cases": [
          [
            "EAxis",
            []
          ],
          [
            "ETicks",
            []
          ],
          [
            "EGrid",
            []
          ],
          [
            "ELabels",
            []
          ],
          [
            "ETitle",
            []
          ],
          [
            "EDomain",
            []
          ]
        ]
      },
      {
        "name": "AxisProperty",
        "comment": " Generated by [axBandPosition](#axBandPosition), [axDomain](#axDomain),\n[axDomainColor](#axDomainColor), [axDomainOpacity](#axDomainOpacity),\n[axDomainWidth](#axDomainWidth), [axEncode](#axEncode), [axFormat](#axFormat),\n[axGrid](#axGrid), [axGridColor](#axGridColor), [axGridDash](#axGridDash),\n[axGridOpacity](#axGridOpacity), [axGridScale](#axGridScale), [axGridWidth](#axGridWidth),\n[axLabels](#axLabels), [axLabelAlign](#axLabelAlign), [axLabelBaseline](#axLabelBaseline),\n[axLabelBound](#axLabelBound), [axLabelColor](#axLabelColor), [axLabelFlush](#axLabelFlush),\n[axLabelFlushOffset](#axLabelFlushOffset), [axLabelFont](#axLabelFont), [axLabelFontSize](#axLabelFontSize)\n[axLabelFontWeight](#axLabelFontWeight), [axLabelLimit](#axLabelLimit), [axLabelOpacity](#axLabelOpacity)\n[axLabelOverlap](#axLabelOverlap), [axLabelPadding](#axLabelPadding), [axMaxExtent](#axMaxExtent),\n[axMinExtent](#axMinExtent), [axOffset](#axOffset), [axPosition](#axPosition),\n[axTicks](#axTicks), [axTickColor](#axTickColor), [axTickCount](#axTickCount),\n[axTemporalTickCount](#axTemporalTickCount), [axTickExtra](#axTickExtra),\n[axTickOffset](#axTickOffset), [axTickOpacity](#axTickOpacity), [axTickRound](#axTickRound),\n[axTickSize](#axTickSize), [axTickWidth](#axTickWidth), [axTitle](#axTitle),\n[axTitleAlign](#axTitleAlign), [axTitleAngle](#axTitleAngle), [axTitleBaseline](#axTitleBaseline),\n[axTitleColor](#axTitleColor),[axTitleFont](#axTitleFont), [axTitleFontSize](#axTitleFontSize),\n[axTitleFontWeight](#axTitleFontWeight), [axTitleLimit](#axTitleLimit), [axTitleOpacity](#axTitleOpacity),\n[axTitlePadding](#axTitlePadding), [axTitleX](#axTitleX), [axTitleY](#axTitleY),\n[axValues](#axValues) and [axZIndex](#axZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "AxisType",
        "comment": " Identifies the type of axis to be configured with [cfAxis](#cfAxis).\n",
        "args": [],
        "cases": [
          [
            "AxAll",
            []
          ],
          [
            "AxLeft",
            []
          ],
          [
            "AxTop",
            []
          ],
          [
            "AxRight",
            []
          ],
          [
            "AxBottom",
            []
          ],
          [
            "AxX",
            []
          ],
          [
            "AxY",
            []
          ],
          [
            "AxBand",
            []
          ]
        ]
      },
      {
        "name": "BinProperty",
        "comment": " Generated by [bnAnchor](#bnAnchor),\n[bnMaxBins](#bnMaxBins), [bnBase](#bnBase), [bnStep](#bnStep), [bnSteps](#bnSteps),\n[bnMinStep](#bnMinStep), [bnDivide](#bnDivide), [bnNice](#bnNice), [bnSignal](#bnSignal)\nand [bnAs](#bnAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Bind",
        "comment": " Generated by [iRange](#iRange), [iCheckbox](#iCheckbox), [iRadio](#iRadio),\n[iSelect](#iSelect), [iText](#iText), [iNumber](#iNumber), [iDate](#iDate),\n[iTime](#iTime), [iMonth](#iMonth), [iWeek](#iWeek), [iDateTimeLocal](#iDateTimeLocal),\n[iTel](#iTel) and [iColor](#iColor).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Boo",
        "comment": " Generated by [true](#true), [false](#false),\n[boos](#boos), [booSignal](#booSignal), [booSignals](#booSignals) and [booExpr](#booExpr)\n",
        "args": [],
        "cases": []
      },
      {
        "name": "BoundsCalculation",
        "comment": " The bounds calculation method to determine the extent of a sub-plot in a grid\nlayout. `Full` indicates the entire calculated bounds (including axes, title, and\nlegend) will be used. `Flush` indicates only the specified width and height values\nfor the group mark will be used. The flush setting can be useful when attempting\nto place sub-plots without axes or legends into a uniform grid structure.\n",
        "args": [],
        "cases": [
          [
            "Full",
            []
          ],
          [
            "Flush",
            []
          ]
        ]
      },
      {
        "name": "CInterpolate",
        "comment": " Type of color interpolation to apply when mapping a data field onto a color\nscale. Additionally, parameterised interpolation types generated by\n[cubeHelix](#cubeHelix), [cubeHelixLong](#cubeHelixLong), [hclLong](#hclLong),\n[hslLong](#hslLong) and [rgb](#rgb).\n",
        "args": [],
        "cases": [
          [
            "Hcl",
            []
          ],
          [
            "Hsl",
            []
          ],
          [
            "Lab",
            []
          ]
        ]
      },
      {
        "name": "Case",
        "comment": " Type of text case transformation. Used when pre-processing text as\npart of a count pattern transformation.\n",
        "args": [],
        "cases": [
          [
            "Lowercase",
            []
          ],
          [
            "Uppercase",
            []
          ],
          [
            "Mixedcase",
            []
          ]
        ]
      },
      {
        "name": "Clip",
        "comment": " Generated by [clEnabled](#clEnabled), [clPath](#clPath) and [clSphere](#clSphere).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ColorSchemeProperty",
        "comment": " Generated by [csScheme](#csScheme), [csCount](#csCount)\nand [csExtent](#csExtent).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ColorValue",
        "comment": " Generated by [cRGB](#cRGB), [cHSL](#cHSL), [cLAB](#cLAB) and [cHCL](#cHCL).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ConfigProperty",
        "comment": " Generated by\n[cfAutosize](#cfAutosize), [cfBackground](#cfBackground), [cfGroup](#cfGroup),\n[cfEvents](#cfEvents), [cfMark](#cfMark), [cfMarks](#cfMarks), [cfStyle](#cfStyle),\n[cfAxis](#cfAxis), [cfLegend](#cfLegend), [cfTitle](#cfTitle), and [cfScaleRange](#cfScaleRange).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ContourProperty",
        "comment": " Generated by\n[cnValues](#cnValues), [cnX](#cnX), [cnY](#cnY), [cnCellSize](#cnCellSize),\n[cnBandwidth](#cnBandWidth), [cnSmooth](#cnSmooth), [cnThresholds](#cnThresholds),\n[cnCount](#cnCount) and [cnNice](#cnNice).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "CountPatternProperty",
        "comment": " Generated by\n[cpPattern](#cpPattern), [cpCase](#cpCase), [cpStopwords](#cpStopwords) and\n[cpAs](#cprAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "CrossProperty",
        "comment": " Generated by [crFilter](#crFilter) and [crAs](#ccrAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Cursor",
        "comment": " Type of cursor to display. See the\n[CSS cursor documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)\n",
        "args": [],
        "cases": [
          [
            "CAuto",
            []
          ],
          [
            "CDefault",
            []
          ],
          [
            "CNone",
            []
          ],
          [
            "CContextMenu",
            []
          ],
          [
            "CHelp",
            []
          ],
          [
            "CPointer",
            []
          ],
          [
            "CProgress",
            []
          ],
          [
            "CWait",
            []
          ],
          [
            "CCell",
            []
          ],
          [
            "CCrosshair",
            []
          ],
          [
            "CText",
            []
          ],
          [
            "CVerticalText",
            []
          ],
          [
            "CAlias",
            []
          ],
          [
            "CCopy",
            []
          ],
          [
            "CMove",
            []
          ],
          [
            "CNoDrop",
            []
          ],
          [
            "CNotAllowed",
            []
          ],
          [
            "CAllScroll",
            []
          ],
          [
            "CColResize",
            []
          ],
          [
            "CRowResize",
            []
          ],
          [
            "CNResize",
            []
          ],
          [
            "CEResize",
            []
          ],
          [
            "CSResize",
            []
          ],
          [
            "CWResize",
            []
          ],
          [
            "CNEResize",
            []
          ],
          [
            "CNWResize",
            []
          ],
          [
            "CSEResize",
            []
          ],
          [
            "CSWResize",
            []
          ],
          [
            "CEWResize",
            []
          ],
          [
            "CNSResize",
            []
          ],
          [
            "CNESWResize",
            []
          ],
          [
            "CNWSEResize",
            []
          ],
          [
            "CZoomIn",
            []
          ],
          [
            "CZoomOut",
            []
          ],
          [
            "CGrab",
            []
          ],
          [
            "CGrabbing",
            []
          ]
        ]
      },
      {
        "name": "DataProperty",
        "comment": " Specify a property to customise data loading. In addition to declaring `DaSphere`\nfor a global sphere, they are more usually generated by the functions\n[daFormat](#daFormat), [daSource](#daSource), [daSources](#daSources),\n[daValue](#daValue),[daOn](#daOn) and [daUrl](#daUrl).\n",
        "args": [],
        "cases": [
          [
            "DaSphere",
            []
          ]
        ]
      },
      {
        "name": "DataReference",
        "comment": " Generated by [daDataset](#daDataset), [daField](#daField), [daFields](#daFields),\n[daSignal](#daSignal), [daValues](#daValues) [daReferences](#daReferences) and\n[daSort](#daSort).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DataType",
        "comment": " Type of data to be parsed when reading input data. Additional parameterised\ndata type format specifications generated by [foDate](#foDate) and [foUtc](#foUtc).\n",
        "args": [],
        "cases": [
          [
            "FoNum",
            []
          ],
          [
            "FoBoo",
            []
          ]
        ]
      },
      {
        "name": "DensityFunction",
        "comment": " Specify a density function as either a Probability Density Function (PDF)\nor a Cumulative Density Function (CDF).\n",
        "args": [],
        "cases": [
          [
            "PDF",
            []
          ],
          [
            "CDF",
            []
          ]
        ]
      },
      {
        "name": "DensityProperty",
        "comment": " Generated by [dnExtent](#dnExtent), [dnMethod](#dnMethod),\n[dnSteps](#dnSteps) and [dnAs](#dnAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Distribution",
        "comment": " Generated by [diNormal](#diNormal),\n[diUniform](#diUniform), [diKde](#diKde) and [diMixture](#diMixture).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EncodingProperty",
        "comment": " Generated by [enEnter](#enEnter), [enUpdate](#enUpdate),\n[enExit](#enExit), [enHover](#enHover), [enName](#enName), [enInteractive](#enInteractive)\nand [enCustom](#enCustom).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventFilter",
        "comment": " Used to configure default event handling. Can be used to prevent or allow a\nset of event types from being handled.\n",
        "args": [],
        "cases": [
          [
            "Prevent",
            []
          ],
          [
            "Allow",
            []
          ]
        ]
      },
      {
        "name": "EventHandler",
        "comment": " Generated by [evHandler](#evHandler),\n[evUpdate](#evUpdate), [evEncode](#evEncode) and [evForce](#evForce).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventSource",
        "comment": " A source for an event selector. To specify a DOM node as a source (using a\nCSS selector string), use [esDom](#esDom).\n",
        "args": [],
        "cases": [
          [
            "ESAll",
            []
          ],
          [
            "ESView",
            []
          ],
          [
            "ESScope",
            []
          ],
          [
            "ESWindow",
            []
          ]
        ]
      },
      {
        "name": "EventStream",
        "comment": " Generated by [esObject](#esObject), [esSelector](#esSelector), [esSignal](#esSignal)\nand [esMerge](#esMerge).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventStreamProperty",
        "comment": " Generated by [esSource](#esSource), [esType](#esType), [esBetween](#esBetween),\n[esConsume](#esConsume), [esFilter](#esFilter), [esDebounce](#esDebounce),\n[esMarkName](#esMarkName), [esMark](#esMark), [esThrottle](#esThrottle) and\n[esStream](#esStream).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventType",
        "comment": " Event types used when handling user interaction events. The `Timer` type will\nfire an event at a regular interval determined by the number of milliseconds provided\nto the `esThrottle` function.\n",
        "args": [],
        "cases": [
          [
            "Click",
            []
          ],
          [
            "DblClick",
            []
          ],
          [
            "DragEnter",
            []
          ],
          [
            "DragLeave",
            []
          ],
          [
            "DragOver",
            []
          ],
          [
            "KeyDown",
            []
          ],
          [
            "KeyPress",
            []
          ],
          [
            "KeyUp",
            []
          ],
          [
            "MouseDown",
            []
          ],
          [
            "MouseMove",
            []
          ],
          [
            "MouseOut",
            []
          ],
          [
            "MouseOver",
            []
          ],
          [
            "MouseUp",
            []
          ],
          [
            "MouseWheel",
            []
          ],
          [
            "TouchEnd",
            []
          ],
          [
            "TouchMove",
            []
          ],
          [
            "TouchStart",
            []
          ],
          [
            "Wheel",
            []
          ],
          [
            "Timer",
            []
          ]
        ]
      },
      {
        "name": "Expr",
        "comment": " A Vega [Expr](https://vega.github.io/vega/docs/types/#Expr) that can be either\na field lookup or a full expression that is evaluated once per datum. Generated\nby [exField](#exField) and [expr](#expr).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Facet",
        "comment": " Generated by [faAggregate](#faAggregate),\n[faField](#faField) and [faGroupBy](#faGroupBy).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Feature",
        "comment": " Generated by [featureSignal](#featureSignal) and [feName](#feName).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Field",
        "comment": " Generated by [fExpr](#fExpr),\n[fDatum](#fDatum), [fGroup](#fGroup), [field](#field), [fParent](#fParent) and\n[fSignal](#fSignal).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Force",
        "comment": " Generated by [foCollide](#foCollide), [foLink](#foLink), [foNBody](#foNBody),\n[foX](#foX) and [foY](#foY).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ForceProperty",
        "comment": " Generated by [fpDistance](#fpDistance), [fpDistanceMax](#fpDistanceMax),\n[fpDistanceMin](#fpDistanceMin), [fpId](#fpId), [fpIterations](#fpIterations),\n[fpStrength](#fpStrength) and [fpTheta](#fpTheta).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ForceSimulationProperty",
        "comment": " Generated by [fsAlpha](#fsAlpha),\n[fsAlphaMin](#fsAlphaMin), [fsAlphaTarget](#fsAlphaTarget), [fsAs](#fsAs),\n[fsForces](#fsForces), [fsIterations](#fsIterations), [fsRestart](#fsRestart),\n[fsStatic](#fsStatic) and [fsVelocityDecay](#fsVelocityDecay).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FormatProperty",
        "comment": " Specify the type of format a data source uses. `ParseAuto` can be used for\nperforming automatic type inference on data types. If more explicit control is needed\nthen `parse` can be used to specify the type for named fields.\n",
        "args": [],
        "cases": [
          [
            "JSON",
            []
          ],
          [
            "CSV",
            []
          ],
          [
            "TSV",
            []
          ],
          [
            "ParseAuto",
            []
          ]
        ]
      },
      {
        "name": "GeoJsonProperty",
        "comment": " Generated by [gjFields](#gjFields), [gjFeature](#gjFeature) and [gjSignal](#gjSignal).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "GeoPathProperty",
        "comment": " Generated by [gpField](#gpField), [gpAs](#gpAs) and [gpPointRadius](#gpPointRadius).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "GraticuleProperty",
        "comment": " Generated by\n[grField](#grField), [grExtent](#grExtent), [grExtentMajor](#grExtentMajor),\n[grExtentMinor](#grExtentMinor), [grStep](#grStep), [grStepMajor](#grStepMajor),\n[grStepMinor](#grStepMinor) and [grPrecision](#grPrecision).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "GridAlign",
        "comment": " Specify a type of layout alignment to apply to grid rows and columns. `AlignNone`\nindicates a flow layout will be used, in which adjacent plots are simply placed\none after the other. `AlignEach` indicates elements will be aligned into a clean\ngrid structure, but each row or column may be of variable size. `AlignAll` indicates\nelements will be aligned and each row or column will be sized identically based\non the maximum observed size. To used different row and column layouts, use `grAlignRow`\nand `grAlignColumn`.\n",
        "args": [],
        "cases": [
          [
            "AlignAll",
            []
          ],
          [
            "AlignEach",
            []
          ],
          [
            "AlignNone",
            []
          ]
        ]
      },
      {
        "name": "HAlign",
        "comment": " Horizontal alignment of some text such as on an axis or legend.\n",
        "args": [],
        "cases": [
          [
            "AlignCenter",
            []
          ],
          [
            "AlignLeft",
            []
          ],
          [
            "AlignRight",
            []
          ]
        ]
      },
      {
        "name": "ImputeMethod",
        "comment": " The imputation method to be used when assigning values to missing data values.\n`ByValue` allows a specific value to be assigned for missing values while the other\nmethods will calculate a value based on a group of existing values.\n",
        "args": [],
        "cases": [
          [
            "ByValue",
            []
          ],
          [
            "ByMean",
            []
          ],
          [
            "ByMedian",
            []
          ],
          [
            "ByMax",
            []
          ],
          [
            "ByMin",
            []
          ]
        ]
      },
      {
        "name": "ImputeProperty",
        "comment": " Generated by\n<imKeyVals>, [imMethod](#imMethod), [imGroupBy](#imGroupBy) and\n[imValue](#imValue).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "InputProperty",
        "comment": " Generated by [inDebounce](#inDebounce), [inElement](#inElement),\n[inOptions](#inOptions), [inMin](#inMin), [inMax](#inMax), [inStep](#inStep),\n[inPlaceholder](#inPlaceholder) and [inAutocomplete](#inAutocomplete).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "JoinAggregateProperty",
        "comment": " Generated\nby [jaGroupBy](#jaGroupBy), [jaFields](#jaFields), [jaOps](#jaOps) and [jaAs](#jaAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LayoutProperty",
        "comment": " Generated by\n[loAlign](#loAlign), [loBounds](#loBounds), [loColumns](#loColumns), [loPadding](#loPadding),\n[loPaddingRC](#loPaddingRC), [loOffset](#loOffset), [loOffsetRC](#loOffsetRC),\n[loHeaderBand](#loHeaderBand), [loHeaderBandRC](#loHeaderBandRC), [loFooterBand](#loFooterBand),\n[loFooterBandRC](#loFooterBandRC), [loTitleBand](#loTitleBand) and\n[loTitleBandRC](#loTitleBandRC).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendEncoding",
        "comment": " Generated by [enLegend](#enLegend), [enTitle](#enTitle),\n[enLabels](#enLabels), [enSymbols](#enSymbols) and [enGradient](#enGradient).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendOrientation",
        "comment": " Position of a legend relative to the visualization it describes.\n",
        "args": [],
        "cases": [
          [
            "Left",
            []
          ],
          [
            "TopLeft",
            []
          ],
          [
            "Top",
            []
          ],
          [
            "TopRight",
            []
          ],
          [
            "Right",
            []
          ],
          [
            "BottomRight",
            []
          ],
          [
            "Bottom",
            []
          ],
          [
            "BottomLeft",
            []
          ],
          [
            "None",
            []
          ]
        ]
      },
      {
        "name": "LegendProperty",
        "comment": " Generated by [leType](#leType), [leDirection](#leDirection), [leOrient](#leOrient),\n[leFill](#leFill), [leOpacity](#leOpacity), [leShape](#leShape), [leSize](#leSize),\n[leStroke](#leStroke), [leStrokeDash](#leStrokeDash), [leEncode](#leEncode),\n[leFormat](#leFormat), [leGridAlign](#leGridAlign), [leClipHeight](#leClipHeight),\n[leColumns](#leColumns), [leColumnPadding](#leColumnPadding), [leRowPadding](#leRowPadding),\n[leCornerRadius](#leCornerRadius), [leFillColor](#leFillColor), [leOffset](#leOffset),\n[lePadding](#lePadding), [leStrokeColor](#leStrokeColor), [leStrokeWidth](#leStrokeWidth),\n[leGradientLength](#leGradientLength), [leGradientLabelLimit](#leGradientLabelLimit),\n[leGradientLabelOffset](#leGraidentLabelOffset), [leGradientOpacity](#leGradientOpacity),\n[leGradientThickness](#leGradientThickness), [leGradientStrokeColor](#leGradientStrokeColor),\n[leGradientStrokeWidth](#leGradientStrokeWidth), [leLabelAlign](#leLabelAlign),\n[leLabelBaseline](#leLabelBaseline), [leLabelColor](#leLabelColor), [leLabelFont](#leLabelFont),\n[leLabelFontSize](#leLabelFontSize), [leLabelFontWeight](#leLabelFontWeight),\n[leLabelLimit](#leLabelLimit), [leLabelOpacity](#leLabelOpacity), [leLabelOffset](#leLabelOffset),\n[leLabelOverlap](#leLabelOverlap), [leSymbolFillColor](#leSymbolFillColor),\n[leSymbolOpacity](#leSymbolOpacity), [leSymbolOffset](#leSymbolOffset),\n[leSymbolSize](#leSymbolSize), [leSymbolStrokeColor](#leSymbolStrokeColor),\n[leSymbolStrokeWidth](#leSymbolStrokeWidth), [leSymbolType](#leSymbolType),\n[leTickCount](#leTickCount), [leTemporalTickCount](#leTemporalTickCount),\n[leTitle](#leTitle), [leTitleAlign](#leTitleAlign), [leTitleBaseline](#leTitleBaseline),\n[leTitleColor](#leTitleColor), [leTitleFont](#leTitleFont), [leTitleFontSize](#leTitleFontSize),\n[leTitleFontWeight](#leTitleFontWeight), [leTitleLimit](#leTitleLimit),\n[leTitleOpacity](#leTitleOpacity) [leTitlePadding](#leTitlePadding),\n[leValues](#leValues) and [leZIndex](#leZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendType",
        "comment": " Type of legend. `LSymbol` representing legends with discrete items and `LGradient`\nfor those representing continuous data.\n",
        "args": [],
        "cases": [
          [
            "LSymbol",
            []
          ],
          [
            "LGradient",
            []
          ]
        ]
      },
      {
        "name": "LinkPathProperty",
        "comment": " Generated by [lpSourceY](#lpSourceY),\n[lpTargetX](#lpTargetX), [lpTargetY](#lpTargetY), [lpOrient](#lpOrient),\n[lpShape](#lpShape) and [lpAs](#lpAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LinkShape",
        "comment": " Shape of a line indicating path between nodes.\n",
        "args": [],
        "cases": [
          [
            "LinkLine",
            []
          ],
          [
            "LinkArc",
            []
          ],
          [
            "LinkCurve",
            []
          ],
          [
            "LinkDiagonal",
            []
          ],
          [
            "LinkOrthogonal",
            []
          ]
        ]
      },
      {
        "name": "LookupProperty",
        "comment": " Generated by [luValues](#luValues),\n[luAs](#luAs) and [luDefault](#luDefault).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Mark",
        "comment": " Type of visual mark used to represent data in the visualization.\n",
        "args": [],
        "cases": [
          [
            "Arc",
            []
          ],
          [
            "Area",
            []
          ],
          [
            "Image",
            []
          ],
          [
            "Group",
            []
          ],
          [
            "Line",
            []
          ],
          [
            "Path",
            []
          ],
          [
            "Rect",
            []
          ],
          [
            "Rule",
            []
          ],
          [
            "Shape",
            []
          ],
          [
            "Symbol",
            []
          ],
          [
            "Text",
            []
          ],
          [
            "Trail",
            []
          ]
        ]
      },
      {
        "name": "MarkInterpolation",
        "comment": " Indicate mark interpolation style.\n",
        "args": [],
        "cases": [
          [
            "Basis",
            []
          ],
          [
            "Bundle",
            []
          ],
          [
            "Cardinal",
            []
          ],
          [
            "CatmullRom",
            []
          ],
          [
            "Linear",
            []
          ],
          [
            "Monotone",
            []
          ],
          [
            "Natural",
            []
          ],
          [
            "Stepwise",
            []
          ],
          [
            "StepAfter",
            []
          ],
          [
            "StepBefore",
            []
          ]
        ]
      },
      {
        "name": "MarkProperty",
        "comment": " Generated by [maX](#maX),\n[maX2](#maX2), [maXC](#maXC), [maWidth](#maWidth), [maY](#maY), [maY2](#maY2), [maYC](#maYC),\n[maHeight](#maHeight), [maOpacity](#maOpacity), [maFill](#maFill), [maFillOpacity](#maFillOpacity),\n[maStroke](#maStroke), [maStrokeOpacity](#maStrokeOpacity), [maStrokeWidth](#maStrokeWidth),\n[maStrokeCap](#maStrokeCap), [maStrokeDash](#maStrokeDash), [maStrokeDashOffset](#maStrokeDashOffset),\n[maStrokeJoin](#maStrokeJoin), [maStrokeMiterLimit](#maStrokeMiterLimit), [maCursor](#maCursor),\n[maHRef](#maHRef), [maTooltip](#maTooltip), [maZIndex](#maZIndex), [maAlign](#maAlign),\n[maBaseline](#maBaseline), [maCornerRadius](#maCornerRadius), [maInterpolate](#maInterpolate),\n[maTension](#maTension), [maDefined](#maDefined), [maSize](#maSize), [maStartAngle](#maStartAngle),\n[maEndAngle](#maEndAngle), [maPadAngle](#maPadAngle), [maInnerRadius](#maInnerRadius),\n[maOuterRadius](#maOuterRadius), [maOrient](#maOrient), [maGroupClip](#maGroupClip),\n[maUrl](#maUrl), [maAspect](#maAspect), [maPath](#maPath), [maShape](#maShape),\n[maSymbol](#maSymbol), [maAngle](#maAngle), [maDir](#maDir), [maDx](#maDx), [maDy](#maDy),\n[maEllipsis](#maEllipsis), [maFont](#maFont), [maFontSize](#maFontSize),\n[maFontWeight](#maFontWeight), [maFontStyle](#maFontStyle), [maLimit](#maLimit),\n[maRadius](#maRadius), [maText](#maText) and [maTheta](#maTheta).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Num",
        "comment": " Generated by [num](#num), [nums](#nums),\n[numSignal](#numSignal), [numSignals](#numSignals), [numList](#numList),\n[numExpr](#numExpr) and [numNull](#numNull)\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Operation",
        "comment": " Type of aggregation operation.\n",
        "args": [],
        "cases": [
          [
            "ArgMax",
            []
          ],
          [
            "ArgMin",
            []
          ],
          [
            "Average",
            []
          ],
          [
            "CI0",
            []
          ],
          [
            "CI1",
            []
          ],
          [
            "Count",
            []
          ],
          [
            "Distinct",
            []
          ],
          [
            "Max",
            []
          ],
          [
            "Mean",
            []
          ],
          [
            "Median",
            []
          ],
          [
            "Min",
            []
          ],
          [
            "Missing",
            []
          ],
          [
            "Q1",
            []
          ],
          [
            "Q3",
            []
          ],
          [
            "Stderr",
            []
          ],
          [
            "Stdev",
            []
          ],
          [
            "Stdevp",
            []
          ],
          [
            "Sum",
            []
          ],
          [
            "Valid",
            []
          ],
          [
            "Variance",
            []
          ],
          [
            "Variancep",
            []
          ]
        ]
      },
      {
        "name": "Order",
        "comment": " Indicate an ordering, usually when sorting.\n",
        "args": [],
        "cases": [
          [
            "Ascend",
            []
          ],
          [
            "Descend",
            []
          ]
        ]
      },
      {
        "name": "Orientation",
        "comment": " Indicate desired orientation of a mark, legend or link path (e.g. horizontally or vertically\noriented bars). Note that not all can use `Radial` orientation.\n",
        "args": [],
        "cases": [
          [
            "Horizontal",
            []
          ],
          [
            "Vertical",
            []
          ],
          [
            "Radial",
            []
          ]
        ]
      },
      {
        "name": "OverlapStrategy",
        "comment": " Type of overlap strategy to be applied when there is not space to show all\nitems on an axis.\n",
        "args": [],
        "cases": [
          [
            "ONone",
            []
          ],
          [
            "OParity",
            []
          ],
          [
            "OGreedy",
            []
          ]
        ]
      },
      {
        "name": "PackProperty",
        "comment": " Generated by [paField](#paField),\n[paSort](#paSort), [paSize](#paSize), [paRadius](#paRadius), [paPadding](#paPadding)\nand [paAs](#paAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PartitionProperty",
        "comment": " Generated by [ptField](#ptField), [ptSort](#ptSort), [ptPadding](#ptPadding),\n[ptRound](#ptRound), [ptSize](#ptSize) and [ptAs](#ptAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PieProperty",
        "comment": " Generated by [piField](#piField),\n[piStartAngle](#piStartAngle), [piEndAngle](#piEndAngle), [piSort](#piSort) and\n[piAs](#piAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PivotProperty",
        "comment": " Generated by [piGroupBy](#piGroupBy),\n[piLimit](#piLimit) and [piOp](#piOp).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Projection",
        "comment": " Type of global map projection.\n",
        "args": [],
        "cases": [
          [
            "Albers",
            []
          ],
          [
            "AlbersUsa",
            []
          ],
          [
            "AzimuthalEqualArea",
            []
          ],
          [
            "AzimuthalEquidistant",
            []
          ],
          [
            "ConicConformal",
            []
          ],
          [
            "ConicEqualArea",
            []
          ],
          [
            "ConicEquidistant",
            []
          ],
          [
            "Equirectangular",
            []
          ],
          [
            "Gnomonic",
            []
          ],
          [
            "Mercator",
            []
          ],
          [
            "NaturalEarth1",
            []
          ],
          [
            "Orthographic",
            []
          ],
          [
            "Stereographic",
            []
          ],
          [
            "TransverseMercator",
            []
          ]
        ]
      },
      {
        "name": "ProjectionProperty",
        "comment": " Generated by\n[prType](#prType), [prClipAngle](#prClipAngle), [prClipExtent](#prClipExtent),\n[prScale](#prScale), [prTranslate](#prTranslate), [prCenter](#prCenter), [prRotate](#prRotate),\n[prPointRadius](#prPointRadius), [prPrecision](#prPrecision), [prFit](#prFit),\n[prExtent](#prExtent), [prSize](#prSize), [prCoefficient](#prCoefficient),\n[prDistance](#prDistance), [prFraction](#prFraction), [prLobes](#prLobes),\n[prParallel](#prParallel), [prRadius](#prRadius), [prRatio](#prRatio), [prSpacing](#prSpacing),\nand [prTilt](#prTilt).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Scale",
        "comment": " Type of scale transformation to apply.\n",
        "args": [],
        "cases": [
          [
            "ScLinear",
            []
          ],
          [
            "ScPow",
            []
          ],
          [
            "ScSqrt",
            []
          ],
          [
            "ScLog",
            []
          ],
          [
            "ScTime",
            []
          ],
          [
            "ScUtc",
            []
          ],
          [
            "ScSequential",
            []
          ],
          [
            "ScOrdinal",
            []
          ],
          [
            "ScBand",
            []
          ],
          [
            "ScPoint",
            []
          ],
          [
            "ScQuantile",
            []
          ],
          [
            "ScQuantize",
            []
          ],
          [
            "ScBinLinear",
            []
          ],
          [
            "ScBinOrdinal",
            []
          ]
        ]
      },
      {
        "name": "ScaleDomain",
        "comment": " Generated by [doNums](#doNums),\n[doStrs](#doStrs) and [doData](#doData).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleNice",
        "comment": " Specify the way a scale can be rounded to 'nice' numbers.\n",
        "args": [],
        "cases": [
          [
            "NMillisecond",
            []
          ],
          [
            "NSecond",
            []
          ],
          [
            "NMinute",
            []
          ],
          [
            "NHour",
            []
          ],
          [
            "NDay",
            []
          ],
          [
            "NWeek",
            []
          ],
          [
            "NMonth",
            []
          ],
          [
            "NYear",
            []
          ],
          [
            "NTrue",
            []
          ],
          [
            "NFalse",
            []
          ]
        ]
      },
      {
        "name": "ScaleProperty",
        "comment": " Generated by [scType](#scType), [scDomain](#scDomain),\n[scDomainMax](#scDomainMax), [scDomainMin](#scDomainMin), [scDomainMid](#scDomainMid),\n[scDomainRaw](#scDomainRaw), [scRange](#scRange), [scReverse](#scReverse),\n[scRound](#scRound), [scClamp](#scClamp), [scInterpolate](#scInterpolate),\n[scPadding](#scPadding), [scNice](#scNice), [scZero](#scZero), [scExponent](#scExponent),\n[scBase](#scBase), [scAlign](#scAlign), [scDomainImplicit](#scDomainImplicit),\n[scPaddingInner](#scPaddingInner), [scPaddingOuter](#scPaddingOuter) and\n[scRangeStep](#scRangeStep).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleRange",
        "comment": " Describes a scale range of scale output values. In addition to the preset default\noptions (`RaWidth`, `RaHeight` etc.), scale ranges can be generated by [raNums](#raNums),\n[raStrs](#raStrs), [raValues](#raValues), [raSignal](#raSignal), [raScheme](#raScheme),\n[raData](#raData), [raStep](#raStep) and [raCustomDefault](#raCustomDefault).\n",
        "args": [],
        "cases": [
          [
            "RaWidth",
            []
          ],
          [
            "RaHeight",
            []
          ],
          [
            "RaSymbol",
            []
          ],
          [
            "RaCategory",
            []
          ],
          [
            "RaDiverging",
            []
          ],
          [
            "RaOrdinal",
            []
          ],
          [
            "RaRamp",
            []
          ],
          [
            "RaHeatmap",
            []
          ]
        ]
      },
      {
        "name": "Side",
        "comment": " Indicate a rectangular side. Can be used to specify an axis position.\n",
        "args": [],
        "cases": [
          [
            "SLeft",
            []
          ],
          [
            "SRight",
            []
          ],
          [
            "STop",
            []
          ],
          [
            "SBottom",
            []
          ]
        ]
      },
      {
        "name": "SignalProperty",
        "comment": " Generated by [siName](#siName), [siBind](#siBind),\n[siDescription](#siDescription), [siOn](#siOn), [siUpdate](#siUpdate),\n[siReact](#siReact), [siValue](#siValue) and [siPushOuter](#siPushOuter).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "SortProperty",
        "comment": " Allow the type of sorting to be customised.\n",
        "args": [],
        "cases": [
          [
            "Ascending",
            []
          ],
          [
            "Descending",
            []
          ]
        ]
      },
      {
        "name": "Source",
        "comment": " Generated by [srData](#srData) and [srFacet](#srFacet).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Spiral",
        "comment": " Specify a spiraling type. Used for the sequential positioning of words in a wordcloud.\n",
        "args": [],
        "cases": [
          [
            "Archimedean",
            []
          ],
          [
            "Rectangular",
            []
          ]
        ]
      },
      {
        "name": "StackOffset",
        "comment": " Indicate the type of offsetting to apply when stacking. `OfZero` uses a baseline\nat the foot of a stack, `OfCenter` uses a central baseline with stacking both above\nand below it. `OfNormalize` rescales the stack to a common height while preserving\nthe relative size of stacked quantities.\n",
        "args": [],
        "cases": [
          [
            "OfZero",
            []
          ],
          [
            "OfCenter",
            []
          ],
          [
            "OfNormalize",
            []
          ]
        ]
      },
      {
        "name": "StackProperty",
        "comment": " Generated by [stField](#stField),\n[stGroupBy](#stGroupBy), [stSort](#stSort), [stOffset](#stOffset) and\n[stAs](#stAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Str",
        "comment": " Generated by [str](#str), [strs](#strs), [strList](#strList), [strSignal](#strSignal),\n[strSignals](#strSignals), [strExpr](#strExpr) and [strNull](#strNull).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "StrokeCap",
        "comment": " Type of stroke cap.\n",
        "args": [],
        "cases": [
          [
            "CButt",
            []
          ],
          [
            "CRound",
            []
          ],
          [
            "CSquare",
            []
          ]
        ]
      },
      {
        "name": "StrokeJoin",
        "comment": " Type of stroke join.\n",
        "args": [],
        "cases": [
          [
            "JMiter",
            []
          ],
          [
            "JRound",
            []
          ],
          [
            "JBevel",
            []
          ]
        ]
      },
      {
        "name": "Symbol",
        "comment": " Identifies a type of symbol.\n",
        "args": [],
        "cases": [
          [
            "SymCircle",
            []
          ],
          [
            "SymSquare",
            []
          ],
          [
            "SymCross",
            []
          ],
          [
            "SymDiamond",
            []
          ],
          [
            "SymTriangleUp",
            []
          ],
          [
            "SymTriangleDown",
            []
          ],
          [
            "SymTriangleLeft",
            []
          ],
          [
            "SymTriangleRight",
            []
          ]
        ]
      },
      {
        "name": "TextDirection",
        "comment": " Direction text is rendered. This determines which end of a text string is\ntruncated if it cannot be displayed within a restricted space.\n",
        "args": [],
        "cases": [
          [
            "LeftToRight",
            []
          ],
          [
            "RightToLeft",
            []
          ]
        ]
      },
      {
        "name": "TimeUnit",
        "comment": " Describes a unit of time. Useful for encoding and transformations. For\ndetails see the\n[Vega scale documentation](https://vega.github.io/vega/docs/scales/#quantitative).\n",
        "args": [],
        "cases": [
          [
            "Year",
            []
          ],
          [
            "Month",
            []
          ],
          [
            "Week",
            []
          ],
          [
            "Day",
            []
          ],
          [
            "Hour",
            []
          ],
          [
            "Minute",
            []
          ],
          [
            "Second",
            []
          ],
          [
            "Millisecond",
            []
          ]
        ]
      },
      {
        "name": "TitleFrame",
        "comment": " Indicate the way a title anchor position is calculated. `FrBounds` implies\ntext anchor is relative to the full bounding box whereas `FrGroup` implies it is\nrelative to the group width/height.\n",
        "args": [],
        "cases": [
          [
            "FrBounds",
            []
          ],
          [
            "FrGroup",
            []
          ]
        ]
      },
      {
        "name": "TitleProperty",
        "comment": " Generated by [tiOrient](#tiOrient),\n[tiAnchor](#tiAnchor), [tiAngle](#tiAngle), [tiAlign](#tiAlign), [tiBaseline](#tiBaseline),\n[tiColor](#tiColor), [tiEncode](#tiEncode), [tiFont](#tiFont), [tiFontSize](#tiFontSize),\n[tiFontWeight](#tiFontWeight), [tiFrame](#tiFrame), [tiInteractive](#tiInteractive),\n[tiLimit](#tiLimit), [tiName](#tiName), [tiStyle](#tiStyle), [tiOffset](#tiOffset) and\n[tiZIndex](#tiZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TopMarkProperty",
        "comment": " Generated by [mType](#mType),\n[mClip](#mClip), [mDescription](#mDescription), [mEncode](#mEncode), [mFrom](#mFrom),\n[mInteractive](#mInteractive), [mKey](#mKey), [mName](#mName), [mOn](#mOn),\n[mSort](#mSort), [mTransform](#mTransform), [mRole](#mRole), [mStyle](#mStyle),\n[mGroup](#mGroup) and [mZIndex](#mZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Transform",
        "comment": " Generated by [trAggregate](#trAggregate), [trBin](#trBin), [trCollect](#trCollect),\n[trContour](#trContour), [trCountPattern](#trCountPattern), [trCross](#trCross),\n[trCrossFilter](#trCrossFilter), [trCrossFilterAsSignal](#trCrossFilterAsSignal),\n[trDensity](#trDensity), [trExtent](#trExtent), [trExtentAsSignal](#trExtentAsSignal),\n[trFilter](#trFilter), [trFlatten](#trFlatten), [trFlattenAs](#trFlattenAs),\n[trFold](#trFold), [trFoldAs](#trFoldAs), [trForce](#trForce), [trFormula](#trFormula),\n[trFormulaInitOnly](#trFormulaInitOnly), [trGeoJson](#trGeoJson), [trGeoPath](#trGeoPath),\n[trGeoPoint](#trGeoPoint), [trGeoPointAs](#trGeoPointAs), [trGeoShape](#trGeoShape),\n[trGraticule](#trGraticule), [trIdentifier](#trIdentifier), [trImpute](#trImpute),\n[trJoinAggregate](#trJoinAggregate), [trLinkPath](#trLinkPath), [trLookup](#trLookup),\n[trNest](#trNest), [trPack](#trPack), [trPartition](#trPartition), [trPie](#trPie),\n[trPivot](#trPivot), [trProject](#trProject), [trResolveFilter](#trResolveFilter),\n[trSample](#trSample), [trSequence](#trSequence), [trStack](#trStack),\n[trStratify](#trStratify), [trTree](#trTree), [trTreeLinks](#trTreeLinks),\n[trTreemap](#trTreemap), [trVoronoi](#trVoronoi), [trWindow](#trWindow) and\n[trWordCloud](#trWordCloud).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TreeMethod",
        "comment": " A tree layout method used in a tree transform.\n",
        "args": [],
        "cases": [
          [
            "Tidy",
            []
          ],
          [
            "Cluster",
            []
          ]
        ]
      },
      {
        "name": "TreeProperty",
        "comment": " Generated by [teField](#teField), [teSort](#teSort), [teMethod](#teMethod),\n[teSize](#teSize), [teNodeSize](#teNodeSize) and [teAs](#teAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TreemapMethod",
        "comment": " A treemap layout method used in a treemap transform.\n",
        "args": [],
        "cases": [
          [
            "Squarify",
            []
          ],
          [
            "Resquarify",
            []
          ],
          [
            "Binary",
            []
          ],
          [
            "Dice",
            []
          ],
          [
            "Slice",
            []
          ],
          [
            "SliceDice",
            []
          ]
        ]
      },
      {
        "name": "TreemapProperty",
        "comment": " Generated by [tmField](#tmField), [tmSort](#tmSort), [tmMethod](#tmMethod),\n[tmPadding](#tmPadding), [tmPaddingInner](#tmPaddingInner), [tmPaddingOuter](#tmPaddingOuter),\n[tmPaddingTop](#tmPaddingTop), [tmPaddingRight](#tmPaddingRight), [tmPaddingBottom](#tmPaddingBottom),\n[tmPaddingLeft](#tmPaddingLeft), [tmRatio](#tmRatio), [tmRound](#tmRound), [tmSize](#tmSize)\nand [tmAs](#tmAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TriggerProperty",
        "comment": " Generated by [tgInsert](#tgInsert), [tgRemove](#tgRemove), [tgRemoveAll](#tgRemoveAll),\n[tgToggle](#tgToggle) and [tgModifyValues](#tgModifyValues).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "VAlign",
        "comment": " Vertical alignment of some text or an image mark. Note that the `Alphabetic`\ntype constructor applies only to text marks.\n",
        "args": [],
        "cases": [
          [
            "AlignTop",
            []
          ],
          [
            "AlignMiddle",
            []
          ],
          [
            "AlignBottom",
            []
          ],
          [
            "Alphabetic",
            []
          ]
        ]
      },
      {
        "name": "VProperty",
        "comment": " Top-level Vega properties (see the\n[specification documentation](https://vega.github.io/vega/docs/specification/)).\n\n**Data properties** specify the input data to be visualized. Generated by\n[`dataSource`](#dataSource) that can collect together data tables such as those\nread from a URL or generated inline.\n\n**Signal properties** specify dynamic variables that respond reactively to other\nsignals or interactions. Generated by [`signals`](#signals).\n\n**Scale properties** map data values to visual channels such as position, or color.\nGenerated by [`scales`](#scales).\n\n**Projection properties** specify how geospatial data referenced with\nlongitude, latitude coordinates are projected onto a plane for visualization.\nGenerated by [`projections`](#projections).\n\n**Axis properties** specify how spatial scale mappings are visualized, such as with\ntick marks, grid lines and labels. Generated by [`axes`](#axes).\n\n**Legend properties** specify how visual scale mappings such as color, shape and\nsize are visualized. Generated by [`legends`](#legends).\n\n**Title properties** specify how a visualization title should appear. Generated\nby [`title`](#title).\n\n** Layout properties** specify how a group of visual marks are organised within\na grid. This allows visualizations to be composed of other visualizations, for\nexample in a dashboard or collection of small multiples. Generated by [`layout`](#layout).\n\n**Mark properties** specify how to visually encode data with graphical primitives\nsuch as points, lines and other symbols. Generated by [`marks`](#marks).\n\n**Top-level group encodings** specify the appearance of the chart's data rectangle.\nFor example setting the background color of the plotting area. Generated by\n[`encode`](#encode).\n\n**Config properties** specify default settings of a specification. Allows consistent\nand easily modifiable styles to be applied to a visualization. Generated by\n[`config`](#config).\n\n**Supplementary properties** add metadata and some styling to one or more visualizations.\nGenerated by [`width`](#width), [`height`](#height), [`padding`](#padding),\n[`paddings`](#paddings), [`autosize`](#autosize), [`background`](#background)\nand [`description`](#description).\n\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Value",
        "comment": " Generated by [vStr](#vStr), [vStrs](#vStrs), [vNum](#vNum),\n[vNums](#vNums), [vTrue](#vTrue), [vFalse](#vFalse), [vBoos](#vBoos),\n[vObject](#vObject), [vKeyValue](#vKeyValue), [vValues](#vValues), [vSignal](#vSignal),\n[vColor](#vColor), [vField](#vField), [vScale](#vScale), [vScaleField](#vScaleField),\n[vBand](#vBand), [vExponent](#vExponent), [vMultiply](#vMultiply), [vOffset](#vOffset),\n[vRound](#vRound), [vNull](#vNull) and [ifElse](#ifElse).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "VoronoiProperty",
        "comment": " Generated by [voExtent](#voExtent), [voSize](#voSize) and [voAs](#voAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WOperation",
        "comment": " Operations that may be applied during a window transformation.\n",
        "args": [],
        "cases": [
          [
            "RowNumber",
            []
          ],
          [
            "Rank",
            []
          ],
          [
            "DenseRank",
            []
          ],
          [
            "PercentRank",
            []
          ],
          [
            "CumeDist",
            []
          ],
          [
            "Ntile",
            []
          ],
          [
            "Lag",
            []
          ],
          [
            "Lead",
            []
          ],
          [
            "FirstValue",
            []
          ],
          [
            "LastValue",
            []
          ],
          [
            "NthValue",
            []
          ]
        ]
      },
      {
        "name": "WindowOperation",
        "comment": " Generated by [wnOperation](#wnOperation), [wnOperationOn](#wnOperationOn) and\n[wnAggOperation](#wnAggOperation).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WindowProperty",
        "comment": " Generated by [wnSort](#wnSort), [wnGroupBy](#wnGroupBy), [wnFrame](#wnFrame)\nand [wnIgnorePeers](#wnIgnorePeers).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WordcloudProperty",
        "comment": " Generated by\n[wcFont](#wcFont), [wcFontStyle](#wcFontStyle), [wcFontWeight](#wcFontWeight),\n[wcFontSize](#wcFontSize), [wcFontSizeRange](#wcFontSizeRange), [wcPadding](#wcPadding),\n[wcRotate](#wcRotate), [wcText](#wcText), [wcSize](#wcSize), [wcSprial](#wcSpiral)\nand [wcAs](#wcAs).\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "agAs",
        "comment": " The output field names generated when performing an aggregation transformation.\nThe list of field names should align with the fields operations provided by `agFields`\nand `agOps`. If not provided, automatic names are generated by appending `_field`\nto the operation name.\n",
        "type": "List String -> Vega.AggregateProperty"
      },
      {
        "name": "agCross",
        "comment": " Specify whether or not the full cross-product of all `groupby` values should\nbe included in the output of an aggregation transformation.\n",
        "type": "Vega.Boo -> Vega.AggregateProperty"
      },
      {
        "name": "agDrop",
        "comment": " Specify whether or not empty (zero count) groups should be dropped when in an\naggregation transformation.\n",
        "type": "Vega.Boo -> Vega.AggregateProperty"
      },
      {
        "name": "agFields",
        "comment": " Specify the data fields to compute aggregate functions when performing an\naggregation transformation. The list of fields should align with the operations\nand field names provided by `agOps` and `agAs`. If no fields and operations are\nspecified, a count aggregation will be used by default.\n",
        "type": "List Vega.Field -> Vega.AggregateProperty"
      },
      {
        "name": "agGroupBy",
        "comment": " Specify the data fields to group by when performing an aggregation transformation.\nIf not specified, a single group containing all data objects will be used.\n",
        "type": "List Vega.Field -> Vega.AggregateProperty"
      },
      {
        "name": "agKey",
        "comment": " Specify a field to act as a unique key when performing an [agGroupBy](#agGroupBy)\naggregation. This can speed up the aggregation but should only be used when there\nis redundancy in the list of groupBy fields (as there is when binning for example).\n\n    transform\n        [ trBin (field \"examScore\") (nums [ 0, 100 ]) []\n        , trAggregate\n            [ agKey (field \"bin0\")\n            , agGroupBy [ field \"bin0\", field \"bin1\" ]\n            , agOps [ Count ]\n            , agAs [ \"count\" ]\n            ]\n        ]\n\n",
        "type": "Vega.Field -> Vega.AggregateProperty"
      },
      {
        "name": "agOps",
        "comment": " The aggregation operations to apply to the fields when performing an\naggregation transformation. The list of operations should align with the fields\noutput field names provided by `agFields` and `agAs`.\n",
        "type": "List Vega.Operation -> Vega.AggregateProperty"
      },
      {
        "name": "anchorSignal",
        "comment": " Specify that an anchor position is to be determined by a named signal.\nThe signal should generate one of `start`, `middle` or `end`.\n",
        "type": "String -> Vega.Anchor"
      },
      {
        "name": "autosize",
        "comment": " Specify how the view is sized.\n\n    toVega\n        [ width 500, padding 5, autosize [ AFit, AResize ], ds, mk [] ]\n\n",
        "type": "List Vega.Autosize -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "autosizeSignal",
        "comment": " Specify that an auto-sizing rule is to be determined by a named signal.\n",
        "type": "String -> Vega.Autosize"
      },
      {
        "name": "axBandPosition",
        "comment": " Specify an interpolation fraction indicating where, for band scales, axis ticks\nshould be positioned. A value of 0 places ticks at the left edge of their bands.\nA value of 0.5 places ticks in the middle of their bands.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axDomain",
        "comment": " Specify whether or not the domain (the axis baseline) should be included as\npart of an axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axDomainColor",
        "comment": " Specify the color of an axis domain line.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axDomainOpacity",
        "comment": " Specify the opacity of an axis domain line.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axDomainWidth",
        "comment": " Specify the width in pixels of an axis domain line.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axEncode",
        "comment": " Mark encodings for custom axis styling.\n",
        "type": "List ( Vega.AxisElement, List Vega.EncodingProperty ) -> Vega.AxisProperty"
      },
      {
        "name": "axFormat",
        "comment": " The format specifier pattern for axis labels. For numerical values, must be\na legal [d3-format specifier](https://github.com/d3/d3-format#locale_format).\nFor date-time values, must be a legal\n[d3-time-format](https://github.com/d3/d3-time-format#locale_format) specifier.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axGrid",
        "comment": " Specify whether or not grid lines should be included as part of an axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axGridColor",
        "comment": " Specify the color of an axis's grid lines.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axGridDash",
        "comment": " Specify the stroke dash of an axis's grid lines as a list of dash-gap lengths\nor `[]` for a solid line (default).\n",
        "type": "List Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axGridOpacity",
        "comment": " Specify the opacity of an axis's grid lines.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axGridScale",
        "comment": " Name of the scale to use for including grid lines. By default grid lines are\ndriven by the same scale as the ticks and labels.\n",
        "type": "String -> Vega.AxisProperty"
      },
      {
        "name": "axGridWidth",
        "comment": " Specify the width of an axis's grid lines in pixel units.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelAlign",
        "comment": " Specify the horizontal alignment of axis tick labels.\n",
        "type": "Vega.HAlign -> Vega.AxisProperty"
      },
      {
        "name": "axLabelAngle",
        "comment": " Specify the angle of text for an axis.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelBaseline",
        "comment": " Specify the vertical alignment of axis tick labels.\n",
        "type": "Vega.VAlign -> Vega.AxisProperty"
      },
      {
        "name": "axLabelBound",
        "comment": " Specify how or if labels should be hidden if they exceed the axis range. If the\nparameter is `NumNull`, no check for label size is made. A number specifies\nthe permitted overflow in pixels that can be tolerated.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelColor",
        "comment": " Specify the color of an axis label.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFlush",
        "comment": " Specify how labels at the beginning or end of the axis should be aligned\nwith the scale range. The parameter represents a pixel distance threshold. Labels\nwith anchor coordinates within this threshold distance for an axis end-point will be\nflush-adjusted. If `NumNull`, no flush alignment will be applied.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFlushOffset",
        "comment": " Specify the number of pixels by which to offset flush-adjusted labels\n(default 0). For example, a value of 2 will push flush-adjusted labels 2 pixels\noutward from the centre of the axis. Offsets can help the labels better visually\ngroup with corresponding axis ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFont",
        "comment": " Specify the font name of an axis label.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFontSize",
        "comment": " Specify the font size of an axis label.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFontWeight",
        "comment": " Specify the font weight of an axis label. This can be a number (e.g. `vNum 300`)\nor text (e.g. `vStr \"bold\"`).\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axLabelLimit",
        "comment": " Specify the maximum length in pixels of axis tick labels.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelOpacity",
        "comment": " Specify the opacity of an axis label.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelOverlap",
        "comment": " Specify the strategy to use for resolving overlap of axis labels.\n",
        "type": "Vega.OverlapStrategy -> Vega.AxisProperty"
      },
      {
        "name": "axLabelPadding",
        "comment": " Specify the padding in pixels between labels and ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabels",
        "comment": " Specify whether or not if labels should be included as part of an axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axMaxExtent",
        "comment": " The maximum extent in pixels that axis ticks and labels should use. This\ndetermines a maximum offset value for axis titles.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axMinExtent",
        "comment": " The minimum extent in pixels that axis ticks and labels should use. This\ndetermines a minimum offset value for axis titles.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axOffset",
        "comment": " The orthogonal offset in pixels by which to displace the axis from its position\nalong the edge of the chart.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axPosition",
        "comment": " The anchor position of the axis in pixels. For x-axes with top or bottom\norientation, this sets the axis group x coordinate. For y-axes with left or right\norientation, this sets the axis group y coordinate.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axTemporalTickCount",
        "comment": " Specify the tick interval for a temporal axis. The first parameter is\nthe type of temporal interval to use and the second the number of steps of that\ninterval between ticks. For example to specify a tick is requested at 3 month\nintervals (e.g. January, April, July, October):\n\n    ax =\n        axes\n            << axis \"xScale\" SBottom [ axTemporalTickCount Month (num 3) ]\n\nIf the second parameter is not a positive value, the number of ticks will be\nauto-generated for the given interval type.\n\n",
        "type": "Vega.TimeUnit -> Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickColor",
        "comment": " Specify the color of an axis's ticks.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTickCount",
        "comment": " A desired number of ticks, for axes visualizing quantitative scales. The\nresulting number may be different so that values are âniceâ (multiples of 2, 5, 10)\nand lie within the underlying scaleâs range.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickExtra",
        "comment": " Specify whether or not an extra axis tick should be added for the initial\nposition of an axis. This is useful for styling axes for band scales such that\nticks are placed on band boundaries rather in the middle of a band.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axTickOffset",
        "comment": " Specify the offset in pixels of an axis's ticks, labels and gridlines.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickOpacity",
        "comment": " Specify the opacity of an axis's ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickRound",
        "comment": " Specify whether or not pixel position values for an axis's ticks should be\nrounded to the nearest integer.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axTickSize",
        "comment": " Specify the size in pixels of axis ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickWidth",
        "comment": " Specify the width in pixels of an axis's ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTicks",
        "comment": " Specify whether or not ticks should be included as part of an axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axTitle",
        "comment": " A title for an axis.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTitleAlign",
        "comment": " Specify the horizontal alignment of an axis's title.\n",
        "type": "Vega.HAlign -> Vega.AxisProperty"
      },
      {
        "name": "axTitleAngle",
        "comment": " Specify the angle of an axis's title text.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleBaseline",
        "comment": " Specify the vertical alignment of an axis's title.\n",
        "type": "Vega.VAlign -> Vega.AxisProperty"
      },
      {
        "name": "axTitleColor",
        "comment": " Specify the color of an axis's title.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTitleFont",
        "comment": " Specify the font to be used for an axis's title.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTitleFontSize",
        "comment": " Specify the size of font in pixels for an axis's title.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleFontWeight",
        "comment": " Specify the font weight of an axis's title. This can be a number (e.g. `vNum 300`)\nor text (e.g. `vStr \"bold\"`).\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axTitleLimit",
        "comment": " Specify the maximum allowed length of an axis's title.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleOpacity",
        "comment": " Specify the opacity of an axis's title.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitlePadding",
        "comment": " Specify an offset in pixels between an axis's labels and title.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axTitleX",
        "comment": " Specify the X position of an axis title relative to the axis group, overriding\nthe standard layout.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleY",
        "comment": " Specify the Y position of an axis title relative to the axis group, overriding\nthe standard layout.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axValues",
        "comment": " Explicitly set an axis tick and label values.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axZIndex",
        "comment": " The z-index indicating the layering of an axis group relative to other axis,\nmark and legend groups. The default value is 0 and axes and grid lines are drawn\nbehind any marks defined in the same specification level. Higher values (1) will\ncause axes and grid lines to be drawn on top of marks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axes",
        "comment": " Create the axes used to visualize spatial scale mappings.\n\n    ax =\n        axes\n            << axis \"myXScale\" SBottom [ axTitle (str \"Population\") ]\n            << axis \"myYScale\" SLeft [ axTickCount (num 5) ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "axis",
        "comment": " Create a single axis used to visualize a spatial scale mapping. The first\nparameter is the name of the scale backing this axis, the second the position of\nthe axis relative to the data rectangle and the third a list of optional axis\nproperties. For example,\n\n    axes\n        << axis \"xScale\" SBottom [ axTitle \"Population\", axZIndex (num 1) ]\n\n",
        "type": "String -> Vega.Side -> List Vega.AxisProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "background",
        "comment": " The fill background color of a visualization. This should be specified as a\n[color string](https://vega.github.io/vega/docs/types/#Color).\n",
        "type": "Vega.Str -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "bcSignal",
        "comment": " Specify that the bounds calculation type is to be determined by a named signal.\n",
        "type": "String -> Vega.BoundsCalculation"
      },
      {
        "name": "black",
        "comment": " Convenience function for specifying a black color setting for marks that can\nbe colored (e.g. with [maStroke](#maStroke))\n",
        "type": "Vega.Value"
      },
      {
        "name": "bnAnchor",
        "comment": " Specify the value in the binned domain at which to anchor the bins of a bin\ntransform, shifting the bin boundaries if necessary to ensure that a boundary aligns\nwith the anchor value. If not specified, the minimum bin extent value serves as\nthe anchor.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnAs",
        "comment": " Specify the output fields to contain the extent of a binning transform\n(its start and end bin values). If not specified these can be retrieved as the `bin0`\nand `bin1` fields.\n",
        "type": "String -> String -> Vega.BinProperty"
      },
      {
        "name": "bnBase",
        "comment": " Specify the number base to use for automatic bin determination in a bin transform.\nIf not specified, base 10 is assumed.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnDivide",
        "comment": " Specify the allowable bin step sub-divisions when performing a binning transformation.\nThe parameter should evaluate to a list of numeric values. If not specified, the\ndefault of [5, 2] is used, which indicates that for base 10 numbers automatic bin\ndetermination can consider dividing bin step sizes by 5 and/or 2.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnMaxBins",
        "comment": " Specify the maximum number of bins to create with a bin transform.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnMinStep",
        "comment": " Specify the minimum allowable bin step size between bins when performing a bin\ntransform.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnNice",
        "comment": " Specify whether or not the bin boundaries in a binning transform will use human-friendly\nvalues such as multiples of ten.\n",
        "type": "Vega.Boo -> Vega.BinProperty"
      },
      {
        "name": "bnSignal",
        "comment": " Bind the specification of a binning transform (its start, step and stop properties)\nto a signal with the given name.\n",
        "type": "String -> Vega.BinProperty"
      },
      {
        "name": "bnStep",
        "comment": " Specify the exact step size to use between bins in a bin transform. This overrides\nsome other options such as `bnMaxBins`.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnSteps",
        "comment": " Specify a list of allowable step sizes between bins to choose from when performing\na bin transform.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "booExpr",
        "comment": " Specify an expression that when evaluated, will be a Boolean value.\n",
        "type": "Vega.Expr -> Vega.Boo"
      },
      {
        "name": "booSignal",
        "comment": " Specify the name of a signal that will generate a Boolean value.\n",
        "type": "String -> Vega.Boo"
      },
      {
        "name": "booSignals",
        "comment": " Specify a list of signals that will generate Boolean values.\n",
        "type": "List String -> Vega.Boo"
      },
      {
        "name": "boos",
        "comment": " Specify a list of Boolean literals.\n",
        "type": "List Bool -> Vega.Boo"
      },
      {
        "name": "cHCL",
        "comment": " Define a color in HCL space (parameters in H - C - L order).\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cHSL",
        "comment": " Define a color in HSL space (parameters in H - S - L order).\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cLAB",
        "comment": " Define a color in CIELab space (parameters in L - A - B order).\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cRGB",
        "comment": " Define a color in RGB space. Each of the three triplet values can be a numeric\nliteral, a signal, or subject to some scale.\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cfAutosize",
        "comment": " Specify the default autosizing properties of view.\n",
        "type": "List Vega.Autosize -> Vega.ConfigProperty"
      },
      {
        "name": "cfAxis",
        "comment": " Specify the default properties of axes.\n",
        "type": "Vega.AxisType -> List Vega.AxisProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfBackground",
        "comment": " Specify the default background of the view.\n",
        "type": "Vega.Str -> Vega.ConfigProperty"
      },
      {
        "name": "cfEvents",
        "comment": " Specify the default filtering of events. This can specified in the first parameter\nas either a 'whitelist' (`Allow`) or 'blacklist' (`Prevent`) comprised the event types\nto be considered in the second parameter. If that list is empty, all event types\nwill be placed in the black/white list.\n",
        "type": "Vega.EventFilter -> List Vega.EventType -> Vega.ConfigProperty"
      },
      {
        "name": "cfGroup",
        "comment": " Specify the default properties of the top-level group mark representing the\ndata rectangle of a chart.\n",
        "type": "List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfLegend",
        "comment": " Specify the default properties of legends.\n",
        "type": "List Vega.LegendProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfMark",
        "comment": " Specify the default properties of a given mark type.\n",
        "type": "Vega.Mark -> List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfMarks",
        "comment": " Specify the default properties of all marks.\n",
        "type": "List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfScaleRange",
        "comment": " Specify the properties defining named range lists used as part of scale specification.\nThe first parameter is the named range label (e.g. `RaOrdinal`, `RaCategory`, `RaHeamap`\netc.). The second is the new range of values to be associated with the named range.\n\n    cf =\n        config [ cfScaleRange RaHeatmap (raScheme (str \"greenblue\") []) ]\n\n",
        "type": "Vega.ScaleRange -> Vega.ScaleRange -> Vega.ConfigProperty"
      },
      {
        "name": "cfStyle",
        "comment": " Specify the properties of a named style. The first property is the name to\ngive the style, the second its mark properties.\n",
        "type": "String -> List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfTitle",
        "comment": " Specify the default properties of a title.\n",
        "type": "List Vega.TitleProperty -> Vega.ConfigProperty"
      },
      {
        "name": "clEnabled",
        "comment": " Specify whether or not clipping should be applied to a set of marks within a\ngroup mark.\n",
        "type": "Vega.Boo -> Vega.Clip"
      },
      {
        "name": "clPath",
        "comment": " Specify an arbitrary clipping path to be applied to a set of marks within a\nregion. The path should be a valid\n[SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n",
        "type": "Vega.Str -> Vega.Clip"
      },
      {
        "name": "clSphere",
        "comment": " Specify a cartographic projection with which to clip all marks to a projected\nsphere of the globe. This is useful in conjunction with map projections that\notherwise include projected content (such as graticule lines) outside the bounds\nof the globe.\n",
        "type": "Vega.Str -> Vega.Clip"
      },
      {
        "name": "cnBandwidth",
        "comment": " Specify the kernel density estimation bandwidth used in a contour transformation.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnCellSize",
        "comment": " Specify the size of cells used for density estimation in a contour transformation.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnCount",
        "comment": " Specify the desired number of contours used in a contour transformation. This\nwill be ignored if `cnThresholds` setting explicit contour values are provided.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnNice",
        "comment": " Specify whether or not contour threshold values should be automatically aligned\nto âniceâ, human-friendly values when performing a contour transformation. If true,\nthe number of thresholds may deviate from that provided by `cnCount`.\n",
        "type": "Vega.Boo -> Vega.ContourProperty"
      },
      {
        "name": "cnSmooth",
        "comment": " Specify whether or not contour polygons should be smoothed in a contour transformation.\nThis will be ignored if kernel density estimation is used.\n",
        "type": "Vega.Boo -> Vega.ContourProperty"
      },
      {
        "name": "cnThresholds",
        "comment": " Specify the explicit contour values to be generated by a contour transformation.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnValues",
        "comment": " Specify a grid of values over which to compute contours. If not provided,\n[trContour](#trContour) will instead compute contours of the kernel density\nestimate of input data.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnX",
        "comment": " Specify the x-coordinate field used for density estimation in a contour\ntransformation.\n",
        "type": "Vega.Field -> Vega.ContourProperty"
      },
      {
        "name": "cnY",
        "comment": " Specify the y-coordinate field used for density estimation in a contour\ntransformation.\n",
        "type": "Vega.Field -> Vega.ContourProperty"
      },
      {
        "name": "combineSpecs",
        "comment": " Combine a list of labelled specifications into a single specification that\nmay be passed to JavaScript for rendering. Useful for creating a single page with\nmultiple visualizations.\n\n    combineSpecs\n        [ ( \"vis1\", myFirstVis )\n        , ( \"vis2\", mySecondVis )\n        , ( \"vis3\", myOtherVis )\n        ]\n\n",
        "type": "List Vega.LabelledSpec -> Vega.Spec"
      },
      {
        "name": "config",
        "comment": " Create a collection of configuration settings. This allows default stylings\nto be defined for a collection of visualizations or visualization components.\n\n    cf =\n        config\n            [ cfMark Text [ maFont [ vStr \"Roboto Condensed, sans-serif\" ] ]\n            , cfTitle\n                [ tiFont (str \"Roboto Condensed, sans-serif\")\n                , tiFontWeight (vNum 500)\n                , tiFontSize (num 17)\n                ]\n            , cfAxis AxAll\n                [ axLabelFont (str \"Roboto Condensed, sans-serif\")\n                , axLabelFontSize (num 12)\n                ]\n            ]\n\n",
        "type": "List Vega.ConfigProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "cpAs",
        "comment": " Specify the names of the two output fields generated by a count pattern transformation.\nBy default they are named `text` and `count`.\n",
        "type": "String -> String -> Vega.CountPatternProperty"
      },
      {
        "name": "cpCase",
        "comment": " Specify how text case transformation to apply before performing a count pattern\ntransformation. The default of `Mixedcase` will leave text untransformed.\n",
        "type": "Vega.Case -> Vega.CountPatternProperty"
      },
      {
        "name": "cpPattern",
        "comment": " Specify a regular expression to define a match in a count pattern transformation.\nThe parameter should be a regular expression where any backslash symbols are escaped.\n\n    transform [ trCountPattern (field \"data\") [ cpPattern (str \"[\\\\w']{3,}\") ] ]\n\n",
        "type": "Vega.Str -> Vega.CountPatternProperty"
      },
      {
        "name": "cpStopwords",
        "comment": " Specify a regular expression to define the text to ignore when performing a\ncount pattern transformation. The parameter should be a regular expression where\nany backslash symbols are escaped.\n",
        "type": "Vega.Str -> Vega.CountPatternProperty"
      },
      {
        "name": "crAs",
        "comment": " Specify the names of the two output fields of a cross-product transform.\n",
        "type": "String -> String -> Vega.CrossProperty"
      },
      {
        "name": "crFilter",
        "comment": " Specify an optional filter for limiting the results of a cross-product transform.\n",
        "type": "Vega.Expr -> Vega.CrossProperty"
      },
      {
        "name": "csCount",
        "comment": " Specify the number of colors to use in a color scheme. This can be useful\nfor scale types such as quantize, which use the length of the scale range to\ndetermine the number of discrete bins for the scale domain.\n",
        "type": "Vega.Num -> Vega.ColorSchemeProperty"
      },
      {
        "name": "csExtent",
        "comment": " Specify the extent of the color range to use in sequential and diverging color\nschemes. The parameter should evaluate to a two-element list representing the min\nand max values of the extent. For example [0.2, 1] will rescale the color scheme\nsuch that color values in the range [0, 0.2] are excluded from the scheme.\n",
        "type": "Vega.Num -> Vega.ColorSchemeProperty"
      },
      {
        "name": "csScheme",
        "comment": " Specify the name of a color scheme to use.\n",
        "type": "Vega.Str -> Vega.ColorSchemeProperty"
      },
      {
        "name": "cubeHelix",
        "comment": " Cube-helix color interpolation. The parameter is a gamma value to control the\nbrightness of the color trajectory.\n",
        "type": "Float -> Vega.CInterpolate"
      },
      {
        "name": "cubeHelixLong",
        "comment": " A long path cube-helix color interpolation. The parameter is a gamma value to control the\nbrightness of the color trajectory.\n",
        "type": "Float -> Vega.CInterpolate"
      },
      {
        "name": "cursorValue",
        "comment": " A convenience function for generating a text string representing a given cursor\ntype. This can be used instead of specifying a cursor type as a literal string\nto avoid problems of mistyping its name.\n\n    mark Symbol\n        [ mEncode\n            [ enEnter\n                [ maY [ vScale \"yScale\", vNum 0, vOffset (vNum 1) ]\n                , maShape [ symbolValue SymTriangleDown ]\n                , maSize [ vNum 400 ]\n                ]\n            , enUpdate\n                [ maX [ vScale \"xScale\", vSignal \"currentYear\" ] ]\n            , enHover\n                [ maCursor [ cursorValue CPointer ] ]\n            ]\n        ]\n\n",
        "type": "Vega.Cursor -> Vega.Value"
      },
      {
        "name": "daDataset",
        "comment": " Reference a dataset with the given name.\n",
        "type": "String -> Vega.DataReference"
      },
      {
        "name": "daField",
        "comment": " Reference a data field with the given value.\n",
        "type": "Vega.Field -> Vega.DataReference"
      },
      {
        "name": "daFields",
        "comment": " Reference a collection of data fields with the given values.\n",
        "type": "List Vega.Field -> Vega.DataReference"
      },
      {
        "name": "daFormat",
        "comment": " Specify the data format when loading or generating a data set.\n",
        "type": "List Vega.FormatProperty -> Vega.DataProperty"
      },
      {
        "name": "daOn",
        "comment": " Specify updates to insert, remove, and toggle data values, or clear the data\nin a data set when trigger conditions are met.\n",
        "type": "List Vega.Trigger -> Vega.DataProperty"
      },
      {
        "name": "daReferences",
        "comment": " Reference a collection of nested data references.\n",
        "type": "List (List Vega.DataReference) -> Vega.DataReference"
      },
      {
        "name": "daSignal",
        "comment": " Make a data reference with a signal.\n",
        "type": "String -> Vega.DataReference"
      },
      {
        "name": "daSort",
        "comment": " Sort a data reference.\n",
        "type": "List Vega.SortProperty -> Vega.DataReference"
      },
      {
        "name": "daSource",
        "comment": " Specify a named data source when generating a data set.\n",
        "type": "String -> Vega.DataProperty"
      },
      {
        "name": "daSources",
        "comment": " Specify a collection of named data sources when generating a data set.\n",
        "type": "List String -> Vega.DataProperty"
      },
      {
        "name": "daUrl",
        "comment": " Specify the name of a data file to be loaded when generating a data set.\n",
        "type": "Vega.Str -> Vega.DataProperty"
      },
      {
        "name": "daValue",
        "comment": " Specify some inline data value(s) when generating a data set.\n",
        "type": "Vega.Value -> Vega.DataProperty"
      },
      {
        "name": "daValues",
        "comment": " Create a data reference from a list of literals. Useful when combining with\ndata references from existing data streams. For example\n\n    scale \"myScale\"\n      [ scDomain\n          (doData\n              [ daReferences\n                  [ [ daValues (vNums [ 2, 4 ]) ]\n                  , [ daDataset \"myData\", daField (field \"myField\") ]\n                  ]\n              ]\n          )\n      ]\n\n",
        "type": "Vega.Value -> Vega.DataReference"
      },
      {
        "name": "data",
        "comment": " Declare a named data set. Depending on the properties provided this may be\nfrom an external file, from a named data source or inline literal values.\n",
        "type": "String -> List Vega.DataProperty -> Vega.DataTable"
      },
      {
        "name": "dataColumn",
        "comment": " Create a column of data. A column has a name and a list of values. The final\nparameter is the list of any other columns to which this is added.\n",
        "type": "String -> Vega.Value -> List Vega.DataColumn -> List Vega.DataColumn"
      },
      {
        "name": "dataFromColumns",
        "comment": " Declare a data table from a list of column values. Each column contains values\nof the same type, but types may vary between columns. Columns should all contain\nthe same number of items; if not the dataset will be truncated to the length of\nthe shortest.\n\nThe first parameter should be the name given to the data table for later reference.\nField formatting specifications can be provided in the second parameter or as an\nempty list to use the default formatting. The columns are most easily generated\nwith `dataColumn`:\n\n    myData =\n        dataFromColumns \"animals\" [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataColumn \"Animal\" (vStrs [ \"Fish\", \"Dog\", \"Cat\" ])\n            << dataColumn \"Age\" (vNums [ 28, 12, 6 ])\n            << dataColumn \"Year\" (vStrs [ \"2010\", \"2014\", \"2015\" ])\n\n",
        "type": "String -> List Vega.FormatProperty -> List Vega.DataColumn -> Vega.DataTable"
      },
      {
        "name": "dataFromRows",
        "comment": " Declare a data table from a list of row values. Each row is specified with a\nlist of tuples where the first value is the column name, and the second the column\nvalue for that row. Each column can have a value of a different type but you must\nensure that when multiple rows are added, they match the types of other values in\nthe same column. Field formatting specifications can be provided in the first\nparameter or as an empty list to use the default formatting.\n\nRows are most easily generated with `dataRow`. If you are creating data inline\n(as opposed to reading from a file), generally, adding data by column is more\nefficient and less error-prone.\n\n    myData =\n        dataFromRows \"animals\" [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataRow [ ( \"Animal\", vStr \"Fish\" ), ( \"Age\", vNum 28 ), ( \"Year\", vStr \"2010\" ) ]\n            << dataRow [ ( \"Animal\", vStr \"Dog\" ), ( \"Age\", vNum 12 ), ( \"Year\", vStr \"2014\" ) ]\n\n",
        "type": "String -> List Vega.FormatProperty -> List Vega.DataRow -> Vega.DataTable"
      },
      {
        "name": "dataRow",
        "comment": " Create a row of data. A row comprises a list of (_columnName_, _value_) pairs.\nThe final parameter is the list of any other rows to which this is added.\n",
        "type": "List ( String, Vega.Value ) -> List Vega.DataRow -> List Vega.DataRow"
      },
      {
        "name": "dataSource",
        "comment": " Specify a data source to be used by a visualization. A data source is a collection\nof data tables which themselves may be generated inline, loaded from a URL or the\nresult of a transformation.\n\n      dataSource\n          [ data \"pop\" [ daUrl (str \"data/population.json\") ]\n          , data \"popYear\" [ daSource \"pop\" ] |> transform [ trFilter (expr \"datum.year == year\") ]\n          , data \"ageGroups\" [ daSource \"pop\" ] |> transform [ trAggregate [ agGroupBy [ field \"age\" ] ] ]\n          ]\n\n",
        "type": "List Vega.DataTable -> Vega.Data"
      },
      {
        "name": "densityFunctionSignal",
        "comment": " Specify a density function based on the value in the named signal.\n",
        "type": "String -> Vega.DensityFunction"
      },
      {
        "name": "diKde",
        "comment": " Specify a kernel density estimate (smoothed probability distribution)\nfor a set of numerical values. The first parameter is the data set containing\nthe source data (or empty string if not to be specified explicitly), the second\nthe name of the field containing the numerical values and the third the bandwidth\nof the kernel. If the bandwidth is 0, it will be estimated from the input data.\n",
        "type": "String -> Vega.Field -> Vega.Num -> Vega.Distribution"
      },
      {
        "name": "diMixture",
        "comment": " Specify a weighted mixture of probability distributions. The parameter should\nbe a list of tuples representing the component distributions and their corresponding\nweights.\n",
        "type": "List ( Vega.Distribution, Vega.Num ) -> Vega.Distribution"
      },
      {
        "name": "diNormal",
        "comment": " Specify a normal (Gaussian) probability distribution with a given mean (first\nparameter) and standard deviation (second parameter).\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Distribution"
      },
      {
        "name": "diUniform",
        "comment": " Specify a uniform probability distribution with given minimum (first\nparameter) and maximum (second parameter) bounds.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Distribution"
      },
      {
        "name": "dnAs",
        "comment": " Specify the output fields to contain a density transform's values (assigned\nto a field named in the first parameter) and probabilities (field named in the\nsecond parameter). If not specified, the output will allocated to fields named\n`value` and `probability`.\n",
        "type": "String -> String -> Vega.DensityProperty"
      },
      {
        "name": "dnExtent",
        "comment": " Specify a [min, max] domain from which to sample a distribution as part of a\ndensity transform.\n",
        "type": "Vega.Num -> Vega.DensityProperty"
      },
      {
        "name": "dnMethod",
        "comment": " Specify the type of distribution to generate for a density transform.\n",
        "type": "Vega.DensityFunction -> Vega.DensityProperty"
      },
      {
        "name": "dnSteps",
        "comment": " Specify the number of uniformly spaced steps to take along an extent domain\nduring a density transform.\n",
        "type": "Vega.Num -> Vega.DensityProperty"
      },
      {
        "name": "doData",
        "comment": " Specify a data reference object that specifies field values in one or more\ndata sets to define a scale domain.\n",
        "type": "List Vega.DataReference -> Vega.ScaleDomain"
      },
      {
        "name": "doNums",
        "comment": " Specify a numeric list literal (`Nums`) representing a scale domain.\n",
        "type": "Vega.Num -> Vega.ScaleDomain"
      },
      {
        "name": "doSignal",
        "comment": " Specify a signal representing a scale domain.\n",
        "type": "String -> Vega.ScaleDomain"
      },
      {
        "name": "doSignals",
        "comment": " Specify a list of signals representing a scale domain.\n",
        "type": "List String -> Vega.ScaleDomain"
      },
      {
        "name": "doStrs",
        "comment": " Specify a string list literal (`Strs`) representing a scale domain.\n",
        "type": "Vega.Str -> Vega.ScaleDomain"
      },
      {
        "name": "dsv",
        "comment": " Specify a DSV (delimited separated value) format with a custom delimiter.\nTypically used when specifying a data URL.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "enCustom",
        "comment": " Specify the properties of a named custom encoding set. To invoke the custom set a\nsignal event handler with an `encode` directive should be defined.\n",
        "type": "String -> List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enEnter",
        "comment": " Specify the properties to be encoded when a mark item is first instantiated\nor a visualization is resized.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enExit",
        "comment": " Specify the properties to be encoded when the data backing a mark item is removed.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enGradient",
        "comment": " Custom encoding for gradient (continuous) legends.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enHover",
        "comment": " Specify the properties to be encoded when a pointer hovers over a mark item.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enInteractive",
        "comment": " Specify whether or not a custom legend encoding set is to be interactive.\n",
        "type": "Vega.Boo -> Vega.EncodingProperty"
      },
      {
        "name": "enLabels",
        "comment": " Specify a custom encoding for legend labels.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enLegend",
        "comment": " Specify a custom encoding for a legend group mark.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enName",
        "comment": " Specify a name for a custom legend encoding set.\n",
        "type": "String -> Vega.EncodingProperty"
      },
      {
        "name": "enSymbols",
        "comment": " Custom encoding for symbol (discrete) legends.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enTitle",
        "comment": " Custom ecoding for a legend title.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enUpdate",
        "comment": " Specify the properties to be encoded when a mark item is updated such as in\nresponse to a signal change.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "encode",
        "comment": " Specify the encoding directives for the visual properties of the top-level\ngroup mark representing a chartâs data rectangle. For example, this can be used\nto set a background fill color for the plotting area, rather than the entire view.\n",
        "type": "List Vega.EncodingProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "esBetween",
        "comment": " Specify an event stream filter that lets only events that occur between the\ntwo given event streams from being handled. This is useful, for example, for\ncapturing pointer dragging as it is a pointer movement event stream that occurs\nbetween `MouseDown` and `MouseUp` events.\n\n    << signal \"myDrag\"\n        [ siValue (vNums [ 200, 200 ])\n        , siOn\n            [ evHandler\n                [esObject\n                    [ esBetween [ esMark Rect, esType MouseDown ] [ esSource ESView, esType MouseUp ]\n                    , esSource ESView\n                    , esType MouseMove\n                    ]\n                ]\n                [ evUpdate \"xy()\" ]\n            ]\n        ]\n\nThis is equivalent to the more compact, but more error-prone event stream selector:\n\n    esSelector (str \"[rect:mousedown, view:mouseup] > view:mousemove\")\n\n",
        "type": "List Vega.EventStreamProperty -> List Vega.EventStreamProperty -> Vega.EventStreamProperty"
      },
      {
        "name": "esConsume",
        "comment": " Specify whether or not an event stream is consumed once it has been captured.\nIf false, the event is made available for subsequent event handling.\n",
        "type": "Vega.Boo -> Vega.EventStreamProperty"
      },
      {
        "name": "esDebounce",
        "comment": " Specify the minimum time to wait between event occurrence and processing. If\na new event arrives during a debouncing window, the debounce timer will restart\nand only the new event will be captured.\n",
        "type": "Vega.Num -> Vega.EventStreamProperty"
      },
      {
        "name": "esDom",
        "comment": " Specify a DOM node as the source for an event selector. This should be referenced\nwith a standard [CSS selector](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors).\n",
        "type": "String -> Vega.EventSource"
      },
      {
        "name": "esFilter",
        "comment": " Specify the filter expressions that must evaluate to `True` in order for an\nevent to be captured. If multiple filters are provided they must all be satisfied\n(`and` operator) for the event to be captured.\n",
        "type": "List String -> Vega.EventStreamProperty"
      },
      {
        "name": "esMark",
        "comment": " Specify a mark type as the source for an event stream.\n",
        "type": "Vega.Mark -> Vega.EventStreamProperty"
      },
      {
        "name": "esMarkName",
        "comment": " Specify a named mark as the source for an event stream. The name given here\nmust correspond to the name provided to a mark via `mName`.\n",
        "type": "String -> Vega.EventStreamProperty"
      },
      {
        "name": "esMerge",
        "comment": " Specify a single event stream merging the given list of event streams.\n",
        "type": "List Vega.EventStream -> Vega.EventStream"
      },
      {
        "name": "esObject",
        "comment": " Specify an event stream for modelling user input. This function expects a stream\nobject definition which provides a more self-explanatory and robust form of\nspecification than using a selector string.\n",
        "type": "List Vega.EventStreamProperty -> Vega.EventStream"
      },
      {
        "name": "esSelector",
        "comment": " Specify an event stream for modelling user input. This function expects a\nshorthand event stream selector string, which is a more compact way of specifying\na stream than with `eventStream` but is more vulnerable to mistakes (as\nit is simply a string).\n",
        "type": "Vega.Str -> Vega.EventStream"
      },
      {
        "name": "esSignal",
        "comment": " Specify the name of a signal that triggers an event stream. This will allow\nan update to be triggered whenever the given signal changes.\n",
        "type": "String -> Vega.EventStream"
      },
      {
        "name": "esSource",
        "comment": " Specify a source for an event selector.\n",
        "type": "Vega.EventSource -> Vega.EventStreamProperty"
      },
      {
        "name": "esStream",
        "comment": " Specify an event stream that is to be used as input into a derived event stream.\nThis can be useful if several event streams have a common element, for example:\n\n    si =\n        let\n            esStart =\n                esMerge\n                    [ esObject [ esType MouseDown ]\n                    , esObject [ esType TouchStart ]\n                    ]\n\n            esEnd =\n                esObject [ esType TouchEnd ]\n        in\n        signals\n            << signal \"down\"\n                [ siValue vNull\n                , siOn\n                    [ evHandler [ esEnd ] [ evUpdate \"null\" ]\n                    , evHandler [ esStart ] [ evUpdate \"xy()\" ]\n                    ]\n                ]\n            << signal \"xCur\"\n                [ siValue vNull\n                , siOn\n                    [ evHandler [ esObject [ esStream esStart, esType TouchEnd ] ]\n                        [ evUpdate \"slice(xDom)\" ]\n                    ]\n                ]\n\n",
        "type": "Vega.EventStream -> Vega.EventStreamProperty"
      },
      {
        "name": "esThrottle",
        "comment": " Specify the minimum time in milliseconds between captured events (default 0).\nNew events that arrive within the throttling window will be ignored. For timer events,\nthis property determines the interval between timer ticks.\n",
        "type": "Vega.Num -> Vega.EventStreamProperty"
      },
      {
        "name": "esType",
        "comment": " Specify an event stream type used when handling user interaction events.\n",
        "type": "Vega.EventType -> Vega.EventStreamProperty"
      },
      {
        "name": "evEncode",
        "comment": " Specify the name of a mark property encoding set to re-evaluate for the mark\nthat is the source of an input event. This is required if `evUpdate` is not specified.\n",
        "type": "String -> Vega.EventHandler"
      },
      {
        "name": "evForce",
        "comment": " Specify whether or not updates that do not change a signal value should propagate.\nFor example, if true and an input stream update sets the signal to its current value,\ndownstream signals will be notified of an update.\n",
        "type": "Vega.Boo -> Vega.EventHandler"
      },
      {
        "name": "evHandler",
        "comment": " Specify an event handler. The first parameter is the stream(s) of events to\nrespond to. The second, a list of handlers that respond to the event stream.\n\n    signal \"tooltip\"\n        [ siValue (vObject [])\n        , siOn\n            [ evHandler [esObject [esMark Rect, esType MouseOver] ] [ evUpdate \"datum\" ]\n            , evHandler [esObject [esMark Rect, esType MouseOut] ] [ evUpdate \"\" ]\n            ]\n        ]\n\n",
        "type": "List Vega.EventStream -> List Vega.EventHandler -> List Vega.EventHandler"
      },
      {
        "name": "evStreamSelector",
        "comment": " Specify an event selector used to generate an event stream.\n",
        "type": "Vega.Str -> Vega.EventStream"
      },
      {
        "name": "evUpdate",
        "comment": " Expression to be evaluated when an event occurs, the result of which becomes\nthe new signal value.\n",
        "type": "String -> Vega.EventHandler"
      },
      {
        "name": "exField",
        "comment": " Specify a field lookup that forms a Vega [Expr](https://vega.github.io/vega/docs/types/#Expr).\nIn contrast to an expression generated by `expr`, a field lookup is applied once\nto an entire field rather than evaluated once per datum.\n",
        "type": "String -> Vega.Expr"
      },
      {
        "name": "expr",
        "comment": " An expression to enable custom calculations specified in the [Vega expression\nlanguage](https://vega.github.io/vega/docs/expressions). In contrast to a field\nreference or signal, the expression is evaluated once per datum behaving like an\nanonymous (lambda) function.\n",
        "type": "String -> Vega.Expr"
      },
      {
        "name": "fDatum",
        "comment": " Perform a lookup on the current data object using the given field.\nOnce evaluated this is similar to simply providing a string value.\n",
        "type": "Vega.Field -> Vega.Field"
      },
      {
        "name": "fExpr",
        "comment": " Specify an expression that references a field but can perform calculations on\neach datum in the field. For example\n\n    fExpr \"scale('xScale', datum.Horsepower)\"\n\n",
        "type": "String -> Vega.Field"
      },
      {
        "name": "fGroup",
        "comment": " Specify a property of the enclosing group mark instance as a field value.\n",
        "type": "Vega.Field -> Vega.Field"
      },
      {
        "name": "fParent",
        "comment": " Specify a field of the enclosing group markâs data object as a field.\n",
        "type": "Vega.Field -> Vega.Field"
      },
      {
        "name": "fSignal",
        "comment": " Specify the name of signal that will generate a field name to reference.\n",
        "type": "String -> Vega.Field"
      },
      {
        "name": "faAggregate",
        "comment": " For data-driven facets, a list aggregate transform properties for the\naggregate data values generated for each facet group item.\n",
        "type": "List Vega.AggregateProperty -> Vega.Facet"
      },
      {
        "name": "faField",
        "comment": " For pre-faceted data, the name of the data field containing a list of data\nvalues to use as the local partition. This is required if using pre-faceted data.\n",
        "type": "Vega.Field -> Vega.Facet"
      },
      {
        "name": "faGroupBy",
        "comment": " For data-driven facets, specify a list of field names by which to partition\nthe data. This is required if using pre-faceted data.\n",
        "type": "List Vega.Field -> Vega.Facet"
      },
      {
        "name": "false",
        "comment": " Specify a Boolean false value.\n",
        "type": "Vega.Boo"
      },
      {
        "name": "feName",
        "comment": " Specify the name of a geoJSON feature. Can be used with [prFit](#prFit) to\nfit a map projection scaling and centre to a given geoJSON feature or feature\ncollection.\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType Orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (feName \"mapData\")\n                ]\n\n",
        "type": "String -> Vega.Feature"
      },
      {
        "name": "featureSignal",
        "comment": " Specify the signal that generates a geoJSON feature. Can be used with\n[prFit](#prFit) to fit a map projection scaling and centre to a given geoJSON\nfeature or feature collection.\n\n    ds =\n        dataSource\n            [ data \"myLongLatData\" []\n                |> transform\n                    [ trGeoJson\n                        [ gjFields (field \"longitude\") (field \"latitude\")\n                        , gjSignal \"feature\"\n                        ]\n                    ]\n            ]\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType Orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (featureSignal \"feature\")\n                ]\n\n",
        "type": "String -> Vega.Feature"
      },
      {
        "name": "field",
        "comment": " Specify the name of a field to reference.\n",
        "type": "String -> Vega.Field"
      },
      {
        "name": "foCenter",
        "comment": " Specify a force that pulls all nodes towards a shared centre point in a force\nsimulation. The two parameters specify the x and y coordinates of the centre point.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Force"
      },
      {
        "name": "foCollide",
        "comment": " Specify a collision detection force that pushes apart nodes whose circular\nradii overlap in a force simulation. The first parameter specifies the radius of\nthe node to which it applies. The second parameter enables the strength and number\nof iterations to be specified.\n",
        "type": "Vega.Num -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foDate",
        "comment": " Specify a date format for parsing data using\n[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format).\nAn empty string indicates default date formatting but care should be taken as\ndifferent browsers may have different default date parsing. Being explicit about the\ndate format is usually safer.\n",
        "type": "String -> Vega.DataType"
      },
      {
        "name": "foLink",
        "comment": " Specify the link constraints that cause nodes to be pushed apart towards a target\nseparation distance. The first parameter is the name of the data set containing the\nlink objects, each of which should contain `source` and `target` fields indicating\nnode objects. The second parameter enables the id, distance, strength and number\nof iterations to be specified. If an id field parameter is provided, it is used\nto relate link objects and node objects. Otherwise, the source and target fields\nshould provide indices into the array of node objects.\n",
        "type": "Vega.Str -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foNBody",
        "comment": " Specify an n-body force that causes nodes to either attract or repel each other\nin a force simulation. The parameter enables the strength, theta value, and min/max\ndistances over which the force acts to be specified.\n",
        "type": "List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foUtc",
        "comment": " Specify a utc date format for parsing data using\n[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format).\n",
        "type": "String -> Vega.DataType"
      },
      {
        "name": "foX",
        "comment": " Specify a force attraction towards a particular x-coordinate (first parameter),\nwith a given strength (second parameter) on a per-node basis.\n",
        "type": "Vega.Field -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foY",
        "comment": " Specify a force attraction towards a particular y-coordinate (first parameter),\nwith a given strength (second parameter) on a per-node basis.\n",
        "type": "Vega.Field -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "formatPropertySignal",
        "comment": " Specify a format property via a named signal. The signal should generate a\nvalid property (e.g. `csv`, `tsv`, `json`). Useful when dynamic loading of data\nwith different formats is required.\n",
        "type": "String -> Vega.FormatProperty"
      },
      {
        "name": "fpDistance",
        "comment": " Specify the distance in pixels by which the link constraint should separate\nnodes (default 30).\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpDistanceMax",
        "comment": " Specify the maximum distance over which an n-body force acts. If two nodes\nexceed this value, they will not exert forces on each other.\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpDistanceMin",
        "comment": " Specify the minimum distance over which an n-body force acts. If two nodes\nare closer than this value, the exerted forces will be as if they are distanceMin\napart (default 1).\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpId",
        "comment": " Specify an optional data field for a nodeâs unique identifier. If provided,\nthe source and target fields of each link should use these values to indicate\nnodes.\n",
        "type": "Vega.Field -> Vega.ForceProperty"
      },
      {
        "name": "fpIterations",
        "comment": " Specify the number of iterations to run collision detection or link constraints\n(default 1) in a force directed simulation.\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpStrength",
        "comment": " Specify the relative strength of a force or link constraint in a force\nsimulation.\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpTheta",
        "comment": " Specify the approximation parameter for aggregating more distance forces in\na force-directed simulation (default 0.9).\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fsAlpha",
        "comment": " Specify the energy level or âtemperatureâ of a simulation under a force transform.\nAlpha values lie in the range [0, 1]. Internally, the simulation will decrease the\nalpha value over time, causing the magnitude of updates to diminish.\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsAlphaMin",
        "comment": " Specify the minimum amount by which to lower the alpha value on each simulation\niteration under a force transform.\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsAlphaTarget",
        "comment": " Specify the target alpha value to which a simulation converges under a force\ntransformation.\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsAs",
        "comment": " Specify the names of the output fields to which node positions and velocities\nare written after a force transformation. The default is [\"x\", \"y\", \"vx\", \"vy\"]\ncorresponding to the order of parameter names to be provided.\n",
        "type": "String -> String -> String -> String -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsForces",
        "comment": " Specify the forces to include in a force-directed simulation resulting from\na force transform.\n",
        "type": "List Vega.Force -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsIterations",
        "comment": " Specify the number of iterations in a force transformation when in static\nmode (default 300).\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsRestart",
        "comment": " Specify whether a simulation in a force transformation should restart when\nnode object fields are modified.\n",
        "type": "Vega.Boo -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsStatic",
        "comment": " Specify whether a simulation in a force transformation should be computed in\nbatch to produce a static layout (true) or should be animated (false).\n",
        "type": "Vega.Boo -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsVelocityDecay",
        "comment": " Specify the 'friction' to be applied to a simulation in a force transformation.\nThis is applied after the application of any forces during an iteration, each nodeâs\nvelocity is multiplied by 1 - velocityDecay (default 0.4).\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "gjFeature",
        "comment": " Specify the field containing the GeoJSON objects to be consolidated into a feature\ncollection by a geoJSON transform.\n",
        "type": "Vega.Field -> Vega.GeoJsonProperty"
      },
      {
        "name": "gjFields",
        "comment": " Specify the fields containing longitude (first parameter) and latitude (second\nparameter) to be consolidated into a feature collection by a geoJSON transform.\n",
        "type": "Vega.Field -> Vega.Field -> Vega.GeoJsonProperty"
      },
      {
        "name": "gjSignal",
        "comment": " Specify the name of the a new signal to capture the output of generated by\na geoJSON transform.\n",
        "type": "String -> Vega.GeoJsonProperty"
      },
      {
        "name": "gpAs",
        "comment": " Specify the output field in which to write a generated shape instance following\na geoShape or geoPath transformation.\n",
        "type": "String -> Vega.GeoPathProperty"
      },
      {
        "name": "gpField",
        "comment": " Specify the data field containing GeoJSON data when applying a geoShape or\ngeoPath transformation. If unspecified, the full input data object will be used.\n",
        "type": "Vega.Field -> Vega.GeoPathProperty"
      },
      {
        "name": "gpPointRadius",
        "comment": " Specify the default radius (in pixels) to use when drawing GeoJSON Point and\nMultiPoint geometries. An expression value may be used to set the point radius\nas a function of properties of the input GeoJSON.\n",
        "type": "Vega.Num -> Vega.GeoPathProperty"
      },
      {
        "name": "grAlignColumn",
        "comment": " Specify a type of layout alignment to apply to grid columns. This can be used in\ncases when alignment rules are different for rows and columns.\n",
        "type": "Vega.GridAlign -> Vega.GridAlign"
      },
      {
        "name": "grAlignRow",
        "comment": " Specify a type of layout alignment to apply to grid rows. This can be used in\ncases when alignment rules are different for rows and columns.\n",
        "type": "Vega.GridAlign -> Vega.GridAlign"
      },
      {
        "name": "grExtent",
        "comment": " Specify both the major and minor extents of a graticule to be the same values.\nShould be a two-element list representing longitude and latitude extents.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grExtentMajor",
        "comment": " Specify the major extent of a graticule. Should be a two-element list representing\nlongitude and latitude extents.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grExtentMinor",
        "comment": " Specify the minor extent of a graticule. Should be a two-element list representing\nlongitude and latitude extents.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grField",
        "comment": " Specify the field used to bin when generating a graticule.\n",
        "type": "Vega.Field -> Vega.GraticuleProperty"
      },
      {
        "name": "grPrecision",
        "comment": " Specify the precision in degrees with which graticule arcs are generated. The\ndefault value is 2.5 degrees.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grStep",
        "comment": " Specify both the major and minor step angles of a graticule to be the same values.\nShould be a two-element list representing longitude and latitude spacing.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grStepMajor",
        "comment": " Specify the major step angles of a graticule. Should be a two-element list\nrepresenting longitude and latitude spacing.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grStepMinor",
        "comment": " Specify the minor step angles of a graticule. Should be a two-element list\nrepresenting longitude and latitude spacing.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "gridAlignSignal",
        "comment": " Specify a type of layout alignment based on the value of the given signal.\n",
        "type": "String -> Vega.GridAlign"
      },
      {
        "name": "hAlignSignal",
        "comment": " Specify the horizontal alignment of some text based on the value of the\ngiven signal.\n",
        "type": "String -> Vega.HAlign"
      },
      {
        "name": "hCenter",
        "comment": " Convenience function for indicating a central horizontal alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "hLeft",
        "comment": " Convenience function for indicating a left horizontal alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "hRight",
        "comment": " Convenience function for indicating a right horizontal alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "hclLong",
        "comment": " A long-path hue-chroma-luminance color interpolation.\n",
        "type": "Vega.CInterpolate"
      },
      {
        "name": "height",
        "comment": " Override the default height of the visualization. If not specified the height\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "hslLong",
        "comment": " A long-path hue-saturation-lightness color interpolation.\n",
        "type": "Vega.CInterpolate"
      },
      {
        "name": "iCheckbox",
        "comment": " A checkbox input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iColor",
        "comment": " A color selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iDate",
        "comment": " A date selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iDateTimeLocal",
        "comment": " A local data time selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iMonth",
        "comment": " A month selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iNumber",
        "comment": " A numeric input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iRadio",
        "comment": " A radio buttons input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iRange",
        "comment": " A slider input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iSelect",
        "comment": " A drop-down list input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iTel",
        "comment": " A telephone number input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iText",
        "comment": " A free text input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iTime",
        "comment": " A time selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iWeek",
        "comment": " A week selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "ifElse",
        "comment": " Specify a conditional list of values dependent on whether an expression (first\nparameter) evaluates as true. The second and third parameters represent the 'then'\nand 'else' branches of the test.\n\nTo include nested conditions, subsequent `ifElse` calls should be placed in the\n'else' branch. For example:\n\n    maFontWeight\n        [ ifElse \"indata('selected', 'source', datum.id)\"\n            [ vStr \"bold\" ]\n            [ ifElse \"indata('selected', 'target', datum.id)\"\n                [ vStr \"bold\" ]\n                [ vNull ]\n            ]\n        ]\n\n",
        "type": "String -> List Vega.Value -> List Vega.Value -> Vega.Value"
      },
      {
        "name": "imGroupBy",
        "comment": " Specify a list of fields by which to group values in an impute transform.\nImputation is then performed on a per-group basis, such as a within group mean\nrather than global mean.\n",
        "type": "List Vega.Field -> Vega.ImputeProperty"
      },
      {
        "name": "imKeyVals",
        "comment": " Specify an additional collection of key values that should be considered for\nimputation as part of an impute transform.\n",
        "type": "Vega.Value -> Vega.ImputeProperty"
      },
      {
        "name": "imMethod",
        "comment": " Specify the imputation method to be used as part of an impute transform. If\nnot specified the default `ByMean` method will be used.\n",
        "type": "Vega.ImputeMethod -> Vega.ImputeProperty"
      },
      {
        "name": "imValue",
        "comment": " Specify the value to use when an imputation method is set to `ByValue` in an\nimpute transform.\n",
        "type": "Vega.Value -> Vega.ImputeProperty"
      },
      {
        "name": "inAutocomplete",
        "comment": " Specify whether autocomplete should be turned on or off for input elements that\nsupport it.\n",
        "type": "Bool -> Vega.InputProperty"
      },
      {
        "name": "inDebounce",
        "comment": " Specify that event handling should be delayed until the specified milliseconds\nhave elapsed since the last event was fired. This helps to limit event broadcasting.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "inElement",
        "comment": " A CSS selector string indicating the parent element to which the input element\nshould be added. This allows the option of the input element to be outside the\nvisualization container, which could be used for linking separate visualizations.\n",
        "type": "String -> Vega.InputProperty"
      },
      {
        "name": "inMax",
        "comment": " Specify the maximum value for a range slider input element.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "inMin",
        "comment": " Specify the minimum value for a range slider input element.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "inOptions",
        "comment": " Specify the options to be selected from a Radio or Select input element.\n",
        "type": "Vega.Value -> Vega.InputProperty"
      },
      {
        "name": "inPlaceholder",
        "comment": " Specify the place-holding text for input elements before any value has been\nentered.\n",
        "type": "String -> Vega.InputProperty"
      },
      {
        "name": "inStep",
        "comment": " Specify the step value (increment between adjacent selectable values) for a\nrange slider input element.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "jaAs",
        "comment": " Specify the output field names generated by a join aggregate transform.\n",
        "type": "List String -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jaFields",
        "comment": " Specify the fields to aggregate in join aggregate transform.\n",
        "type": "List Vega.Field -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jaGroupBy",
        "comment": " Specify the fields to group by in a join aggregate transform.\n",
        "type": "List Vega.Field -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jaOps",
        "comment": " Specify the operations in a join aggregate transform.\n",
        "type": "List Vega.Operation -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jsonProperty",
        "comment": " Specify the property to be extracted from some JSON when it has some\nsurrounding structure or meta-data. For example, specifying the property\n`values.features` is equivalent to retrieving `json.values.features` from the\nloaded JSON object with a custom delimiter.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "keyValue",
        "comment": " Specify a custom key-value pair to be stored in an object generated by\n[vObject](#vObject).\n",
        "type": "String -> Vega.Value -> Vega.Value"
      },
      {
        "name": "layout",
        "comment": " Create a layout used in the visualization. For example the following creates\na three-column layout with 20 pixel padding between columns:\n\n    lo =\n        layout [ loColumns (num 3), loPadding (num 20) ]\n\n",
        "type": "List Vega.LayoutProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "leClipHeight",
        "comment": " Specify the height in pixels to clip a symbol legend entries and limit its size.\nBy default no clipping is performed.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leColumnPadding",
        "comment": " Specify the horizontal padding between entries in a symbol legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leColumns",
        "comment": " Specify the number of columns in which to arrange symbol legend entries. A\nvalue of 0 or lower indicates a single row with one column per entry. The default\nis 0 for horizontal symbol legends and 1 for vertical symbol legends.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leCornerRadius",
        "comment": " Specify the corner radius for an enclosing legend rectangle.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leDirection",
        "comment": " Specify the direction of a legend.\n",
        "type": "Vega.Orientation -> Vega.LegendProperty"
      },
      {
        "name": "leEncode",
        "comment": " Mark encodings for custom legend styling. For example, to create a horizontal\ndash symbol (using a simple SVG path) for each legend item:\n\n    legend\n        [ leEncode [ enSymbols [ enEnter [ maShape [ vStr \"M-0.5,0H1\" ] ] ] ]\n        , leStroke \"myColourScale\"\n        ]\n\n",
        "type": "List Vega.LegendEncoding -> Vega.LegendProperty"
      },
      {
        "name": "leFill",
        "comment": " Specify the name of the scale that maps to the legend symbols' fill colors.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leFillColor",
        "comment": " Specify the background color of an enclosing legend rectangle.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leFormat",
        "comment": " Specify the format pattern for legend labels. Text should be either a\n[d3-format specifier](https://github.com/d3/d3-format#locale_format) or a\n[d3-time-format specifier](https://github.com/d3/d3-time-format#locale_format).\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leGradientLabelLimit",
        "comment": " Specify the maximum allowed length of gradient labels in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientLabelOffset",
        "comment": " Specify the vertical offset in pixels for gradient labels in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientLength",
        "comment": " Specify the length in pixels of the primary axis of a color gradient in a\nlegend. This value corresponds to the height of a vertical gradient or the width\nof a horizontal gradient.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientOpacity",
        "comment": " Specify the opacity of a color gradient in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientStrokeColor",
        "comment": " Specify the color of a legend's color gradient border.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leGradientStrokeWidth",
        "comment": " Specify the width of a legend's color gradient border.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientThickness",
        "comment": " Specify the thickness in pixels of the color gradient in a legend. This value\ncorresponds to the width of a vertical gradient or the height of a horizontal\ngradient.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGridAlign",
        "comment": " Specify the alignment to apply to symbol legends rows and columns.\n",
        "type": "Vega.GridAlign -> Vega.LegendProperty"
      },
      {
        "name": "leLabelAlign",
        "comment": " Specify the horizontal text alignment for a legend label.\n",
        "type": "Vega.HAlign -> Vega.LegendProperty"
      },
      {
        "name": "leLabelBaseline",
        "comment": " Specify the vertical text alignment for a legend label.\n",
        "type": "Vega.VAlign -> Vega.LegendProperty"
      },
      {
        "name": "leLabelColor",
        "comment": " Specify the text color for legend labels.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leLabelFont",
        "comment": " Specify the text font for legend labels.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leLabelFontSize",
        "comment": " Specify the font size in pixels for legend labels.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelFontWeight",
        "comment": " Specify the font weight for legend labels.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leLabelLimit",
        "comment": " Specify the maximum allowed length in pixels of a legend label.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelOffset",
        "comment": " Specify the horizontal pixel offset for a legend's symbols.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelOpacity",
        "comment": " Specify the opacity for a legend's labels.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelOverlap",
        "comment": " Specify the strategy to use for resolving overlap of labels in gradient legends.\n",
        "type": "Vega.OverlapStrategy -> Vega.LegendProperty"
      },
      {
        "name": "leOffset",
        "comment": " Specify the offset in pixels by which to displace the legend from the data\nrectangle and axes.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leOpacity",
        "comment": " Specify the name of the scale that maps to the legend symbols' opacities.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leOrient",
        "comment": " Specify the orientation of the legend, determining where the legend is placed\nrelative to a chartâs data rectangle.\n",
        "type": "Vega.LegendOrientation -> Vega.LegendProperty"
      },
      {
        "name": "lePadding",
        "comment": " Specify the padding between the border and content of the legend group.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leRowPadding",
        "comment": " Specify the vertical padding between entries in a symbol legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leShape",
        "comment": " Specify the name of the scale that maps to the legend symbols' shapes.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leSize",
        "comment": " Specify the name of the scale that maps to the legend symbols' sizes.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leStroke",
        "comment": " Specify the name of the scale that maps to the legend symbols' strokes.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leStrokeColor",
        "comment": " Specify the border color of an enclosing legend rectangle.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leStrokeDash",
        "comment": " Specify the name of the scale that maps to the legend symbols' stroke dashing.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leStrokeWidth",
        "comment": " Specify the stroke width of the color of a legend's gradient border.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolBaseFillColor",
        "comment": " Specify the default fill color for legend symbols. This is only applied if there\nis no fill scale color encoding for the legend.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolBaseStrokeColor",
        "comment": " Specify the default stroke color for legend symbols. This is only applied if\nthere is no stroke scale color encoding for the legend.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolDirection",
        "comment": " Specify the default direction for legend symbols.\n",
        "type": "Vega.Orientation -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolFillColor",
        "comment": " Specify the fill color for legend symbols.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolOffset",
        "comment": " Specify the offset in pixels between legend labels their corresponding symbol\nor gradient.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolOpacity",
        "comment": " Specify the opacity for a legend's symbols.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolSize",
        "comment": " Specify the default symbol area size in square pixel units.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolStrokeColor",
        "comment": " Specify the border color for legend symbols.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolStrokeWidth",
        "comment": " Specify the default symbol border width used in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolType",
        "comment": " Specify the default symbol shape used in a legend.\n",
        "type": "Vega.Symbol -> Vega.LegendProperty"
      },
      {
        "name": "leTemporalTickCount",
        "comment": " Specify a desired number of ticks for a temporal legend. The first parameter\nis the type of temporal interval to use and the second the number of steps of that\ninterval between ticks. For example to specify a tick is requested at six-month\nintervals (e.g. January, July):\n\n    lg =\n        legends\n            << legend\n                [ leFill \"cScale\"\n                , leType LGradient\n                , leFormat (str \"%b %Y\")\n                , leTemporalTickCount Month (num 6)\n                ]\n\nIf the second parameter is not a positive value, the number of ticks will be\nauto-generated for the given interval type.\n\n",
        "type": "Vega.TimeUnit -> Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTickCount",
        "comment": " Specify the desired number of tick values for quantitative legends.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitle",
        "comment": " Specify the title for the legend (none by default).\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leTitleAlign",
        "comment": " Specify the horizontal alignment for a legend title.\n",
        "type": "Vega.HAlign -> Vega.LegendProperty"
      },
      {
        "name": "leTitleBaseline",
        "comment": " Specify the vertical alignment for a legend title.\n",
        "type": "Vega.VAlign -> Vega.LegendProperty"
      },
      {
        "name": "leTitleColor",
        "comment": " Specify the text color for a legend title.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leTitleFont",
        "comment": " Specify the text font for a legend title.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leTitleFontSize",
        "comment": " Specify the font size in pixel units for a legend title.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitleFontWeight",
        "comment": " Specify the font weight for a legend title.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leTitleLimit",
        "comment": " Specify the maximum allowed length in pixels of a legend title.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitleOpacity",
        "comment": " Specify the opacity for a legend's title.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitlePadding",
        "comment": " Specify the padding between the legend title and entries.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leType",
        "comment": " Specify the type of legend.\n",
        "type": "Vega.LegendType -> Vega.LegendProperty"
      },
      {
        "name": "leValues",
        "comment": " Explicitly set visible legend values.\n",
        "type": "List Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leZIndex",
        "comment": " Specify the integer z-index indicating the layering of the legend group relative\nto other axis, mark and legend groups. The default value is 0.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "legend",
        "comment": " Create a single legend used to visualize a color, size or shape mapping.\n",
        "type": "List Vega.LegendProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "legendOrientationSignal",
        "comment": " Specify a signal that indicates the position of a legend relative to the\nvisualization it describes.\n",
        "type": "String -> Vega.LegendOrientation"
      },
      {
        "name": "legendTypeSignal",
        "comment": " Specify a type of legend is to be determined by the given signal. Valid values\ngenerated by the signal are `symbol` and `gradient`.\n",
        "type": "String -> Vega.LegendType"
      },
      {
        "name": "legends",
        "comment": " Create legends used to visualize color, size and shape mappings. Commonly the\nfunctional composition operator (`<<`) is used to combine multiple legend\nspecifications. For example,\n\n    lg =\n        legends\n            << legend\n                [ leTitle (str \"Income\")\n                , leOrient BottomRight\n                , leType LSymbol\n                , leSize \"mySizeScale\"\n                ]\n            << legend\n                [ leTitle (str \"Nationality\")\n                , leOrient TopRight\n                , leType LSymbol\n                , leFill \"myColorScale\"\n                ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "linkShapeSignal",
        "comment": " Specify the shape of a line indicating path between nodes using the given signal.\n",
        "type": "String -> Vega.LinkShape"
      },
      {
        "name": "loAlign",
        "comment": " Specify the alignment to apply to grid rows and columns in a grid layout.\n",
        "type": "Vega.GridAlign -> Vega.LayoutProperty"
      },
      {
        "name": "loBounds",
        "comment": " Specify the bounds calculation method to use for determining the extent of a\nsub-plot in a grid layout.\n",
        "type": "Vega.BoundsCalculation -> Vega.LayoutProperty"
      },
      {
        "name": "loColumns",
        "comment": " Specify the number of columns to include in a grid layout. If unspecified, a\nsingle row with unlimited columns will be assumed.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loFooterBand",
        "comment": " Specify the band positioning in the interval [0,1] indicating where in a cell\na footer should be placed in a grid layout. For a column footer, 0 maps to the left\nedge of the footer cell and 1 to right edge. For a row footer, the range maps from\ntop to bottom.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loFooterBandRC",
        "comment": " Similar to [loFooterBand](#loFooterBand) but allowing row and column settings\nto be specified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loHeaderBand",
        "comment": " Specify the band positioning in the interval [0,1] indicating where in a cell\na header should be placed in a grid layout. For a column header, 0 maps to the left\nedge of the header cell and 1 to right edge. For a row footer, the range maps from\ntop to bottom.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loHeaderBandRC",
        "comment": " Similar to [loFHeaderBand](#loHeaderBand) but allowing row and column settings\nto be specified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loOffset",
        "comment": " Specify the orthogonal offset in pixels by which to displace grid header, footer\nand title cells from their position along the edge of a grid layout.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loOffsetRC",
        "comment": " Similar to [loOffset](#loOffset) but allowing row and column settings to be\nspecified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loPadding",
        "comment": " Specify the padding in pixels to add between elements within rows and columns\nof a grid layout.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loPaddingRC",
        "comment": " Similar to [loPadding](#loPadding) but allowing row and column settings to be\nspecified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loTitleBand",
        "comment": " Specify where in a cell of a grid layout, a title should be placed. For a\ncolumn title, 0 maps to the left edge of the title cell and 1 to right edge. The\ndefault value is 0.5, indicating a centred position.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loTitleBandRC",
        "comment": " Similar to [loTitleBand](#loTitleBand) but allowing row and column settings\nto be specified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "lpAs",
        "comment": " Specify the name for the output field of a link path in a linkPath transformation.\nIf not specified, the default is \"path\".\n",
        "type": "String -> Vega.LinkPathProperty"
      },
      {
        "name": "lpOrient",
        "comment": " Specify the orientation of a link path in a linkPath transformation. If a radial\norientation is specified, x and y coordinate parameters will be interpreted as an\nangle (in radians) and radius, respectively.\n",
        "type": "Vega.Orientation -> Vega.LinkPathProperty"
      },
      {
        "name": "lpShape",
        "comment": " Specify the shape of a link path in a linkPath transformation.\n",
        "type": "Vega.LinkShape -> Vega.LinkPathProperty"
      },
      {
        "name": "lpSourceX",
        "comment": " Specify the data field for the source x-coordinate in a linkPath transformation.\nThe default is `source.x`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "lpSourceY",
        "comment": " Specify the data field for the source y-coordinate in a linkPath transformation.\nThe default is `source.y`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "lpTargetX",
        "comment": " Specify the data field for the target x-coordinate in a linkPath transformation.\nThe default is `target.x`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "lpTargetY",
        "comment": " Specify the data field for the target y-coordinate in a linkPath transformation.\nThe default is `target.y`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "luAs",
        "comment": " Specify the output fields in which to write data found in the secondary\nstream of a lookup.\n",
        "type": "List String -> Vega.LookupProperty"
      },
      {
        "name": "luDefault",
        "comment": " Specify the default value to assign if lookup fails in a lookup transformation.\n",
        "type": "Vega.Value -> Vega.LookupProperty"
      },
      {
        "name": "luValues",
        "comment": " Specify the data fields to copy from the secondary stream to the primary\nstream in a lookup transformation. If not specified, a reference to the full data\nrecord is copied.\n",
        "type": "List Vega.Field -> Vega.LookupProperty"
      },
      {
        "name": "mClip",
        "comment": " Indicate whether or how marks should be clipped to a specified shape. For a\nsimple case of clipping to the retangular 'data rectangle':\n\n    mClip (clEnabled true)\n\nTo clip by some abritrary simple polygon use [clPath](#clPath) either to specify\nan SVG path string explicitly in pixel coordinates, or more usefully for geographic\ncoordinates use the output of [trGeoPath](#trGeoPath):\n\n    ds =\n        dataSource\n            [ data \"myClippingPoly\"\n                [ daUrl (str \"myPolyFile.json\")\n                , daFormat [ topojsonFeature \"idOfClippingPoly\" ]\n                ]\n                |> transform [ trGeoPath \"myProjection\" [] ]\n            ...\n\n    mk =\n        marks\n              << mark Path\n                  [ mFrom [ srData (str \"myMapSource\") ]\n                  , mClip (clPath (strSignal \"data('myClippingPoly')[0]['path']\"))\n                  ...\n\n",
        "type": "Vega.Clip -> Vega.TopMarkProperty"
      },
      {
        "name": "mDescription",
        "comment": " Specify a description of a mark, useful for inline comments.\n",
        "type": "String -> Vega.TopMarkProperty"
      },
      {
        "name": "mEncode",
        "comment": " Specify a set of visual encoding rules for a mark.\n",
        "type": "List Vega.EncodingProperty -> Vega.TopMarkProperty"
      },
      {
        "name": "mFrom",
        "comment": " Specify the data source to be visualized by a mark. If not specified, a single\nelement data set containing an empty object is assumed. The source can either be\na data set to use or a faceting directive to subdivide a data set across a set\nof group marks.\n",
        "type": "List Vega.Source -> Vega.TopMarkProperty"
      },
      {
        "name": "mGroup",
        "comment": " Assemble a group of top-level marks. This can be used to create nested groups\nof marks within a `Group` mark (including further nested group specifications) by\nsuppyling the specification as a series of properties. For example,\n\n    marks\n        << mark Group\n            [ mFrom [ srData (str \"myData\") ]\n            , mGroup [ mkGroup1 [], mkGroup2 [] ]\n            ]\n\n",
        "type": "List ( Vega.VProperty, Vega.Spec ) -> Vega.TopMarkProperty"
      },
      {
        "name": "mInteractive",
        "comment": " Specify whether a mark can serve as an input event source. If false, no\nmouse or touch events corresponding to the mark will be generated.\n",
        "type": "Vega.Boo -> Vega.TopMarkProperty"
      },
      {
        "name": "mKey",
        "comment": " Specify a data field to use as a unique key for data binding. When a\nvisualizationâs data is updated, the key value will be used to match data elements\nto existing mark instances. Use a key field to enable object constancy for\ntransitions over dynamic data.\n",
        "type": "Vega.Field -> Vega.TopMarkProperty"
      },
      {
        "name": "mName",
        "comment": " Specify a unique name for a mark. This name can be used to refer to the mark\nin another mark or within an event stream definition. SVG renderers will add this\nname value as a CSS class name on the enclosing SVG group (g) element containing\nthe mark instances.\n",
        "type": "String -> Vega.TopMarkProperty"
      },
      {
        "name": "mOn",
        "comment": " Specify a set of triggers for modifying a mark's properties in response to\nsignal changes.\n",
        "type": "List Vega.Trigger -> Vega.TopMarkProperty"
      },
      {
        "name": "mSort",
        "comment": " Specify the Fields and sort order for sorting mark items. The sort order will\ndetermine the default rendering order. This is defined over generated scenegraph\nitems and sorting is performed after encodings are computed, allowing items to be\nsorted by size or position. To sort by underlying data properties in addition to\nmark item properties, append the prefix `datum` to a field name.\n\n    mSort [ ( field \"datum.y\", Ascend ) ]\n\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.TopMarkProperty"
      },
      {
        "name": "mStyle",
        "comment": " Specify the names of custom styles to apply to a mark. A style is a named\ncollection of mark property defaults defined within the configuration. These\nproperties will be applied to the markâs enter encoding set, with later styles\noverriding earlier styles. Any properties explicitly defined within the markâs\n`encode` block will override a style default.\n",
        "type": "List String -> Vega.TopMarkProperty"
      },
      {
        "name": "mTransform",
        "comment": " Specify a set of post-encoding transforms to be applied after any encode\nblocks, that operate directly on mark scenegraph items (not backing data objects).\nThese can be useful for performing layout with transforms that can set x, y,\nwidth, height, etc. properties. Only data transforms that do not generate or\nfilter data objects should be used.\n",
        "type": "List Vega.Transform -> Vega.TopMarkProperty"
      },
      {
        "name": "mZIndex",
        "comment": " Specify the z-index (draw order) of a mark. Marks with higher values are drawn\n'on top' of marks with lower numbers. This can be useful, for example, when drawing\nnode-link diagrams and the node symbol should sit on top of connected edge lines.\n",
        "type": "Vega.Num -> Vega.TopMarkProperty"
      },
      {
        "name": "maAlign",
        "comment": " The horizontal alignment of a text or image mark. To guarantee valid\nalignment type names, use `hCenter`, `hLeft` etc. For example:\n\n    << mark Text\n        [ mEncode\n            [ enEnter [ maAlign [ hCenter ] ] ]\n        ]\n\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maAngle",
        "comment": " The rotation angle of the text in degrees in a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maAspect",
        "comment": " Specify whether or not image aspect ratio should be preserved in an image mark.\nThis may be specified directly, via a field, a signal or any other Boolean-generating\nvalue.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maBaseline",
        "comment": " The vertical baseline of a text or image mark. This may be specified directly,\nvia a field, a signal or any other text-generating value. To guarantee valid\nalignment type names, use `vTop`, `vMiddle` etc. For example:\n\n    << mark Text\n        [ mEncode\n            [ enEnter [ maBaseline [ vTop ] ] ]\n        ]\n\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maCornerRadius",
        "comment": " The corner radius in pixels of an arc or rect mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maCursor",
        "comment": " The cursor to be displayed over a mark. This may be specified directly, via a\nfield, a signal or any other text-generating value. To guarantee valid cursor type\nnames, use [cursorValue](#cursorValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maCustom",
        "comment": " Create a custom mark property. For example:\n\n    mEncode\n        [ enEnter\n            [ maFill [ vScale \"cScale\", vField (field \"group\") ]\n            , maCustom \"myName\" [ vScale \"xScale\", vField (field \"group\") ]\n            ]\n        ]\n\nFor further details see the\n[Vega Beeswarm plot example](https://vega.github.io/vega/examples/beeswarm-plot/).\n\n",
        "type": "String -> List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDefined",
        "comment": " Indicate if the current data point in a linear mark is defined. If false, the\ncorresponding line/trail segment will be omitted, creating a âbreakâ. This may be\nspecified directly, via a field, a signal or any other Boolean-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDir",
        "comment": " The direction text is rendered in a text mark. This determines which side is\ntruncated in response to the text size exceeding the value of the limit parameter.\nThis may be specified directly, via a field, a signal or any other string-generating\nvalue. To guarantee valid direction type names, use [textDirectionValue](#textDirectionValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDx",
        "comment": " The horizontal offset in pixels (before rotation), between the text and anchor\npoint of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDy",
        "comment": " The vertical offset in pixels (before rotation), between the text and anchor\npoint of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maEllipsis",
        "comment": " The ellipsis string for text truncated in response to the limit parameter of\na text mark. This may be specified directly, via a field, a signal or any other\nstring-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maEndAngle",
        "comment": " The end angle in radians clockwise from north for an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFill",
        "comment": " The fill color of a mark. This may be specified directly, via a field,\na signal or any other color-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFillOpacity",
        "comment": " The fill opacity of a mark in the range 0 to 1.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFont",
        "comment": " The typeface used by a text mark. This can be a generic font description such\nas `sans-serif`, `monospace` or any specific font name made accessible via a css\nfont definition. This may be specified directly, via a field, a signal or any other\nstring-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFontSize",
        "comment": " The font size in pixels used by a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFontStyle",
        "comment": " The font style, such as `normal` or `italic` used by a text mark. This may be\nspecified directly, via a field, a signal or any other string-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFontWeight",
        "comment": " The font weight, such as `normal` or `bold` used by a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maGroupClip",
        "comment": " Indicate if the visible group content should be clipped to the groupâs\nspecified width and height. This may be specified directly, via a field, a signal\nor any other Boolean-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maHRef",
        "comment": " A URL to load upon mouse click. If defined, the mark acts as a hyperlink. This\nmay be specified directly, via a field, a signal or any other text-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maHeight",
        "comment": " The height of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maInnerRadius",
        "comment": " The inner radius in pixel units of an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maInterpolate",
        "comment": " The interpolation style of a linear mark. This may be specified directly,\nvia a field, a signal or any other text-generating value. To guarantee valid\ninterpolation type names, use [markInterpolationValue](#markInterpolationValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maLimit",
        "comment": " The maximum length of a text mark in pixels (default 0, indicating no limit).\nThe text value will be automatically truncated if the rendered size exceeds this\nlimit.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maOpacity",
        "comment": " The opacity of a mark in the range 0 to 1.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maOrient",
        "comment": " The orientation of an area mark. With a vertical orientation, an area mark is\ndefined by the x, y, and (y2 or height) properties; with a horizontal orientation,\nthe y, x and (x2 or width) properties must be specified instead. The orientation\nmay be specified directly, via a field, a signal or any other text-generating value.\nTo guarantee valid orientation type names, use [orientationValue](#orientationValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maOuterRadius",
        "comment": " The outer radius in pixel units of an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maPadAngle",
        "comment": " The padding angle in radians clockwise from north for an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maPath",
        "comment": " The [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths)\ndescribing the geometry of a path mark. This may be specified directly, via a field,\na signal or any other text-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maRadius",
        "comment": " Polar coordinate radial offset in pixels, relative to the origin determined\nby the x and y properties of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maShape",
        "comment": " A shape instance that provides a drawing method to invoke within the renderer.\nShape instances cannot be specified directly, instead they must be generated by\na data transform such as symbol generation or a geoshape.\nFor example,\n\n    shapeEncoding =\n        [ maShape [ symbolValue SymSquare ]\n        , maStroke [ black ]\n        ]\n\n    lg =\n        legends\n            << legend\n                [ leFill \"cScale\"\n                , leOrient BottomRight\n                , leEncode [ enSymbols [ enUpdate shapeEncoding ] ]\n                ]\n\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maSize",
        "comment": " The area in pixels of the bounding box of point-based mark such as a symbol.\nNote that this value sets the area of the mark; the side lengths will increase with\nthe square root of this value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStartAngle",
        "comment": " The start angle in radians clockwise from north for an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStroke",
        "comment": " The stroke color of a mark. This may be specified directly, via a field,\na signal or any other color-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeCap",
        "comment": " The stroke cap ending style for a mark. This may be specified directly, via a\nfield, a signal or any other text-generating value. To guarantee valid stroke cap\nnames, use [strokeCapValue](#strokeCapValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeDash",
        "comment": " The stroke dash style of a mark. This may be specified directly, via a\nfield, a signal or any other numeric list-generating value. The list should consist\nof alternating dash-gap lengths in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeDashOffset",
        "comment": " A mark's offset of the first stroke dash in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeJoin",
        "comment": " The stroke join method for a mark. This may be specified directly, via a\nfield, a signal or any other text-generating value. To guarantee valid stroke join\nnames, use [strokeJoinValue](#strokeJoinValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeMiterLimit",
        "comment": " The miter limit at which to bevel a line join for a mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeOpacity",
        "comment": " The stroke opacity of a mark in the range 0 to 1.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeWidth",
        "comment": " The stroke width of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maSymbol",
        "comment": " A symbol shape that describes a symbol mark. For preset shapes, use\n[symbolValue](#symbolValue). For correct sizing of custom shape paths, define\ncoordinates within a square ranging from -1 to 1 along both the x and y dimensions.\nSymbol definitions may be specified directly, via a field, a signal or any other\ntext-generating value. For example, to generate a preset shape:\n\n    maShape [ symbolValue SymTriangleLeft ]\n\nor a custom shape with an SVG path:\n\n    maShape [ symbolValue (symPath \"M-1,-1H1V1H-1Z\") ]\n\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maTension",
        "comment": " The interpolation tension in the range 0 to 1 of a linear mark. Applies only\nto cardinal and catmull-rom interpolators.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maText",
        "comment": " The text to display in a text mark. This may be specified directly,\nvia a field, a signal or any other string-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maTheta",
        "comment": " Polar coordinate angle in radians, relative to the origin determined by the\nx and y properties of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maTooltip",
        "comment": " The tooltip text to show upon mouse hover over a mark. This may be specified\ndirectly, via a field, a signal or any other text-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maUrl",
        "comment": " The URL of an image file to be displayed as an image mark. This may be specified\ndirectly, via a field, a signal or any other text-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maWidth",
        "comment": " The width of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maX",
        "comment": " The primary x-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maX2",
        "comment": " The secondary x-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maXC",
        "comment": " The centre x-coordinate of a mark in pixels. This is an alternative to `maX`\nor `maX2`, not an addition.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maY",
        "comment": " The primary y-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maY2",
        "comment": " The secondary y-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maYC",
        "comment": " The centre y-coordinate of a mark in pixels. This is an alternative to `maY`\nor `maY2`, not an addition.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maZIndex",
        "comment": " An integer z-index indicating the layering order of sibling mark items. The\ndefault value is 0. Higher values (1) will cause marks to be drawn on top of those\nwith lower z-index values. Setting the z-index as an encoding property only affects\nordering among sibling mark items; it will not change the layering relative to other\nmark definitions.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "mark",
        "comment": " Create a single mark definition. Marks form the visible components of a visualization.\nEach mark specification can include a list of mark properties (second parameter)\nthat customise the appearance of the mark and relate its appearance to data streams\nor signals.\n",
        "type": "Vega.Mark -> List Vega.TopMarkProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "markInterpolationValue",
        "comment": " A convenience function for generating a value representing a given mark\ninterpolation type. This can be used instead of specifying an interpolation type\nas a literal string to avoid problems of mistyping the interpolation name.\n\n    signals\n       << signal \"interp\" [ siValue (markInterpolationValue Linear) ]\n\n",
        "type": "Vega.MarkInterpolation -> Vega.Value"
      },
      {
        "name": "marks",
        "comment": " Create the marks used in the visualization. Multiple mark specifications are\ncommonly combined using the functional composition operator (`<<`). For example,\n\n      mk =\n          marks\n              << mark Line\n                  [ mFrom [ srData (str \"myData\") ]\n                  , mEncode\n                      [ enEnter\n                          [ maX [ vScale \"xScale\", vField (field \"distance\") ]\n                          , maY [ vScale \"yScale\", vField (field \"energy\") ]\n                          , maStroke [ black ]\n                          ]\n                      ]\n                  ]\n              << mark Symbol\n                  [ mFrom [ srData (str \"myData\") ]\n                  , mEncode\n                      [ enEnter\n                          [ maX [ vScale \"xScale\", vField (field \"distance\") ]\n                          , maY [ vScale \"yScale\", vField (field \"energy\") ]\n                          , maFill [ white ]\n                          , maStroke [ black ]\n                          ]\n                      ]\n                  ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "nInterval",
        "comment": " Specify a desired 'nice' temporal interval between labelled tick points.\n",
        "type": "Vega.TimeUnit -> Int -> Vega.ScaleNice"
      },
      {
        "name": "nTickCount",
        "comment": " Specify a desired tick count for a human-friendly 'nice' scale range.\n",
        "type": "Int -> Vega.ScaleNice"
      },
      {
        "name": "num",
        "comment": " Specify a numeric literal.\n",
        "type": "Float -> Vega.Num"
      },
      {
        "name": "numExpr",
        "comment": " Specify an expression that to be evaluated as a numeric value.\n",
        "type": "Vega.Expr -> Vega.Num"
      },
      {
        "name": "numList",
        "comment": " Specify a list of potentially mixed numeric types. This can be useful when,\nfor example, a domain is specified as being bounded by 0 and some signal:\n\n    scDomain (doNums (numList [ num 0, numSignal \"mySignal\" ] ) )\n\n",
        "type": "List Vega.Num -> Vega.Num"
      },
      {
        "name": "numNull",
        "comment": " Specify an absence of a numeric value.\n",
        "type": "Vega.Num"
      },
      {
        "name": "numSignal",
        "comment": " Specify a signal that will provide a numeric value.\n",
        "type": "String -> Vega.Num"
      },
      {
        "name": "numSignals",
        "comment": " Specify a list of signals that will provide numeric values.\n",
        "type": "List String -> Vega.Num"
      },
      {
        "name": "nums",
        "comment": " Specify a list of numeric literals. For lists that contain a mixture of numeric\nliterals and signals use [numList](#numList) instead.\n",
        "type": "List Float -> Vega.Num"
      },
      {
        "name": "on",
        "comment": " Add a list of triggers to the given data table.\n",
        "type": "List Vega.Trigger -> Vega.DataTable -> Vega.DataTable"
      },
      {
        "name": "operationSignal",
        "comment": " Indicate an aggregation operation is to be determined by a named signal. The\nsignal should generate the name of a valid operation (e.g. `average`).\n",
        "type": "String -> Vega.Operation"
      },
      {
        "name": "orderSignal",
        "comment": " Indicate a sort order determined by a named signal for comparison operations.\nSee the [Vega type comparison documentation](https://vega.github.io/vega/docs/types/#Compare).\n",
        "type": "String -> Vega.Order"
      },
      {
        "name": "orientationSignal",
        "comment": " Indicate an orientation for marks, legends and link paths is determined by a named signal.\n",
        "type": "String -> Vega.Orientation"
      },
      {
        "name": "orientationValue",
        "comment": " A convenience function for generating a value representing a given mark\norientation type. This can be used instead of specifying an orientation type as\na literal string to avoid problems of mistyping its name.\n\n     maOrient [ orientationValue Horizontal ]\n\n",
        "type": "Vega.Orientation -> Vega.Value"
      },
      {
        "name": "overlapStrategySignal",
        "comment": " Specify an axis overlap strategy is to be determined by a named signal.\n",
        "type": "String -> Vega.OverlapStrategy"
      },
      {
        "name": "paAs",
        "comment": " The names to give the output fields of a packing transform. The default is\n[\"x\", \"y\", \"r\", \"depth\", \"children\"], where x and y are the layout coordinates,\nr is the node radius, depth is the tree depth, and children is the count of a\nnodeâs children in the tree.\n",
        "type": "String -> String -> String -> String -> String -> Vega.PackProperty"
      },
      {
        "name": "paField",
        "comment": " The data field corresponding to a numeric value for the node in a packing\ntransform. The sum of values for a node and all its descendants is available on\nthe node object as the value property. If radius is null, this field determines\nthe node size.\n",
        "type": "Vega.Field -> Vega.PackProperty"
      },
      {
        "name": "paPadding",
        "comment": " The approximate padding to include between packed circles.\n",
        "type": "Vega.Num -> Vega.PackProperty"
      },
      {
        "name": "paRadius",
        "comment": " Specify an explicit node radius to use in a packing transform. If `Nothing` (the\ndefault), the radius of each leaf circle is derived from the field value.\n",
        "type": "Maybe.Maybe Vega.Field -> Vega.PackProperty"
      },
      {
        "name": "paSize",
        "comment": " The size of a packing layout, provided as a two-element list in [width, height]\norder (or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.PackProperty"
      },
      {
        "name": "paSort",
        "comment": " Specify how sorting of sibling nodes is supported in a packing transform.\nThe inputs to subject to sorting are tree node objects, not input data objects.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.PackProperty"
      },
      {
        "name": "padding",
        "comment": " Set the padding around the visualization in pixel units. The way padding is\ninterpreted will depend on the `autosize` properties.\nfor details.\n",
        "type": "Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "paddings",
        "comment": " Set the padding around the visualization in pixel units in _left_, _top_,\n_right_, _bottom_ order. The way padding is interpreted will depend on the\n`autosize` properties.\nfor details.\n",
        "type": "Float -> Float -> Float -> Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "parse",
        "comment": " Specify data parsing rules as a list of tuples where each corresponds to a\nfield name paired with its desired data type. This is only necessary if there is\nsome ambiguity that could prevent correct type inference, such as time text:\n\n    dataSource\n        [ data \"timeData\"\n            [ daUrl (str \"data/timeSeries.json\")\n            , daFormat [ parse [ ( \"timestamp\", foDate \"%d/%m/%y %H:%M\" ) ] ]\n            ]\n        ]\n\n",
        "type": "List ( String, Vega.DataType ) -> Vega.FormatProperty"
      },
      {
        "name": "piAs",
        "comment": " The output fields for the computed start and end angles for each arc in a pie\ntransform.\n",
        "type": "String -> String -> Vega.PieProperty"
      },
      {
        "name": "piEndAngle",
        "comment": " The end angle in radians in a pie chart transform. The default is 2 PI\nindicating the final slice ends 'north'.\n",
        "type": "Vega.Num -> Vega.PieProperty"
      },
      {
        "name": "piField",
        "comment": " The field to encode with angular spans in a pie chart transform.\n",
        "type": "Vega.Field -> Vega.PieProperty"
      },
      {
        "name": "piGroupBy",
        "comment": " Specify the fields to group by when performing a pivot transform. If not specified,\na single group containing all data objects will be used.\n",
        "type": "List Vega.Field -> Vega.PivotProperty"
      },
      {
        "name": "piLimit",
        "comment": " Specify the maximum number of fields to generate when performing a pivot transform\nor 0 for no limit.\n",
        "type": "Vega.Num -> Vega.PivotProperty"
      },
      {
        "name": "piOp",
        "comment": " Specify the aggregation operation to use by when performing a pivot transform.\nIf not specified, fields will be aggregated by their sum.\n",
        "type": "Vega.Operation -> Vega.PivotProperty"
      },
      {
        "name": "piSort",
        "comment": " Indicate whether or not pie slices should be stored in angular size order.\n",
        "type": "Vega.Boo -> Vega.PieProperty"
      },
      {
        "name": "piStartAngle",
        "comment": " The starting angle in radians in a pie chart transform. The default is 0\nindicating that the first slice starts 'north'.\n",
        "type": "Vega.Num -> Vega.PieProperty"
      },
      {
        "name": "prCenter",
        "comment": " Specify a projectionâs centre as a two-element list of longitude and latitude\nin degrees. The default value is [0, 0].\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prClipAngle",
        "comment": " Specify a projectionâs clipping circle radius to the specified angle in degrees.\nA value of zero indicates antimeridian cutting should be applied rather than\nsmall-circle clipping.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prClipExtent",
        "comment": " Specify a projectionâs viewport clip extent to the specified bounds in pixels.\nThe extent bounds should be specified as a list of four numbers in [x0, y0, x1, y1]\norder where x0 is the left-side of the viewport, y0 is the top, x1 is the right\nand y1 is the bottom.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prCoefficient",
        "comment": " Specify a Hammer map projection's coefficient (defaults to 2).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prCustom",
        "comment": " Specify a custom map projection. Custom names need to be registered with the\nVega runtime.\n",
        "type": "Vega.Str -> Vega.Projection"
      },
      {
        "name": "prDistance",
        "comment": " Specify a Satellite map projection's distance value. Values are expressed as a\nproportion of the Earth's radius (defaults to 2).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prExtent",
        "comment": " Specify the display region into which the projection should be automatically fit.\nUsed in conjunction with [prFit](#prFit). The region bounds should be specified\nin [x0, y0, x1, y1] order where x0 is the left-side, y0 is the top, x1 is the\nright and y1 is the bottom.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prFit",
        "comment": " Specify the GeoJSON data to which a projection should attempt to automatically\nfit by setting its translate and scale values.\n\n    ds =\n        dataSource [ data \"mapData\" [ daUrl (str \"myGeoJson.json\") ] ]\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType Orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (feName \"mapData\")\n                ]\n\n",
        "type": "Vega.Feature -> Vega.ProjectionProperty"
      },
      {
        "name": "prFraction",
        "comment": " Specify a Bottomley map projection's fraction parameter (defaults to 0.5).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prLobes",
        "comment": " Specify the number of lobes in radial map projections such as the Berghaus Star.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prParallel",
        "comment": " Specify a the parallel used for map projections such as the Armadillo (defaults\nto 20 degrees N).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prPointRadius",
        "comment": " Specify the default radius (in pixels) to use when drawing projected GeoJSON\nPoint and MultiPoint geometries. The default value is 4.5.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prPrecision",
        "comment": " Specify a threshold for the projectionâs adaptive resampling in pixels. This\ncorresponds to the DouglasâPeucker distance. If precision is not specified, the\nprojectionâs current resampling precision which defaults to â0.5 â 0.70710 is used.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prRadius",
        "comment": " Specify the radius for the Gingery map projection. Defaults to 30 degrees.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prRatio",
        "comment": " Specify a Hill map projection's ratio allowing it to vary continuously between\nMaurer 73 (0) and Eckert IV projections (infinity). Defaults to 1.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prRotate",
        "comment": " Specify a projectionâs three-axis rotation angle. This should be a two- or\nthree-element list of numbers [lambda, phi, gamma] specifying the rotation angles\nin degrees about each spherical axis.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prScale",
        "comment": " Specify a projectionâs the projectionâs scale factor to the specified value.\nThe default scale is projection-specific. The scale factor corresponds linearly\nto the distance between projected points; however, scale factor values are not\nequivalent across projections.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prSize",
        "comment": " Specify the width and height of the display region into which the projection\nshould be automatically fit. Used in conjunction with [prFit](#prFit) this is equivalent\nto calling [prExtent](#prExtent) with the top-left position set to (0,0). The region\nsize should be specified in [width, height] order (or a signal that generates such\na list).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prSpacing",
        "comment": " Specify the spacing for a Lagrange conformal map projection (defaults to 0.5).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prTilt",
        "comment": " Specify the tilt angle for a Satellite map projection (defaults to 0 degrees).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prTranslate",
        "comment": " Specify a translation offset to the specified two-element list [tx, ty]. If\nnot specified as a two-element list, returns the current translation offset which\ndefaults to [480, 250]. The translation offset determines the pixel coordinates\nof the projectionâs centre. The default translation offset places (0Â°,0Â°) at the\ncentre of a 960Ã500 area.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prType",
        "comment": " Specify the type of global map projection to use in a projection transformation.\n",
        "type": "Vega.Projection -> Vega.ProjectionProperty"
      },
      {
        "name": "projection",
        "comment": " Create a single map projection for transforming geo data onto a plane.\n",
        "type": "String -> List Vega.ProjectionProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "projectionSignal",
        "comment": " Specify a global map projection type is to be determined by a signal.\n",
        "type": "String -> Vega.Projection"
      },
      {
        "name": "projectionValue",
        "comment": " Convenience function for generating a value representing a given projection\ntype. Useful when generating signals representing projection types.\n",
        "type": "Vega.Projection -> Vega.Value"
      },
      {
        "name": "projections",
        "comment": " Create the projections used to map geographic data onto a plane.\n\n    pr =\n        projections\n            << projection \"myProj\" [ prType Orthographic ]\n            << projection \"myProj2\" [ prType Albers, prRotate (nums [ -20, 15 ]) ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "ptAs",
        "comment": " Specify the output field names for the output of a partition layout transform.\nThe parameters correspond to the (default name) fields `x0`, `y0`, `x1`, `y1`,\n`depth` and `children`.\n",
        "type": "String -> String -> String -> String -> String -> String -> Vega.PartitionProperty"
      },
      {
        "name": "ptField",
        "comment": " Specify the data field corresponding to a numeric value for a partition node.\nThe sum of values for a node and all its descendants is available on the node object\nas the `value` property. This field determines the size of a node.\n",
        "type": "Vega.Field -> Vega.PartitionProperty"
      },
      {
        "name": "ptPadding",
        "comment": " Specify the padding between adjacent nodes for a partition layout transform.\n",
        "type": "Vega.Num -> Vega.PartitionProperty"
      },
      {
        "name": "ptRound",
        "comment": " Specify whether or not node layout values should be rounded in a partition transform.\nThe default is false.\n",
        "type": "Vega.Boo -> Vega.PartitionProperty"
      },
      {
        "name": "ptSize",
        "comment": " Specify the size of a partition layout as two-element list corresponding to\n[width, height] (or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.PartitionProperty"
      },
      {
        "name": "ptSort",
        "comment": " Specify how sorting of sibling nodes is performed during a partition layout\ntransform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.PartitionProperty"
      },
      {
        "name": "raCustomDefault",
        "comment": " Specify a custom range default scheme. This can be use when a new named default\nhas been created as part of a config setting is required.\n",
        "type": "String -> Vega.ScaleRange"
      },
      {
        "name": "raData",
        "comment": " Specify a scale range as a data reference object. This is used for specifying\nordinal scale ranges as a series of distinct field values.\n\n    scale \"myScale\"\n        [ scType ScOrdinal\n        , scDomain (doData [ daDataset \"clusters\", daField (field \"id\") ])\n        , scRange (raData [ daDataset \"clusters\", daField (field \"name\") ])\n        ]\n\n",
        "type": "List Vega.DataReference -> Vega.ScaleRange"
      },
      {
        "name": "raNums",
        "comment": " Specify a scale range as a list of numbers.\n",
        "type": "List Float -> Vega.ScaleRange"
      },
      {
        "name": "raScheme",
        "comment": " Specify a scale range as a list of color schemes. The first parameter is\nthe name of the colour scheme to use, the second any customising properties.\n",
        "type": "Vega.Str -> List Vega.ColorSchemeProperty -> Vega.ScaleRange"
      },
      {
        "name": "raSignal",
        "comment": " Specify a signal name used to generate a scale range.\n",
        "type": "String -> Vega.ScaleRange"
      },
      {
        "name": "raStep",
        "comment": " Specify the step size for a band scale range.\n",
        "type": "Vega.Value -> Vega.ScaleRange"
      },
      {
        "name": "raStrs",
        "comment": " Specify a scale range as a list of strings.\n",
        "type": "List String -> Vega.ScaleRange"
      },
      {
        "name": "raValues",
        "comment": " Specify a scale range as a list of values.\n",
        "type": "List Vega.Value -> Vega.ScaleRange"
      },
      {
        "name": "rgb",
        "comment": " RGB color interpolation. The parameter is a gamma value to control the\nbrightness of the color trajectory.\n",
        "type": "Float -> Vega.CInterpolate"
      },
      {
        "name": "scAlign",
        "comment": " Specify the alignment of elements within each step of a band scale, as a\nfraction of the step size. Should be in the range [0,1].\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scBase",
        "comment": " Specify the base of the logorithm used in a logarithmic scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scClamp",
        "comment": " Specify whether output values should be clamped to when using a quantitative\nscale range (default false). If clamping is disabled and the scale is passed a\nvalue outside the domain, the scale may return a value outside the range through\nextrapolation. If clamping is enabled, the output value of the scale is always\nwithin the scaleâs range.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scCustom",
        "comment": " Specify a custom named scale.\n",
        "type": "String -> Vega.Scale"
      },
      {
        "name": "scDomain",
        "comment": " Specify the domain of input data values for a scale.\n",
        "type": "Vega.ScaleDomain -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainImplicit",
        "comment": " Specify whether or not ordinal domains should be implicitly extended with new\nvalues. If false, a scale will return `undefined` for values not included in the\ndomain; if true, new values will be appended to the domain and an updated range\nvalue will be returned.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainMax",
        "comment": " Specify the maximum value of a scale domain, overriding a `scDomain` setting.\nThis is only intended for use with scales having continuous domains.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainMid",
        "comment": " Insert a single mid-point value into a two-element scale domain. The mid-point\nvalue must lie between the domain minimum and maximum values. This can be useful\nfor setting a midpoint for diverging color scales. Only used with scales having\ncontinuous, piecewise domains.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainMin",
        "comment": " Specify the minimum value of a scale domain, overriding a `scDomain` setting.\nThis is only used with scales having continuous domains.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainRaw",
        "comment": " Specify a list value that directly overrides the domain of a scale. Useful for\nsupporting interactions such as panning or zooming a scale. The scale may be\ninitially determined using a data-driven domain, then modified in response to user\ninput.\n\n    scales\n        << scale \"xDetail\"\n            [ scType ScTime\n            , scRange RaWidth\n            , scDomain (doData [ daDataset \"sp500\", daField (field \"date\") ])\n            , scDomainRaw (vSignal \"detailDomain\")\n            ]\n\n",
        "type": "Vega.Value -> Vega.ScaleProperty"
      },
      {
        "name": "scExponent",
        "comment": " Specify the exponent to be used in power scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scInterpolate",
        "comment": " Specify the interpolation method for a quantitative scale.\n",
        "type": "Vega.CInterpolate -> Vega.ScaleProperty"
      },
      {
        "name": "scNice",
        "comment": " Extend the range of a scale domain so it starts and ends on 'nice' round\nvalues.\n",
        "type": "Vega.ScaleNice -> Vega.ScaleProperty"
      },
      {
        "name": "scPadding",
        "comment": " Expand a scale domain to accommodate the specified number of pixels on each\nend of a quantitative scale range or the padding between bands in a band scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scPaddingInner",
        "comment": " Expand a scale domain to accommodate the specified number of pixels\nbetween inner bands in a band scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scPaddingOuter",
        "comment": " Expand a scale domain to accommodate the specified number of pixels\noutside the outer bands in a band scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scRange",
        "comment": " Specify the range of a scale representing the set of visual values.\n",
        "type": "Vega.ScaleRange -> Vega.ScaleProperty"
      },
      {
        "name": "scRangeStep",
        "comment": " Specify the step size for band and point scales.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scReverse",
        "comment": " Reverse the order of a scale range.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scRound",
        "comment": " Specify whether to round numeric output values to integers. Helpful for\nsnapping to the pixel grid.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scType",
        "comment": " Specify the type of a named scale.\n",
        "type": "Vega.Scale -> Vega.ScaleProperty"
      },
      {
        "name": "scZero",
        "comment": " Specify whether or not a scale domain should include zero. The default is\ntrue for linear, sqrt and power scales and false for all others.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scale",
        "comment": " Create a single scale used to map data values to visual properties.\n",
        "type": "String -> List Vega.ScaleProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "scaleNiceSignal",
        "comment": " Specify that the type of 'nice' scale generation is to be determined by a\nsignal with the given name.\n",
        "type": "String -> Vega.ScaleNice"
      },
      {
        "name": "scaleRangeSignal",
        "comment": " Specify that a default scaling (`width`, `category`, `heatmap` etc.) is to be\ndetermined by a signal with the given name.\n",
        "type": "String -> Vega.ScaleRange"
      },
      {
        "name": "scaleSignal",
        "comment": " Specify a type of scale transformation is to be determined by a signal.\n",
        "type": "String -> Vega.Scale"
      },
      {
        "name": "scales",
        "comment": " Create the scales used to map data values to visual properties.\n\n    sc =\n        scales\n            << scale \"xScale\"\n                [ scType ScLinear\n                , scDomain (doData [ daDataset \"myData\", daField (field \"x\") ])\n                , scRange RaWidth\n                ]\n            << scale \"yScale\"\n                [ scType ScLinear\n                , scDomain (doData [ daDataset \"myData\", daField (field \"y\") ])\n                , scRange RaHeight\n                ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "siBind",
        "comment": " Bind a signal to an external input element such as a slider, selection list\nor radio button group.\n",
        "type": "Vega.Bind -> Vega.SignalProperty"
      },
      {
        "name": "siDescription",
        "comment": " Specify a text description of a signal, useful for inline documentation.\n",
        "type": "String -> Vega.SignalProperty"
      },
      {
        "name": "siName",
        "comment": " A unique name to be given to a signal. Signal names should be contain only\nalphanumeric characters (or â$â, or â_â) and may not start with a digit. Reserved\nkeywords that may not be used as signal names are \"datum\", \"event\", \"item\", and\n\"parent\".\n",
        "type": "String -> Vega.SignalProperty"
      },
      {
        "name": "siOn",
        "comment": " Specify event stream handlers for updating a signal value in response to\ninput events.\n",
        "type": "List (List Vega.EventHandler) -> Vega.SignalProperty"
      },
      {
        "name": "siPushOuter",
        "comment": " Specify that a signal updates should target a signal in an enclosing scope.\nUsed when creating nested signals in a group mark.\n",
        "type": "Vega.SignalProperty"
      },
      {
        "name": "siReact",
        "comment": " Specify whether a signal update expression should be automatically re-evaluated\nwhen any upstream signal dependencies update. If false, the update expression will\nonly be run upon initialization.\n",
        "type": "Vega.Boo -> Vega.SignalProperty"
      },
      {
        "name": "siUpdate",
        "comment": " Specify an update expression for a signal which may include other signals,\nin which case the signal will automatically update in response to upstream signal\nchanges, so long as its react property is not false.\n",
        "type": "String -> Vega.SignalProperty"
      },
      {
        "name": "siValue",
        "comment": " Specify the initial value of a signal.\n",
        "type": "Vega.Value -> Vega.SignalProperty"
      },
      {
        "name": "sideSignal",
        "comment": " Specify that an axis side is to be determined by a signal with the given\nname.\n",
        "type": "String -> Vega.Side"
      },
      {
        "name": "signal",
        "comment": " Create a single signal used to add a dynamic component to a visualization.\n",
        "type": "String -> List Vega.SignalProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "signals",
        "comment": " Create the signals used to add dynamism to the visualization.\n\n    si =\n        signals\n            << signal \"chartSize\" [ siValue (vNum 120) ]\n            << signal \"chartPad\" [ siValue (vNum 15) ]\n            << signal \"chartStep\" [ siUpdate \"chartSize + chartPad\" ]\n            << signal \"width\" [ siUpdate \"chartStep * 4\" ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "soByField",
        "comment": " The field to be used when sorting.\n",
        "type": "Vega.Str -> Vega.SortProperty"
      },
      {
        "name": "soOp",
        "comment": " A sorting operation.\n",
        "type": "Vega.Operation -> Vega.SortProperty"
      },
      {
        "name": "sortPropertySignal",
        "comment": " Specify that a sorting order is to be determined by a named signal. The value\nof the signal should be either `ascending` or `descending`.\n",
        "type": "String -> Vega.SortProperty"
      },
      {
        "name": "spiralSignal",
        "comment": " Specify that a spiral type for wordcloud allocation is to be determined by a\nsignal with the given name. The value of the signal should be either `archimedean`\nor `rectangular`.\n",
        "type": "String -> Vega.Spiral"
      },
      {
        "name": "srData",
        "comment": " Name of the source for a set of marks.\n",
        "type": "Vega.Str -> Vega.Source"
      },
      {
        "name": "srFacet",
        "comment": " Create a facet directive for a set of marks. The first parameter is the name\nof the source data set from which the facet partitions are to be generated. The\nsecond parameter is the name to be given to the generated facet source. Marks\ndefined with the faceted `group` mark can reference this data source name to\nvisualize the local data partition.\n\n    mark Group\n        [ mFrom [ srFacet (str \"table\") \"facet\" [ faGroupBy [ field \"category\" ] ] ]\n        , mEncode [ enEnter [ maY [ vScale \"yScale\", vField (field \"category\") ] ] ]\n        , mGroup [ nestedMk [] ]\n        ]\n\n    nestedMk =\n        marks\n            << mark Rect\n                [ mName \"bars\"\n                , mFrom [ srData (str \"facet\") ]\n                , mEncode\n                    [ enEnter\n                        [ maY [ vScale \"pos\", vField (field \"position\") ]\n                        , maHeight [ vScale \"pos\", vBand (num 1) ]\n                        , maX [ vScale \"xScale\", vField (field \"value\") ]\n                        , maX2 [ vScale \"xScale\", vBand (num 0) ]\n                        , maFill [ vScale \"cScale\", vField (field \"position\") ]\n                        ]\n                    ]\n                ]\n\n",
        "type": "Vega.Str -> String -> List Vega.Facet -> Vega.Source"
      },
      {
        "name": "stAs",
        "comment": " Specify the names of the output fields for the computed start and end stack\nvalues of a stack transform.\n",
        "type": "String -> String -> Vega.StackProperty"
      },
      {
        "name": "stField",
        "comment": " Specify the data field that determines the stack heights in a stack transform.\n",
        "type": "Vega.Field -> Vega.StackProperty"
      },
      {
        "name": "stGroupBy",
        "comment": " Specify a grouping of fields with which to partition data into separate stacks\nin a stack transform.\n",
        "type": "List Vega.Field -> Vega.StackProperty"
      },
      {
        "name": "stOffset",
        "comment": " Specify the baseline offset used in a stack transform.\n",
        "type": "Vega.StackOffset -> Vega.StackProperty"
      },
      {
        "name": "stSort",
        "comment": " Specify the criteria for sorting values in a stack transform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.StackProperty"
      },
      {
        "name": "stackOffsetSignal",
        "comment": " Specify a named signal to drive the type of offsetting to apply when\nperforming a stack transform.\n",
        "type": "String -> Vega.StackOffset"
      },
      {
        "name": "str",
        "comment": " Specify a string literal.\n",
        "type": "String -> Vega.Str"
      },
      {
        "name": "strExpr",
        "comment": " Specify an expression that when evaluated, is a string.\n",
        "type": "Vega.Expr -> Vega.Str"
      },
      {
        "name": "strNull",
        "comment": " Specify an absence of a string value.\n",
        "type": "Vega.Str"
      },
      {
        "name": "strSignal",
        "comment": " Specify the name of a signal that will generate a string value.\n",
        "type": "String -> Vega.Str"
      },
      {
        "name": "strSignals",
        "comment": " Specify a list of signals that will generate string values.\n",
        "type": "List String -> Vega.Str"
      },
      {
        "name": "strokeCapSignal",
        "comment": " Specify a type of stroke cap with a given signal. Valid values generated by\nthe signal are the strings `butt`, `round` and `square`.\n",
        "type": "String -> Vega.StrokeCap"
      },
      {
        "name": "strokeCapValue",
        "comment": " A convenience function for generating a value representing a given\nstroke cap type.\n\n    signal \"strokeCap\" [ siValue (strokeCapValue CRound) ]\n\n",
        "type": "Vega.StrokeCap -> Vega.Value"
      },
      {
        "name": "strokeJoinSignal",
        "comment": " Specify a type of stroke join with a given signal. Valid values generated by\nthe signal are the strings `miter`, `round` and `bevel`.\n",
        "type": "String -> Vega.StrokeJoin"
      },
      {
        "name": "strokeJoinValue",
        "comment": " A convenience function for generating a text string representing a given\nstroke join type. This can be used instead of specifying an stroke join type\nas a literal string to avoid problems of mistyping its name.\n\n    signal \"strokeJoin\" [ siValue (strokeJoinValue JBevel) ]\n\n",
        "type": "Vega.StrokeJoin -> Vega.Value"
      },
      {
        "name": "strs",
        "comment": " Specify a list of string literals.\n",
        "type": "List String -> Vega.Str"
      },
      {
        "name": "symPath",
        "comment": " Specify a custom symbol shape as an\n[SVG path description](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n",
        "type": "String -> Vega.Symbol"
      },
      {
        "name": "symbolSignal",
        "comment": " Specify a type of symbol from a signal with the given name. Valid values\ngenerated by the signal are the strings `circle`, `square`, `cross` etc.\n",
        "type": "String -> Vega.Symbol"
      },
      {
        "name": "symbolValue",
        "comment": " A convenience function for generating a value representing a given symbol type.\n\n    maShape [ symbolValue SymTriangleDown ]\n\n",
        "type": "Vega.Symbol -> Vega.Value"
      },
      {
        "name": "teAs",
        "comment": " Specify the output field names within which to write the results of a tree\nlayout transform. The parameters represent the names to replace the defaults in\nthe following order: `x`, `y`, `depth` and `children`.\n",
        "type": "String -> String -> String -> String -> Vega.TreeProperty"
      },
      {
        "name": "teField",
        "comment": " Specify the data corresponding to a numeric value to be associated with nodes\nin a tree transform.\n",
        "type": "Vega.Field -> Vega.TreeProperty"
      },
      {
        "name": "teMethod",
        "comment": " Specify layout method used in a tree transform.\n",
        "type": "Vega.TreeMethod -> Vega.TreeProperty"
      },
      {
        "name": "teNodeSize",
        "comment": " Specify the size of each node in a tree layout as a two-element [width,height]\nlist (or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.TreeProperty"
      },
      {
        "name": "teSize",
        "comment": " Specify the size of of a tree layout as a two-element [width,height] list\n(or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.TreeProperty"
      },
      {
        "name": "teSort",
        "comment": " Specify how sorting of sibling nodes is performed as part of a tree layout\ntransform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.TreeProperty"
      },
      {
        "name": "textDirectionSignal",
        "comment": " Specify a text direction rendering with a given signal. Valid values generated\nby the signal are the strings `ltr` and `rtl` .\n",
        "type": "String -> Vega.TextDirection"
      },
      {
        "name": "textDirectionValue",
        "comment": " Create a text direction value. For example,\n\n      << mark Text\n          [ mFrom [ srData (str \"table\") ]\n          , mEncode\n              [ enEnter\n                  [ maText [ vField (field \"date\") ]\n                  , maDir [ textDirectionValue RightToLeft ]\n                  ]\n          ]\n\n",
        "type": "Vega.TextDirection -> Vega.Value"
      },
      {
        "name": "tgInsert",
        "comment": " Specify an expression that evaluates to data objects to insert as triggers.\nA trigger enables dynamic updates to a visualization. Insert operations are only\napplicable to data sets, not marks.\n",
        "type": "String -> Vega.TriggerProperty"
      },
      {
        "name": "tgModifyValues",
        "comment": " Specify a data or mark modification trigger. The first parameter is an\nexpression that evaluates to data objects to modify and the second parameter an\nexpression that evaluates to an object of name-value pairs, indicating the field\nvalues that should be updated. For example:\n\n    mark Symbol\n        [ mFrom [ srData (str \"countries\") ]\n        , mOn\n            [ trigger \"myDragSignal\"\n                [ tgModifyValues \"dragged\" \"{fx: x(), fy: y()}\" ]\n            ]\n\nwould set the `fx` and `fy` properties on mark items referenced by `myDragSignal`\nto the current mouse pointer position.\n\n",
        "type": "String -> String -> Vega.TriggerProperty"
      },
      {
        "name": "tgRemove",
        "comment": " Specify an expression that evaluates to data objects to remove.\nA trigger enables dynamic updates to a visualization. Remove operations are only\napplicable to data sets, not marks.\n",
        "type": "String -> Vega.TriggerProperty"
      },
      {
        "name": "tgRemoveAll",
        "comment": " Remove all data object triggers.\n",
        "type": "Vega.TriggerProperty"
      },
      {
        "name": "tgToggle",
        "comment": " Specify an expression that evaluates to data objects to toggle. Toggled\nobjects are inserted or removed depending on whether they are already in the\ndata set. Applicable only to data sets, not marks.\n",
        "type": "String -> Vega.TriggerProperty"
      },
      {
        "name": "tiAlign",
        "comment": " Specify the horizontal alignment of a title. If specified this will override\nthe [tiAnchor](#tiAnchor) setting (useful when aligning rotated title text).\n",
        "type": "Vega.HAlign -> Vega.TitleProperty"
      },
      {
        "name": "tiAnchor",
        "comment": " Specify the anchor positioning of a title. Used for aligning title text.\n",
        "type": "Vega.Anchor -> Vega.TitleProperty"
      },
      {
        "name": "tiAngle",
        "comment": " Specify the angle in degrees of a title.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiBaseline",
        "comment": " Specify the vertical title text baseline.\n",
        "type": "Vega.VAlign -> Vega.TitleProperty"
      },
      {
        "name": "tiColor",
        "comment": " Specify the color of a title.\n",
        "type": "Vega.Str -> Vega.TitleProperty"
      },
      {
        "name": "tiEncode",
        "comment": " Specify optional mark encodings for custom title styling. This is a standard\nencoding for text marks and may contain `enEnter`, `enUpdate`, `enExit` and\n`enHover` specifications.\n",
        "type": "List Vega.EncodingProperty -> Vega.TitleProperty"
      },
      {
        "name": "tiFont",
        "comment": " Specify the font name of a title.\n",
        "type": "Vega.Str -> Vega.TitleProperty"
      },
      {
        "name": "tiFontSize",
        "comment": " Specify the font size of a title.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiFontWeight",
        "comment": " Specify the font weight of a title (can be a number such as `vnum 300` or text\nsuch as `vStr \"bold\"`).\n",
        "type": "Vega.Value -> Vega.TitleProperty"
      },
      {
        "name": "tiFrame",
        "comment": " Specify the reference frame for the anchor position of a title.\n",
        "type": "Vega.TitleFrame -> Vega.TitleProperty"
      },
      {
        "name": "tiInteractive",
        "comment": " Specify whether or not a title's properties should respond to input events\nsuch as mouse hover.\n",
        "type": "Vega.Boo -> Vega.TitleProperty"
      },
      {
        "name": "tiLimit",
        "comment": " Specify the maximim allowed length of a title in pixels.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiName",
        "comment": " Specify a mark name to apply to a title text mark. This name can be used to\nrefer to the title mark with an\n[event stream definition](https://vega.github.io/vega/docs/event-streams/).\n",
        "type": "String -> Vega.TitleProperty"
      },
      {
        "name": "tiOffset",
        "comment": " Specify the orthogonal offset in pixels by which to displace the title from\nits position along the edge of the chart.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiOrient",
        "comment": " Specify the positioning of a title relative to the chart.\n",
        "type": "Vega.Side -> Vega.TitleProperty"
      },
      {
        "name": "tiStyle",
        "comment": " Specify a mark style property to apply to the title text mark. If not\nspecified the default style of `group-title` is used.\n",
        "type": "Vega.Str -> Vega.TitleProperty"
      },
      {
        "name": "tiZIndex",
        "comment": " Specify a z-index indicating the layering of the title group relative to\nother axis, mark and legend groups.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "timeUnitSignal",
        "comment": " Specify the name of a signal that will generate time unit.\n",
        "type": "String -> Vega.TimeUnit"
      },
      {
        "name": "title",
        "comment": " Specify the top-level title to be displayed as part of a visualization.\nThe first paramter is the text of the title to display, the second any optional\nproperties for customising the title's appearance.\n",
        "type": "Vega.Str -> List Vega.TitleProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "titleFrameSignal",
        "comment": " Specify a title anchor positioning rule with a given signal. Valid values\ngenerated by the signal should be either `bounds` or `group`.\n",
        "type": "String -> Vega.TitleFrame"
      },
      {
        "name": "tmAs",
        "comment": " Specify the output field names for the output of a treemap layout transform.\nThe parameters correspond to the (default name) fields `x0`, `y0`, `x1`, `y1`,\n`depth` and `children`.\n",
        "type": "String -> String -> String -> String -> String -> String -> Vega.TreemapProperty"
      },
      {
        "name": "tmField",
        "comment": " Specify the data field corresponding to a numeric value for a treemap node.\nThe sum of values for a node and all its descendants is available on the node object\nas the `value` property. This field determines the size of a node.\n",
        "type": "Vega.Field -> Vega.TreemapProperty"
      },
      {
        "name": "tmMethod",
        "comment": " Specify the layout method to use in a treemap transform.\n",
        "type": "Vega.TreemapMethod -> Vega.TreemapProperty"
      },
      {
        "name": "tmPadding",
        "comment": " Specify the inner and outer padding values for a treemap layout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingBottom",
        "comment": " Specify the padding between the bottom edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingInner",
        "comment": " Specify the inner padding values for a treemap layout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingLeft",
        "comment": " Specify the padding between the left edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingOuter",
        "comment": " Specify the outer padding values for a treemap layout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingRight",
        "comment": " Specify the padding between the right edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingTop",
        "comment": " Specify the padding between the top edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmRatio",
        "comment": " Specify the target aspect ratio for the `Squarify` or `Resquarify` treemap layout\ntrqnsformations. The default is the golden ratio, Ï = (1 + sqrt(5)) / 2.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmRound",
        "comment": " Specify whether or not node layout values should be rounded in a treemap transform.\nThe default is false.\n",
        "type": "Vega.Boo -> Vega.TreemapProperty"
      },
      {
        "name": "tmSize",
        "comment": " Specify the size of a treemap layout as two-element list (or signal) corresponding\nto [width, height].\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmSort",
        "comment": " Specify how sorting of sibling nodes is performed during a treemap layout\ntransform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.TreemapProperty"
      },
      {
        "name": "toVega",
        "comment": " Convert a list of Vega specifications into a single JSON object that may be\npassed to Vega for graphics generation. Recommended practice for top-level\nproperties that have more than a simple parameter is to create as a series of\ncompactly named functions (e.g. `ds` for the data source, `sc` for scales, `si`\nfor signals, `ax` for axes etc.) and construct a list of them. For example,\n\n    helloWorld : Spec\n    helloWorld =\n        let\n            table =\n                dataFromColumns \"table\" []\n                    << dataColumn \"label\" (vStrs [ \"Hello\", \"from\", \"elm-vega\" ])\n                    << dataColumn \"x\" (vNums [ 1, 2, 3 ])\n\n            ds =\n                dataSource [ table [] ]\n\n            sc =\n                scales\n                    << scale \"xScale\"\n                        [ scDomain (doData [ daDataset \"table\", daField (field \"x\") ])\n                        , scRange RaWidth\n                        ]\n\n            mk =\n                marks\n                    << mark Text\n                        [ mFrom [ srData (str \"table\") ]\n                        , mEncode\n                            [ enEnter\n                                [ maX [ vScale \"xScale\", vField (field \"x\") ]\n                                , maText [ vField (field \"label\") ]\n                                ]\n                            ]\n                        ]\n        in\n        toVega\n            [ width 100, ds, sc [], mk [] ]\n\n",
        "type": "List ( Vega.VProperty, Vega.Spec ) -> Vega.Spec"
      },
      {
        "name": "topojsonFeature",
        "comment": " Specify a topoJSON feature format. The first parameter is the name of the\nfeatyre object set to extract.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "topojsonMesh",
        "comment": " Specify a named property to extract from topoJSON file. Unlike\n[topojsonFeature](#topojsonFeature), geo data are returned as a single unified\nmesh instance, not as individual GeoJSON features.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "trAggregate",
        "comment": " Ggroup and summarize an input data stream to produce a derived output stream.\nAggregate transforms can be used to compute counts, sums, averages and other\ndescriptive statistics over groups of data objects.\n",
        "type": "List Vega.AggregateProperty -> Vega.Transform"
      },
      {
        "name": "trBin",
        "comment": " Discretises numeric values into a set of bins. The first parameter is the\nfield to bin, the second a two-element numeric list representing the min/max\nextent of the bins. Optional binning properties can be provided in the final parameter.\nCommonly used to create frequency histograms by combining with [trAggregate](#trAggregate)\nto do the counting of field values in each bin.\n\n    transform\n        [ trBin (field \"examScore\") (nums [ 0, 100 ]) []\n        , trAggregate\n            [ agKey (field \"bin0\")\n            , agGroupBy [ field \"bin0\", field \"bin1\" ]\n            , agOps [ Count ]\n            , agAs [ \"count\" ]\n            ]\n        ]\n\n",
        "type": "Vega.Field -> Vega.Num -> List Vega.BinProperty -> Vega.Transform"
      },
      {
        "name": "trCollect",
        "comment": " Collect all the objects in a data stream within a single list, allowing\nsorting by data field values.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.Transform"
      },
      {
        "name": "trContour",
        "comment": " Generate a set of contour (iso) lines at a set of discrete levels. Commonly\nused to visualize density estimates for 2D point data.\n\nThe first two parameters are the width and height over which to compute the contours.\nThe third a list of optional contour properties. The transform generates a new\nstream of GeoJSON data as output which may be visualized using either the\n`trGeoShape` or `trGeoPath` transforms.\n\n    transform\n        [ trContour (numSignal \"width\")\n            (numSignal \"height\")\n            [ cnX (fExpr \"scale('xScale', datum.Horsepower)\")\n            , cnY (fExpr \"scale('yScale', datum.Miles_per_Gallon)\")\n            , cnCount (numSignal \"count\")\n            ]\n        ]\n\n",
        "type": "Vega.Num -> Vega.Num -> List Vega.ContourProperty -> Vega.Transform"
      },
      {
        "name": "trCountPattern",
        "comment": " Count the number of occurrences of a text pattern, as defined by a regular\nexpression. This transform will iterate through each data object and count all\nunique pattern matches found within the designated text field.\n\nThe first parameter is the field containing the text to count, the second a list\nof optional counting properties. The transform generates two fields named `text`\nand `count` unless renamed via `cpAs`.\n\n",
        "type": "Vega.Field -> List Vega.CountPatternProperty -> Vega.Transform"
      },
      {
        "name": "trCross",
        "comment": " Compute the cross-product of a data stream with itself.\n",
        "type": "List Vega.CrossProperty -> Vega.Transform"
      },
      {
        "name": "trCrossFilter",
        "comment": " Maintain a filter mask for multiple dimensional queries, using a set of\nsorted indices. The parameter is a list of (field,range) pairs indicating which\nfields to filter and the numeric range of values in the form of a `num` that\nshould resolve to a [min (inclusive), max (exclusive)] pair.\n",
        "type": "List ( Vega.Field, Vega.Num ) -> Vega.Transform"
      },
      {
        "name": "trCrossFilterAsSignal",
        "comment": " Perform a crossfilter transform. This version can be used with\n[trResolvefilter](#trResolveFilter) to enable fast interactive querying over large\ndata sets. The final parameter is the name of a new signal with which to bind the\nresults of the filter (which can then be referenced by [trResolveFilter](#trResolveFilter)).\n",
        "type": "List ( Vega.Field, Vega.Num ) -> String -> Vega.Transform"
      },
      {
        "name": "trDensity",
        "comment": " Compute a new data stream of uniformly-spaced samples drawn from a one-dimensional\nprobability density function (pdf) or cumulative distribution function (cdf).\nUseful for representing probability distributions and generating continuous\ndistributions from discrete samples through kernel density estimation.\n",
        "type": "Vega.Distribution -> List Vega.DensityProperty -> Vega.Transform"
      },
      {
        "name": "trExtent",
        "comment": " Compute the minimum and maximum values for a data field, producing a two-element\n[min, max] list.\n",
        "type": "Vega.Field -> Vega.Transform"
      },
      {
        "name": "trExtentAsSignal",
        "comment": " Compute the minimum and maximum values for a given data field and bind it to a\nsignal with the given name.\n",
        "type": "Vega.Field -> String -> Vega.Transform"
      },
      {
        "name": "trFilter",
        "comment": " Remove objects from a data stream based on the given filter expression.\n",
        "type": "Vega.Expr -> Vega.Transform"
      },
      {
        "name": "trFlatten",
        "comment": " Map list-valued fields to a set of individual data objects, one per list entry.\nThis version generates the output fields with names corresponding to the list field used.\n",
        "type": "List Vega.Field -> Vega.Transform"
      },
      {
        "name": "trFlattenAs",
        "comment": " Similar to [trFlatten](#trFlatten) but allowing the output fields to be named.\n",
        "type": "List Vega.Field -> List String -> Vega.Transform"
      },
      {
        "name": "trFold",
        "comment": " Collapse one or more data fields into two properties: a _key_ containing the\noriginal data field name and a _value_ containing the data value.\n",
        "type": "List Vega.Field -> Vega.Transform"
      },
      {
        "name": "trFoldAs",
        "comment": " Perform a fold transform generating the key and value fields named by the second\nand third parameters.\n",
        "type": "List Vega.Field -> String -> String -> Vega.Transform"
      },
      {
        "name": "trForce",
        "comment": " Compute a force-directed layout. This layout transformation uses a model in\nwhich data objects act as charged particles (or nodes), optionally connected by\na set of edges (or links). A set of forces is used to drive a physics simulation\nthat determines the node positions.\n",
        "type": "List Vega.ForceSimulationProperty -> Vega.Transform"
      },
      {
        "name": "trFormula",
        "comment": " Extend a data object with new values according to the given\n[Vega expression](https://vega.github.io/vega/docs/expressions/). The second\nparameter is a new field name to give the result of the evaluated expression.\nThis version will reapply the formula if the data changes. To perform a one-off\nformula calculation use [trFormulaInitOnly](#trFormulaInitOnly).\n\n    dataSource\n        [ data \"world\"\n            [ daUrl (str \"https://vega.github.io/vega/data/world-110m.json\")\n            , daFormat [ topojsonFeature \"countries\" ]\n            ]\n            |> transform\n                [ trFormula \"geoCentroid('myProj', datum)\" \"myCentroid\" ]\n        ]\n\n",
        "type": "String -> String -> Vega.Transform"
      },
      {
        "name": "trFormulaInitOnly",
        "comment": " Similar to [trFormula](#trFormula) but will apply the formula only once even\nif the data changes.\n",
        "type": "String -> String -> Vega.Transform"
      },
      {
        "name": "trGeoJson",
        "comment": " Consolidate geographic data into a single feature collection. This can be\ncaptured as a signal that will represent the consolidated feature collection.\n",
        "type": "List Vega.GeoJsonProperty -> Vega.Transform"
      },
      {
        "name": "trGeoPath",
        "comment": " Map GeoJSON features to SVG path strings according to a provided cartographic\nprojection for use with the path mark. Similar to the [trGeoShape](#trGeoShape)\nbut immediately generates SVG path strings.\n",
        "type": "String -> List Vega.GeoPathProperty -> Vega.Transform"
      },
      {
        "name": "trGeoPoint",
        "comment": " Project a longitude, latitude pair to (x,y) coordinates according to the given\nmap projection. The first parameter is the name of the map projection to use, the\nsecond and third the fields containing the longitude and latitude values respectively.\nThis version generates two new fields with the name `x` and `y` holding the\nprojected coordinates.\n",
        "type": "String -> Vega.Field -> Vega.Field -> Vega.Transform"
      },
      {
        "name": "trGeoPointAs",
        "comment": " Similar to [trGeoPoint](#trGeoPoint) but allowing the projected coordinates\nto be named (last two parameters).\n",
        "type": "String -> Vega.Field -> Vega.Field -> String -> String -> Vega.Transform"
      },
      {
        "name": "trGeoShape",
        "comment": " Generate a renderer instance that maps GeoJSON features to a shape instance\nfor use with the shape mark. Similar to the [trGeoPath](#trGeoPath), but rather than\ngenerate intermediate SVG path strings, this transform produces a shape instance\nthat directly generates drawing commands during rendering resulting in improved\nperformance when using canvas rendering for dynamic maps.\n",
        "type": "String -> List Vega.GeoPathProperty -> Vega.Transform"
      },
      {
        "name": "trGraticule",
        "comment": " Generate a reference grid of meridians (longitude) and parallels (latitude)\nfor cartographic maps. The default graticule has meridians and parallels every\n10Â° between Â±80Â° latitude; for the polar regions meridians are every 90Â°.\n\nIt generates a new data stream containing a single GeoJSON data object\nfor the graticule, which can subsequently be drawn using the geopath or geoshape\ntransform.\n\n",
        "type": "List Vega.GraticuleProperty -> Vega.Transform"
      },
      {
        "name": "trIdentifier",
        "comment": " Extend a data object with a globally unique key value. Identifier values are\nassigned using an internal counter. This counter is shared across all instances\nof this transform within a single Vega view, including different data sources,\nbut not across different Vega views.\n",
        "type": "String -> Vega.Transform"
      },
      {
        "name": "trImpute",
        "comment": " Generate new values for missing data. The first parameter is the data field\nfor which missing values should be imputed. The second is a key field that uniquely\nidentifies the data objects within a group and so allows missing values to be\nidentified. The third is a list of optional properties for customising the imputation.\n",
        "type": "Vega.Field -> Vega.Field -> List Vega.ImputeProperty -> Vega.Transform"
      },
      {
        "name": "trJoinAggregate",
        "comment": " Group and summarize an input data stream in a similar way to [trAggregate](#trAggregate)\nbut which is then joined back to the input stream. This can be helpful for creating\nderived values that combine both raw data and aggregate calculations, such as percentages\nof group totals.\n",
        "type": "List Vega.JoinAggregateProperty -> Vega.Transform"
      },
      {
        "name": "trLinkPath",
        "comment": " Route a visual link between two nodes, for example to draw edges in a tree or\nnetwork layout. Writes one property to each datum, providing an SVG path string\nfor the link path.\n",
        "type": "List Vega.LinkPathProperty -> Vega.Transform"
      },
      {
        "name": "trLookup",
        "comment": " Extend a primary data stream by looking up values on a secondary data stream.\nThe first parameter is the name of the secondary data stream upon which to perform\nthe lookup. The second is the key field in that secondary stream. The third is the\nset of key fields from the primary data stream, each of which are then searched\nfor in a single key field of the secondary data stream. Optional customisation\nprovided as a list of properties in the final parameter.\n",
        "type": "String -> Vega.Field -> List Vega.Field -> List Vega.LookupProperty -> Vega.Transform"
      },
      {
        "name": "trNest",
        "comment": " Generate a tree data structure from input data objects by dividing children\ninto groups based on distinct field values. This can provide input to tree layout\nmethods such as [trTree](#trTree), [trTreemap](#trTreemap), [trPack](#trPack) and\n[trPartition](#trPartition).\n",
        "type": "List Vega.Field -> Vega.Boo -> Vega.Transform"
      },
      {
        "name": "trPack",
        "comment": " Compute an enclosure diagram that uses containment (nesting) to represent a\nhierarchy. The size of the leaf circles encodes a quantitative dimension of the\ndata. The enclosing circles show the approximate cumulative size of each subtree,\nbut due to wasted space there is some distortion; only the leaf nodes can be\ncompared accurately.\n",
        "type": "List Vega.PackProperty -> Vega.Transform"
      },
      {
        "name": "trPartition",
        "comment": " Compute the layout for an adjacency diagram: a space-filling variant of a node-link\ntree diagram. Nodes are drawn as solid areas (either arcs or rectangles) sized by\nsome quantitative field, and their placement relative to other nodes reveals their\nposition in the hierarchy.\n",
        "type": "List Vega.PartitionProperty -> Vega.Transform"
      },
      {
        "name": "trPie",
        "comment": " Calculates the angular extents of arc segments laid out in a circle, for example\nto create a pie chart. Writes two properties to each datum, indicating the starting\nand ending angles (in radians) of an arc.\n",
        "type": "List Vega.PieProperty -> Vega.Transform"
      },
      {
        "name": "trPivot",
        "comment": " Map unique values from a field to new aggregated fields in the output stream.\nThe first parameter is the field to pivot on (providing new field names). The second\nis the field containing values to aggregate to populate new values. The third allows\nthe transform to be customised.\n",
        "type": "Vega.Field -> Vega.Field -> List Vega.PivotProperty -> Vega.Transform"
      },
      {
        "name": "trProject",
        "comment": " Perform a relational algebra projection transform resulting in a new stream\nof derived data objects that include one or more fields from the input stream.\nThe parameter is a list of field-name pairs where the fields are those fields to\nbe copied over in the projection and the names are the new names to give the\nprojected fields.\n",
        "type": "List ( Vega.Field, String ) -> Vega.Transform"
      },
      {
        "name": "trResolveFilter",
        "comment": " Use a filter mask generated by a crossfilter transform to generate filtered\ndata streams efficiently. The first prarameter is the signal created by\n[trCrossFilterAsSignal](#trCrossFilterAsSignal) and the second a bit mask indicating\nwhich fields in the crossfilter should be ignored. Each bit corresponds to a field\nand query in the crossfilter transformâs fields and query lists. If the corresponding\nbit is on, that field and query will be ignored when resolving the filter. All other\nqueries must pass the filter for a tuple to be included downstream.\n",
        "type": "String -> Vega.Num -> Vega.Transform"
      },
      {
        "name": "trSample",
        "comment": " Generate a random sample from a data stream to generate a smaller stream. The\nparameter determines the maximum number of data items to sample.\n",
        "type": "Vega.Num -> Vega.Transform"
      },
      {
        "name": "trSequence",
        "comment": " Generate a data stream of numbers between a start (first parameter) and end\n(second parameter) inclusive in increments specified by the third parameter. If\nthe end value is less than the start value, the third parameter should be negative.\nThe resulting output field will be called `data`.\n\nSequences can be used to feed other transforms to generate data, for example to\ncreate random (x,y) coordinates:\n\n    dataSource\n        [ data \"randomData\" []\n            |> transform\n                [ trSequence (num 1) (num 1000) (num 1)\n                , trFormula \"random()\" \"x\"\n                , trFormula \"random()\" \"y\"\n                ]\n        ]\n\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Num -> Vega.Transform"
      },
      {
        "name": "trSequenceAs",
        "comment": " Similar to [trSequence](#trSequence) but allowing the resulting sequence to\nbe named (fourth parameter).\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Num -> String -> Vega.Transform"
      },
      {
        "name": "trStack",
        "comment": " Compute a layout by stacking groups of values. The most common use case is to\ncreate stacked graphs, including stacked bar charts and stream graphs. This\ntransform writes two properties to each datum, indicating the starting and ending\nstack values.\n",
        "type": "List Vega.StackProperty -> Vega.Transform"
      },
      {
        "name": "trStratify",
        "comment": " Generate a hierarchical (tree) data structure from input data objects, based\non key fields that match an id for each node (first parameter) and their parent's\nkey (second parameter) nodes. Internally, this transform generates a set of tree\nnode objects that can then be processed by tree layout methods such as tree,\ntreemap, pack, and partition.\n",
        "type": "Vega.Field -> Vega.Field -> Vega.Transform"
      },
      {
        "name": "trTree",
        "comment": " Compute a node-link diagram layout for hierarchical data. Supports both cluster\nlayouts (for example to create dendrograms) and tidy layouts.\n",
        "type": "List Vega.TreeProperty -> Vega.Transform"
      },
      {
        "name": "trTreeLinks",
        "comment": " Generate a new stream of data objects representing links between nodes in a\ntree. This transform must occur downstream of a tree-generating transform such as\n[trNest](#trNest) or [trStratify](#trStratify). The generated link objects will\nhave `source` and `target` fields that reference input data objects corresponding\nto parent (source) and child (target) nodes.\n",
        "type": "Vega.Transform"
      },
      {
        "name": "trTreemap",
        "comment": " Recursively subdivide an area into rectangles with areas proportional to each\nnodeâs associated value.\n",
        "type": "List Vega.TreemapProperty -> Vega.Transform"
      },
      {
        "name": "trVoronoi",
        "comment": " Compute a voronoi diagram for a set of input points and return the computed\ncell paths.\n",
        "type": "Vega.Field -> Vega.Field -> List Vega.VoronoiProperty -> Vega.Transform"
      },
      {
        "name": "trWindow",
        "comment": " Performs calculations such as ranking, lead/lag analysis and running sums over\nsorted groups of data objects . Calculated values are written back to the input\ndata stream.\n\n    transform\n        [ trWindow [ wnOperation RowNumber \"rank\" ]\n            [ wnSort [ ( field \"myField\", Descend ) ] ]\n        ]\n\n",
        "type": "List Vega.WindowOperation -> List Vega.WindowProperty -> Vega.Transform"
      },
      {
        "name": "trWordcloud",
        "comment": " Compute a word cloud layour similar to a 'wordle'. Useful for visualising the\nrelative frequency of words or phrases.\n\n    mark Text\n        [ mTransform\n            [ trWordcloud\n                [ wcSize (nums [ 800, 400 ])\n                , wcText (field \"text\")\n                , wcRotate (numExpr (exField \"datum.angle\"))\n                , wcFontSize (numExpr (exField \"datum.count\"))\n                , wcFontWeight (strExpr (exField \"datum.weight\"))\n                , wcFontSizeRange (nums [ 12, 56 ])\n                ]\n            ]\n        ]\n\n",
        "type": "List Vega.WordcloudProperty -> Vega.Transform"
      },
      {
        "name": "transform",
        "comment": " Apply the given ordered list of transforms to the given data stream. Transform\nexamples include filtering, creating new data fields from expressions and creating\nnew data fields suitable for a range of visualization and layout types.\n",
        "type": "List Vega.Transform -> Vega.DataTable -> Vega.DataTable"
      },
      {
        "name": "transparent",
        "comment": " Convenience function for specifying a transparent setting for marks that can\nbe colored (e.g. with [maFill](#maFill))\n",
        "type": "Vega.Value"
      },
      {
        "name": "treeMethodSignal",
        "comment": " Specify that a tree layout method is to be determined by a named signal.\nThe signal should generate either `tidy` or `cluster`.\n",
        "type": "String -> Vega.TreeMethod"
      },
      {
        "name": "treemapMethodSignal",
        "comment": " Specify a treemap layout method type is to be determined by a named signal.\nThe signal should generate the one of `squarify`, `resquarify`, `binary`, `dice`,\n`slice` or `slicedice`.\n",
        "type": "String -> Vega.TreemapMethod"
      },
      {
        "name": "trigger",
        "comment": " Creates a trigger that may be applied to a data table or mark.\nThe first parameter is the name of the trigger and the second\na list of trigger actions.\n",
        "type": "String -> List Vega.TriggerProperty -> Vega.Trigger"
      },
      {
        "name": "true",
        "comment": " Specify a Boolean true value.\n",
        "type": "Vega.Boo"
      },
      {
        "name": "vAlignSignal",
        "comment": " Specify the vertical alignment of some text based on the value of the\nnamed signal.\n",
        "type": "String -> Vega.VAlign"
      },
      {
        "name": "vAlphabetic",
        "comment": " Convenience function for indicating an alphabetic vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vBand",
        "comment": " Specify a band number or fraction of a band number. Band scales are used when\naggregating data into discrete categories such as in a frequency histogram.\n",
        "type": "Vega.Num -> Vega.Value"
      },
      {
        "name": "vBoos",
        "comment": " Specify a list of Boolean values.\n",
        "type": "List Bool -> Vega.Value"
      },
      {
        "name": "vBottom",
        "comment": " Convenience function for indicating a bottom vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vColor",
        "comment": " Specify a color value.\n",
        "type": "Vega.ColorValue -> Vega.Value"
      },
      {
        "name": "vExponent",
        "comment": " Specify an exponential value modifier.\n",
        "type": "Vega.Value -> Vega.Value"
      },
      {
        "name": "vFalse",
        "comment": " Specify a 'false' value.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vField",
        "comment": " Specify a data or signal field.\n",
        "type": "Vega.Field -> Vega.Value"
      },
      {
        "name": "vMiddle",
        "comment": " Convenience function for indicating a middle vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vMultiply",
        "comment": " Specify a multiplication value modifier.\n",
        "type": "Vega.Value -> Vega.Value"
      },
      {
        "name": "vNull",
        "comment": " Specify a absence of a value.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vNum",
        "comment": " Specify a numeric value.\n",
        "type": "Float -> Vega.Value"
      },
      {
        "name": "vNums",
        "comment": " Specify a list of numbers.\n",
        "type": "List Float -> Vega.Value"
      },
      {
        "name": "vObject",
        "comment": " Specify an object containing a list of [key-value](#keyValue) pairs.\n",
        "type": "List Vega.Value -> Vega.Value"
      },
      {
        "name": "vOffset",
        "comment": " Specify an additive value modifier.\n",
        "type": "Vega.Value -> Vega.Value"
      },
      {
        "name": "vRound",
        "comment": " Specify a rounding value modifier. Rounding is applied after all other modifiers.\n",
        "type": "Vega.Boo -> Vega.Value"
      },
      {
        "name": "vScale",
        "comment": " Specify the name of a scale.\n",
        "type": "String -> Vega.Value"
      },
      {
        "name": "vScaleField",
        "comment": " Specify a scale field used to dynamically look up a scale name.\n",
        "type": "Vega.Field -> Vega.Value"
      },
      {
        "name": "vSignal",
        "comment": " Specify a named signal.\n",
        "type": "String -> Vega.Value"
      },
      {
        "name": "vStr",
        "comment": " Specify a string value.\n",
        "type": "String -> Vega.Value"
      },
      {
        "name": "vStrs",
        "comment": " Specify a list of string values.\n",
        "type": "List String -> Vega.Value"
      },
      {
        "name": "vTop",
        "comment": " Convenience function for indicating a top vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vTrue",
        "comment": " Specify a 'true' value.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vValues",
        "comment": " Specify a list of values. Used for nesting collections of possibly mixed types.\n",
        "type": "List Vega.Value -> Vega.Value"
      },
      {
        "name": "voAs",
        "comment": " Specify the name of the output field of a voronoi transform. If not specified,\nthe default is `path`.\n",
        "type": "String -> Vega.VoronoiProperty"
      },
      {
        "name": "voExtent",
        "comment": " Specify the extent of the voronoi cells in a voronoi transform. The two parameters\nshould each evaluate to a list of two numbers representing the coordinates of the\ntop-left and bottom-right of the extent respectively.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.VoronoiProperty"
      },
      {
        "name": "voSize",
        "comment": " Specify extent of the voronoi cells in a voronoi transform. The single parameter\nshould evaluate to a list of two numbers representing the bottom-right of the extent.\nThe top-left is assumed to be [0,0].\n",
        "type": "Vega.Num -> Vega.VoronoiProperty"
      },
      {
        "name": "wOperationSignal",
        "comment": " Specify that a window operation is to be determined by a named signal. The\nsignal should generate the name of a valid operation (e.g. `dense_rank`).\nFor names of valid window operations see the\n[Vega window operation documentation](https://vega.github.io/vega/docs/transforms/window/#ops)\n",
        "type": "String -> Vega.WOperation"
      },
      {
        "name": "wcAs",
        "comment": " Specify the output fields created by a word cloud transform. The parameters\nmap to the following default values: `x`, `y`, `font`, `fontSize`, `fontStyle`,\n`fontWeight` and `angle`.\n",
        "type": "String -> String -> String -> String -> String -> String -> String -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFont",
        "comment": " Specify the font family to use for a word in a wordcloud.\n",
        "type": "Vega.Str -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontSize",
        "comment": " Specify the font size to use for a word in a wordcloud.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontSizeRange",
        "comment": " Specify the font size range to use for words in a wordcloud. The parameter should\nresolve to a two-element list [min,max]. The size of words in a wordcloud will be\nscaled to lie in the given range according to the square root scale.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontStyle",
        "comment": " Specify the font style to use for words in a wordcloud.\n",
        "type": "Vega.Str -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontWeight",
        "comment": " Specify the font weights to use for words in a wordcloud.\n",
        "type": "Vega.Str -> Vega.WordcloudProperty"
      },
      {
        "name": "wcPadding",
        "comment": " Specify the padding, in pixels, to be placed around words in a wordcloud.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcRotate",
        "comment": " Specify the angle in degrees of words in a wordcloud layout.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcSize",
        "comment": " Specify size of layout created by a wordcloud transform. The parameter should\nresolve to a two-element list [width, height] in pixels.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcSpiral",
        "comment": " Specify spiral layout method for a wordcloud transform.\n",
        "type": "Vega.Spiral -> Vega.WordcloudProperty"
      },
      {
        "name": "wcText",
        "comment": " Specify data field with the input word text for a wordcloud transform.\n",
        "type": "Vega.Field -> Vega.WordcloudProperty"
      },
      {
        "name": "white",
        "comment": " Convenience function for specifying a white color setting for marks that can\nbe colored (e.g. with [maStroke](#maStroke))\n",
        "type": "Vega.Value"
      },
      {
        "name": "width",
        "comment": " Override the default width of the visualization. If not specified the width\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "wnAggOperation",
        "comment": " Specify an aggregate operation to be applied during a window transformation.\nThis version is suitable for operations without parameters (e.g. `RowNumber`) and\nthat are not applied to a specific field.\n\nThe parameters are the operation to apply, the input field (or `Nothing` if no input\nfield) and the name to give to the field which will contain the results of the calculation.\n\nThe example below calculates the average over an unbounded window:\n\n    transform\n        [ trWindow [ wnAggOperation Mean (Just (field \"IMDB_Rating\")) \"avScore\" ]\n            [ wnFrame numNull ]\n        ]\n\n",
        "type": "Vega.Operation -> Maybe.Maybe Vega.Field -> String -> Vega.WindowOperation"
      },
      {
        "name": "wnFrame",
        "comment": " Specify a two-element list indicating how the sliding window should proceed\nduring a window transform. The list entries should either be a number indicating\nthe offset from the current data object, or `NumNull` to indicate unbounded rows\npreceding or following the current data object.\n",
        "type": "Vega.Num -> Vega.WindowProperty"
      },
      {
        "name": "wnGroupBy",
        "comment": " Specify the data fields by which to partition data objects into separate windows\nduring a window transform. If not specified, a single group containing all data\nobjects will be used.\n",
        "type": "List Vega.Field -> Vega.WindowProperty"
      },
      {
        "name": "wnIgnorePeers",
        "comment": " Specify whether or not a sliding frame in a window transform should ignore\npeer values.\n",
        "type": "Vega.Boo -> Vega.WindowProperty"
      },
      {
        "name": "wnOperation",
        "comment": " Specify a window-specific operation to be applied during a window transformation.\nThis version is suitable for operations without parameters (e.g. `RowNumber`) and\nthat are not applied to a specific field.\n\nThe parameters are the operation to apply and the name to give to the field which\nwill contain the results of the calculation.\n\n    transform\n        [ trWindow [ wnOperation Rank \"order\" ]\n            [ wnSort [ ( field \"Gross\", Descend ) ] ]\n        ]\n\n",
        "type": "Vega.WOperation -> String -> Vega.WindowOperation"
      },
      {
        "name": "wnOperationOn",
        "comment": " Specify a window-specific operation to be applied during a window transformation.\nThis version is suitable for operations that have a parameter (e.g. `Lag` or `Lead`)\nand/or operations that require a specific field as input (e.g. `LastValue`).\nThe parameters are in order: the type of operation, a possible operation parameter,\nthe field to apply it to and its output field name.\n\n    transform\n        [ trWindow\n            [ wnOperationOn Lag\n                (Just (num 5))\n                (Just (field \"temperature\"))\n                \"oldTemp\"\n            ]\n            []\n        ]\n\n",
        "type": "Vega.WOperation -> Maybe.Maybe Vega.Num -> Maybe.Maybe Vega.Field -> String -> Vega.WindowOperation"
      },
      {
        "name": "wnSort",
        "comment": " Specify how sorting data objects is applied within a window transform.\n\n    transform\n        [ trWindow [ wnOperation RowNumber \"order\" ]\n          [ wnSort [ ( field \"score\", Ascend ) ] ]\n        ]\n\nIf two objects are equal in terms of sorting field datum by they are considered\n'peers'. If no sorting comparator is specified, data objects are processed in the\norder they are observed.\n\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.WindowProperty"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "VegaLite",
    "comment": " Create Vega-Lite specifications in Elm. A specification can be sent to a\nVega-Lite compiler to generate the graphics. While this a pure Elm library, to\ngenerate the graphical output you probably want to send the JSON generated by\n`toVegaLite` via a port to some JavaScript that invokes the Vega-Lite runtime.\n\n\n# Creating A Vega-Lite Specification\n\n@docs toVegaLite\n@docs VLProperty\n@docs Spec\n@docs LabelledSpec\n@docs combineSpecs\n\n\n# Creating the Data Specification\n\nFunctions and types for declaring the data to the visualized. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format).\n\n@docs dataFromUrl\n@docs dataFromColumns\n@docs dataFromRows\n@docs dataFromJson\n@docs dataFromSource\n@docs dataName\n@docs datasets\n@docs dataColumn\n@docs dataRow\n@docs Data\n@docs DataColumn\n@docs DataRow\n\n\n## Geographic Data\n\n@docs geometry\n@docs geoFeatureCollection\n@docs geometryCollection\n@docs geoPoint\n@docs geoPoints\n@docs geoLine\n@docs geoLines\n@docs geoPolygon\n@docs geoPolygons\n@docs DataType\n\n\n## Formating Input Data\n\nSee the Vega-Lite\n[format](https://vega.github.io/vega-lite/docs/data.html#format),\n[JSON](https://vega.github.io/vega-lite/docs/data.html#json) documentation.\n\n@docs Format\n@docs jsonProperty\n@docs topojsonFeature\n@docs topojsonMesh\n@docs parse\n@docs dsv\n\n@docs foDate\n@docs foUtc\n\n\n# Creating the Transform Specification\n\nTransformation rules are applied to data fields or geospatial coordinates before\nthey are encoded visually.\n\n@docs transform\n\n\n## Map Projections\n\nSee the\n[Vega-Lite map projection documentation](https://vega.github.io/vega-lite/docs/projection.html).\n\n@docs projection\n\n@docs prType\n@docs prClipAngle\n@docs prClipExtent\n@docs prCenter\n@docs prRotate\n@docs prPrecision\n@docs prCoefficient\n@docs prDistance\n@docs prFraction\n@docs prLobes\n@docs prParallel\n@docs prRadius\n@docs prRatio\n@docs prSpacing\n@docs prTilt\n\n@docs Projection\n@docs customProjection\n@docs ClipRect\n@docs clipRect\n\n\n## Aggregation\n\nSee the\n[Vega-Lite aggregate documentation](https://vega.github.io/vega-lite/docs/aggregate.html).\n\n@docs aggregate\n@docs Operation\n@docs opAs\n@docs timeUnitAs\n\n\n## Binning\n\nSee the [Vega-Lite binning documentation](https://vega.github.io/vega-lite/docs/bin.html).\n\n@docs binAs\n@docs biBase\n@docs biDivide\n@docs biExtent\n@docs biMaxBins\n@docs biMinStep\n@docs biNice\n@docs biStep\n@docs biSteps\n\n\n## Data Calculation\n\nSee\n[Vega-Lite calculate documentation](https://vega.github.io/vega-lite/docs/calculate.html).\n\n@docs calculateAs\n\n\n## Filtering\n\nSee the\n[Vega-Lite filter documentation](https://vega.github.io/vega-lite/docs/filter.html).\n\n@docs filter\n\n@docs fiEqual\n@docs fiLessThan\n@docs fiLessThanEq\n@docs fiGreaterThan\n@docs fiGreaterThanEq\n@docs fiExpr\n@docs fiCompose\n@docs fiSelection\n@docs fiOneOf\n@docs fiRange\n@docs numRange\n@docs dtRange\n\n\n## Flattening\n\nSee the Vega-Lite [flatten](https://vega.github.io/vega-lite/docs/flatten.html)\nand [fold](https://vega.github.io/vega-lite/docs/fold.html) documentation.\n\n@docs flatten\n@docs flattenAs\n@docs fold\n@docs foldAs\n\n\n## Relational Joining (lookup)\n\nSee the [Vega-Lite lookup documentation](https://vega.github.io/vega-lite/docs/lookup.html)\nfor further details.\n\n@docs lookup\n@docs lookupAs\n\n\n## Window Transformations\n\nSee the Vega-Lite\n[window transform field](https://vega.github.io/vega-lite/docs/window.html#field-def)\nand [window transform](https://vega.github.io/vega-lite/docs/window.html#window-transform-definition)\ndocumentation.\n\n@docs windowAs\n@docs wiAggregateOp\n@docs wiOp\n@docs WindowOperation\n@docs wiParam\n@docs wiField\n\n@docs wiFrame\n@docs wiIgnorePeers\n@docs wiGroupBy\n@docs wiSort\n@docs wiAscending\n@docs wiDescending\n\n\n# Creating the Mark Specification\n\nFunctions for declaring the type of visual marks used in the visualization.\n\n@docs area\n@docs bar\n@docs boxplot\n@docs errorband\n@docs errorbar\n@docs circle\n@docs geoshape\n@docs line\n@docs point\n@docs rect\n@docs rule\n@docs square\n@docs textMark\n@docs tick\n@docs trail\n\n\n## Mark Properties\n\nSee the Vega-Lite\n[general mark](https://vega.github.io/vega-lite/docs/mark.html#general-mark-properties),\n[area mark](https://vega.github.io/vega-lite/docs/area.html#properties),\n[bar mark](https://vega.github.io/vega-lite/docs/bar.html),\n[hyperlink mark](https://vega.github.io/vega-lite/docs/mark.html#hyperlink),\n[line mark](https://vega.github.io/vega-lite/docs/line.html#properties),\n[point mark](https://vega.github.io/vega-lite/docs/point.html#properties),\n[text mark](https://vega.github.io/vega-lite/docs/text.html) and\n[tick mark](https://vega.github.io/vega-lite/docs/tick.html#config)\nproperty documentation.\n\n@docs maAlign\n@docs maAngle\n@docs maBandSize\n@docs maBaseline\n@docs maBinSpacing\n@docs maBorders\n@docs maClip\n@docs maColor\n@docs maCursor\n@docs maExtent\n@docs maHRef\n@docs maContinuousBandSize\n@docs maDiscreteBandSize\n@docs maDx\n@docs maDy\n@docs maFill\n@docs maFilled\n@docs maFillOpacity\n@docs maFont\n@docs maFontSize\n@docs maFontStyle\n@docs maFontWeight\n@docs maInterpolate\n@docs maOpacity\n@docs maOrient\n@docs maPoint\n@docs maLine\n@docs maRadius\n@docs maRule\n@docs maShape\n@docs maShortTimeLabels\n@docs maSize\n@docs maStroke\n@docs maStrokeCap\n@docs StrokeCap\n@docs maStrokeDash\n@docs maStrokeDashOffset\n@docs maStrokeJoin\n@docs StrokeJoin\n@docs maStrokeMiterLimit\n@docs maStrokeOpacity\n@docs maStrokeWidth\n@docs maStyle\n@docs maTension\n@docs maText\n@docs maTheta\n@docs maThickness\n@docs maTicks\n@docs maXOffset\n@docs maYOffset\n@docs maX2Offset\n@docs maY2Offset\n\n\n### Used by Mark Properties\n\n@docs MarkOrientation\n@docs MarkInterpolation\n@docs Symbol\n@docs symbolPath\n@docs Cursor\n@docs PointMarker\n@docs pmMarker\n@docs LineMarker\n@docs lmMarker\n@docs SummaryExtent\n@docs iqrScale\n\n\n# Creating the Encoding Specification\n\nTypes and functions for declaring which data fields (data) are mapped to which channels\n(position, color etc.).\n\n@docs encoding\n@docs Measurement\n\n\n## Position channel\n\nRelates to where something appears in the visualization.\nSee the\n[Vega-Lite position documentation](https://vega.github.io/vega-lite/docs/encoding.html#position)\n\n@docs position\n@docs Position\n\n\n### Position Channel Properties\n\n@docs pName\n@docs pRepeat\n@docs pMType\n@docs pBin\n@docs pTimeUnit\n@docs pTitle\n@docs pAggregate\n@docs pScale\n@docs pAxis\n@docs pSort\n@docs pStack\n@docs pWidth\n@docs pHeight\n\n\n## Properties Used by Position Channels\n\n\n## Sorting Properties\n\nSee the\n[Vega-Lite sort documentation](https://vega.github.io/vega-lite/docs/sort.html).\n\n@docs SortProperty\n@docs soByField\n@docs soByRepeat\n@docs soCustom\n\n\n## Stacking Properties\n\n@docs StackProperty\n\n\n## Axis Properties\n\nSee the\n[Vega-Lite axis property documentation](https://vega.github.io/vega-lite/docs/axis.html#axis-properties)\n\n@docs axDomain\n@docs axFormat\n@docs axGrid\n@docs axLabelAngle\n@docs axLabelOverlap\n@docs axLabelPadding\n@docs axLabels\n@docs axMaxExtent\n@docs axMinExtent\n@docs axOffset\n@docs axOrient\n@docs axPosition\n@docs axTicks\n@docs axTickCount\n@docs axTickSize\n@docs axTitle\n@docs axTitleAlign\n@docs axTitleAngle\n@docs axTitleMaxLength\n@docs axTitlePadding\n@docs axValues\n@docs axDates\n@docs axZIndex\n\n\n## Positioning Constants\n\n@docs OverlapStrategy\n@docs Side\n@docs HAlign\n@docs VAlign\n\n\n## Mark channels\n\nRelate to the appearance of the visual marks in the visualization such as their\ncolor or size.\n\n@docs size\n@docs color\n@docs fill\n@docs stroke\n@docs opacity\n@docs shape\n\n\n### Mark Channel Properties\n\n@docs mName\n@docs mRepeat\n@docs mMType\n@docs mScale\n@docs mBin\n@docs mTimeUnit\n@docs mTitle\n@docs mAggregate\n@docs mLegend\n@docs mPath\n@docs mNum\n@docs mStr\n@docs mBoo\n\n\n### Mark Legends\n\nSee the\n[Vega-Lite legend property documentation](https://vega.github.io/vega-lite/docs/legend.html#legend-properties).\n\n@docs leFormat\n@docs leOffset\n@docs leOrient\n@docs lePadding\n@docs leTickCount\n@docs leTitle\n@docs leType\n@docs leValues\n@docs leZIndex\n@docs Legend\n@docs LegendOrientation\n@docs leNums\n@docs leStrs\n@docs leDts\n\n\n## Text Channels\n\nRelate to the appearance of the text and tooltip elements of the visualization.\nSee the\n[Vega-Lite text documentation](https://vega.github.io/vega-lite/docs/encoding.html#text)\n\n@docs text\n@docs tooltip\n@docs tooltips\n@docs tName\n@docs tRepeat\n@docs tMType\n@docs tBin\n@docs tAggregate\n@docs tTimeUnit\n@docs tTitle\n@docs tFormat\n@docs FontWeight\n\n\n## Hyperlink Channel\n\nRelates to a clickable URL destination of a mark. Unlike most other channels, the\nhyperlink channel has no direct visual expression other than the option of changing\nthe cursor style when hovering, so an encoding will usually pair hyperlinks with\nother visual channels such as marks or texts. See the\n[Vega-Lite hyperlink documentation](https://vega.github.io/vega-lite/docs/encoding.html#href)\n\n@docs hyperlink\n@docs hName\n@docs hRepeat\n@docs hMType\n@docs hBin\n@docs hAggregate\n@docs hTimeUnit\n@docs hStr\n\n\n## Order channels\n\nChannels that relate to the order of data fields such as for sorting stacking order\nor order of data points in a connected scatterplot. See the\n[Vega-Lite order documentation](https://vega.github.io/vega-lite/docs/encoding.html#order).\n\n@docs order\n@docs oName\n@docs oRepeat\n@docs oMType\n@docs oBin\n@docs oAggregate\n@docs oSort\n@docs oTimeUnit\n\n\n## Facet channels\n\nChannels for faceting single plots into small multiples. Can be used to create\ntrellis plots or other arrangements in rows and columns. See the\n[Vega-Lite facet documentation](https://vega.github.io/vega-lite/docs/encoding.html#facet).\nSee also, 'faceted view composition' for a more flexible (but more verbose) way\nof defining faceted views.\n\n@docs row\n@docs column\n\n\n## Level of detail Channel\n\nUsed for grouping data but without changing the visual appearance of a mark. When,\nfor example, a field is encoded by color, all data items with the same value for\nthat field are given the same color. When a detail channel encodes a field, all\ndata items with the same value are placed in the same group. This allows, for example\na line chart with multiple lines to be created â one for each group. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#detail)\nfor more information.\n\n@docs detail\n@docs dName\n@docs dMType\n@docs dAggregate\n@docs dBin\n@docs dTimeUnit\n\n\n## Scaling\n\nUsed to specify how the encoding of a data field should be applied. See the\n[Vega-Lite scale documentation](https://vega.github.io/vega-lite/docs/scale.html).\n\n@docs scType\n@docs scDomain\n@docs scRange\n@docs scScheme\n@docs scPadding\n@docs scPaddingInner\n@docs scPaddingOuter\n@docs scRangeStep\n@docs scRound\n@docs scClamp\n@docs scInterpolate\n@docs scNice\n@docs scZero\n@docs scReverse\n\n@docs Scale\n@docs raName\n@docs raNums\n@docs raStrs\n@docs categoricalDomainMap\n@docs domainRangeMap\n@docs ScaleDomain\n@docs doNums\n@docs doStrs\n@docs doDts\n@docs doSelection\n\n@docs ScaleNice\n@docs scNiceTickCount\n@docs scNiceInterval\n\n\n### Color Scaling\n\n@docs CInterpolate\n@docs cubeHelix\n@docs cubeHelixLong\n@docs rgb\n\n\n# Creating view compositions\n\nViews can be combined to create more complex multiview displays. This may involve\nlayering views on top of each other (superposition) or laying them out in adjacent\nspaces (juxtaposition using `repeat`, `facet`, `hConcat` or `vConcat`). Where different\nviews have potentially conflicting channels (e.g. two position scales in a layered\nvisualization) the rules for resolving them can be defined with `resolve`.\nSee the\n[Vega-Lite composition documentation](https://vega.github.io/vega-lite/docs/composition.html)\n\n@docs layer\n@docs hConcat\n@docs vConcat\n@docs resolve\n@docs resolution\n@docs align\n@docs alignRC\n@docs CompositionAlignment\n@docs bounds\n@docs Bounds\n@docs spacing\n@docs spacingRC\n@docs center\n@docs centerRC\n\n@docs reAxis\n@docs reLegend\n@docs reScale\n@docs Channel\n@docs Resolution\n\n\n## Faceted views\n\nThese are small multiples each of which show subsets of the same dataset. The specification\ndetermines which field should be used to determine subsets along with their spatial\narrangement (in rows or columns). For details see the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/facet.html)\n\n@docs repeat\n@docs rowFields\n@docs columnFields\n@docs facet\n@docs columnBy\n@docs rowBy\n\n@docs fName\n@docs fMType\n@docs fAggregate\n@docs fBin\n@docs fHeader\n@docs fTimeUnit\n\n@docs asSpec\n@docs specification\n@docs Arrangement\n\n\n### Facet Headers\n\nSee\n[Vega-Lite header documentation](https://vega.github.io/vega-lite/docs/header.html)\n\n@docs hdLabelAngle\n@docs hdLabelColor\n@docs hdLabelFont\n@docs hdLabelFontSize\n@docs hdLabelLimit\n\n@docs hdTitle\n@docs hdTitleAnchor\n@docs hdTitleAngle\n@docs hdTitleBaseline\n@docs hdTitleColor\n@docs hdTitleFont\n@docs hdTitleFontWeight\n@docs hdTitleFontSize\n@docs hdTitleLimit\n\n@docs hdFormat\n\n\n# Creating Selections for Interaction\n\nSelections allow a visualization to respond to interactions (such as clicking or\ndragging). They transform interactions into data queries. See the Vega-Lite\n[selection](https://vega.github.io/vega-lite/docs/selection.html) and\n[bind](https://vega.github.io/vega-lite/docs/bind.html)\ndocumentation.\n\n@docs selection\n@docs select\n@docs Selection\n@docs SelectionProperty\n@docs seBind\n@docs seEncodings\n@docs seFields\n@docs seNearest\n@docs seOn\n@docs seResolve\n@docs seSelectionMark\n@docs seToggle\n@docs seTranslate\n@docs seZoom\n\n@docs iRange\n@docs iCheckbox\n@docs iRadio\n@docs iSelect\n@docs iText\n@docs iNumber\n@docs iDate\n@docs iTime\n@docs iMonth\n@docs iWeek\n@docs iDateTimeLocal\n@docs iTel\n@docs iColor\n\n@docs inDebounce\n@docs inElement\n@docs inOptions\n@docs inMin\n@docs inMax\n@docs inName\n@docs inStep\n@docs inPlaceholder\n\n@docs SelectionResolution\n\n@docs smFill\n@docs smFillOpacity\n@docs smStroke\n@docs smStrokeDash\n@docs smStrokeDashOffset\n@docs smStrokeOpacity\n@docs smStrokeWidth\n\n\n## Making conditional channel encodings\n\nTo make channel encoding conditional on the result of some interaction, use\n[mSelectionCondition](#mSelectionCondition) (and its 't' and 'h' variants). Similarly\n[mDataCondition](#mDataCondition) (and its 't' and 'h' variants) will encode a mark\nconditionally depending on some data properties such as whether a datum is null\nor an outlier.\n\nFor interaction, once a selection has been defined and named, supplying a set of\nencodings allow mark encodings to become dependent on that selection.\n`mSelectionCondition` is followed firstly a (Boolean) selection and then an\nencoding if that selection is true and another encoding to be applied if it is false.\nThe color specification below states \"whenever data marks are selected with an\ninterval mouse drag, encode the cylinder field with an ordinal color scheme,\notherwise make them grey\":\n\n    sel =\n        selection << select \"myBrush\" Interval []\n\n    enc =\n        encoding\n            << position X [ pName \"Horsepower\", pMType Quantitative ]\n            << position Y [ pName \"Miles_per_Gallon\", pMType Quantitative ]\n            << color\n                [ mSelectionCondition (selectionName \"myBrush\")\n                    [ mName \"Cylinders\", mMType Ordinal ]\n                    [ mStr \"grey\" ]\n                ]\n\nIn a similar way, `mDataCondition` will encocode a mark depending on whether any\npredicate tests are satisfied. Unlike slections, multiple conditions and associated\nencodings can be specified. Each test condition is evaluated in order and only on\nfailure of the test does encoding procede to the next test. If no tests are true,\nthe encoding in the final parameter is applied in a similar way to 'case of'\nexpressions:\n\n    enc =\n        encoding\n            << position X [ pName \"value\", pMType Ordinal ]\n            << color\n                [ mDataCondition\n                    [ ( expr \"datum.value < 40\", [ mStr \"blue\" ] )\n                    , ( expr \"datum.value < 50\", [ mStr \"red\" ] )\n                    , ( expr \"datum.value < 60\", [ mStr \"yellow\" ] )\n                    ]\n                    [ mStr \"black\" ]\n                ]\n\nSee the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/condition.html).\n\n@docs mSelectionCondition\n@docs mDataCondition\n@docs tSelectionCondition\n@docs tDataCondition\n@docs hDataCondition\n@docs hSelectionCondition\n\n@docs and\n@docs or\n@docs not\n@docs expr\n@docs selected\n@docs selectionName\n\n\n# Global Configuration\n\nConfiguration options that affect the entire visualization. These are in addition\nto the data and transform options described above. See the\n[Vega-Lite top level spec documentation](https://vega.github.io/vega-lite/docs/spec.html#top-level-specifications)\n\n@docs name\n@docs title\n@docs description\n@docs height\n@docs width\n@docs padding\n@docs paSize\n@docs paEdges\n@docs autosize\n@docs Autosize\n@docs background\n\n\n## Style Setting\n\nAllows default properties for most marks and guides to be set. See the\n[Vega-Lite configuration documentation](https://vega.github.io/vega-lite/docs/config.html).\n\n@docs configure\n@docs configuration\n\n@docs coArea\n@docs coAutosize\n@docs coAxis\n@docs coAxisX\n@docs coAxisY\n@docs coAxisLeft\n@docs coAxisRight\n@docs coAxisTop\n@docs coAxisBottom\n@docs coAxisBand\n@docs coBackground\n@docs coBar\n@docs coCircle\n@docs coCountTitle\n@docs coFieldTitle\n@docs coGeoshape\n@docs coLegend\n@docs coLine\n@docs coMark\n@docs coNamedStyle\n@docs coNumberFormat\n@docs coPadding\n@docs coPoint\n@docs coProjection\n@docs coRange\n@docs coRect\n@docs coRemoveInvalid\n@docs coRule\n@docs coScale\n@docs coSelection\n@docs coSquare\n@docs coStack\n@docs coText\n@docs coTick\n@docs coTitle\n@docs coTimeFormat\n@docs coTrail\n@docs coView\n\n\n## Axis Configuration Options\n\nSee the\n[Vega-Lite axis config documentation](https://vega.github.io/vega-lite/docs/axis.html#general-config).\n\n@docs axcoBandPosition\n@docs axcoDomain\n@docs axcoDomainColor\n@docs axcoDomainWidth\n@docs axcoMaxExtent\n@docs axcoMinExtent\n@docs axcoGrid\n@docs axcoGridColor\n@docs axcoGridDash\n@docs axcoGridOpacity\n@docs axcoGridWidth\n@docs axcoLabels\n@docs axcoLabelAngle\n@docs axcoLabelColor\n@docs axcoLabelFont\n@docs axcoLabelFontSize\n@docs axcoLabelLimit\n@docs axcoLabelOverlap\n@docs axcoLabelPadding\n@docs axcoShortTimeLabels\n@docs axcoTicks\n@docs axcoTickColor\n@docs axcoTickRound\n@docs axcoTickSize\n@docs axcoTickWidth\n@docs axcoTitleAlign\n@docs axcoTitleAngle\n@docs axcoTitleBaseline\n@docs axcoTitleColor\n@docs axcoTitleFont\n@docs axcoTitleFontWeight\n@docs axcoTitleFontSize\n@docs axcoTitleLimit\n@docs axcoTitleMaxLength\n@docs axcoTitlePadding\n@docs axcoTitleX\n@docs axcoTitleY\n\n\n## Legend Configuration Options\n\nSee the\n[Vega-Lite legend configuration documentation](https://vega.github.io/vega-lite/docs/legend.html#config).\n\n@docs lecoCornerRadius\n@docs lecoFillColor\n@docs lecoOrient\n@docs lecoOffset\n@docs lecoStrokeColor\n@docs lecoStrokeDash\n@docs lecoStrokeWidth\n@docs lecoPadding\n@docs lecoGradientLabelBaseline\n@docs lecoGradientLabelLimit\n@docs lecoGradientLabelOffset\n@docs lecoGradientStrokeColor\n@docs lecoGradientStrokeWidth\n@docs lecoGradientHeight\n@docs lecoGradientWidth\n@docs lecoLabelAlign\n@docs lecoLabelBaseline\n@docs lecoLabelColor\n@docs lecoLabelFont\n@docs lecoLabelFontSize\n@docs lecoLabelLimit\n@docs lecoLabelOffset\n@docs lecoShortTimeLabels\n@docs lecoEntryPadding\n@docs lecoSymbolColor\n@docs lecoSymbolType\n@docs lecoSymbolSize\n@docs lecoSymbolStrokeWidth\n@docs lecoTitleAlign\n@docs lecoTitleBaseline\n@docs lecoTitleColor\n@docs lecoTitleFont\n@docs lecoTitleFontSize\n@docs lecoTitleFontWeight\n@docs lecoTitleLimit\n@docs lecoTitlePadding\n\n\n## Scale Configuration Options\n\nSee the\n[Vega-Lite scale configuration documentation](https://vega.github.io/vega-lite/docs/scale.html#scale-config)\n\n@docs sacoBandPaddingInner\n@docs sacoBandPaddingOuter\n@docs sacoClamp\n@docs sacoMaxBandSize\n@docs sacoMinBandSize\n@docs sacoMaxFontSize\n@docs sacoMinFontSize\n@docs sacoMaxOpacity\n@docs sacoMinOpacity\n@docs sacoMaxSize\n@docs sacoMinSize\n@docs sacoMaxStrokeWidth\n@docs sacoMinStrokeWidth\n@docs sacoPointPadding\n@docs sacoRangeStep\n@docs sacoRound\n@docs sacoTextXRangeStep\n@docs sacoUseUnaggregatedDomain\n\n\n## Scale Range Configuration Options\n\nSee the\n[Vega-Lite scheme configuration documentation](https://vega.github.io/vega/docs/schemes/#scheme-properties).\n\n@docs racoCategory\n@docs racoDiverging\n@docs racoHeatmap\n@docs racoOrdinal\n@docs racoRamp\n@docs racoSymbol\n\n\n## Title Configuration Options\n\nSee the\n[Vega-Lite title configuration documentation](https://vega.github.io/vega-lite/docs/title.html#config)\n\n@docs ticoAnchor\n@docs ticoAngle\n@docs ticoBaseline\n@docs ticoColor\n@docs ticoFont\n@docs ticoFontSize\n@docs ticoFontWeight\n@docs ticoLimit\n@docs ticoOffset\n@docs ticoOrient\n\n\n## View Configuration Options\n\nSee the\n[Vega-Lite view configuration documentation](https://vega.github.io/vega-lite/docs/spec.html#config)\n\n@docs vicoWidth\n@docs vicoHeight\n@docs vicoClip\n@docs vicoFill\n@docs vicoFillOpacity\n@docs vicoStroke\n@docs vicoStrokeOpacity\n@docs vicoStrokeWidth\n@docs vicoStrokeDash\n@docs vicoStrokeDashOffset\n\n@docs APosition\n\n@docs FieldTitleProperty\n\n\n# General Data functions\n\nIn addition to more general data types like integers and string, the following types\ncan carry data used in specifications.\n\n@docs boo\n@docs true\n@docs false\n@docs dt\n@docs num\n@docs str\n@docs boos\n@docs dts\n@docs nums\n@docs strs\n\n\n## Temporal Data\n\n@docs dtYear\n@docs dtQuarter\n@docs dtMonth\n@docs dtDate\n@docs dtDay\n@docs dtHour\n@docs dtMinute\n@docs dtSecond\n@docs dtMillisecond\n@docs MonthName\n@docs DayName\n\n@docs TimeUnit\n@docs utc\n\n---\n\n\n# Type Reference\n\nTypes that are not specified directly, porovided here for reference with links\nto the functions that generate them.\n\n@docs PositionChannel\n@docs MarkChannel\n@docs DetailChannel\n@docs FacetChannel\n@docs HyperlinkChannel\n@docs OrderChannel\n@docs TextChannel\n\n@docs Mark\n@docs MarkProperty\n\n@docs BooleanOp\n@docs Binding\n\n@docs AxisProperty\n@docs AxisConfig\n@docs BinProperty\n@docs ConfigurationProperty\n@docs InputProperty\n@docs HeaderProperty\n@docs LegendConfig\n@docs LegendProperty\n@docs LegendValues\n@docs ProjectionProperty\n@docs ScaleProperty\n@docs ScaleConfig\n@docs RangeConfig\n@docs SelectionMarkProperty\n@docs TitleConfig\n@docs ViewConfig\n\n@docs DataValue\n@docs DataValues\n@docs DateTime\n@docs Geometry\n\n@docs FacetMapping\n@docs RepeatFields\n@docs Filter\n@docs FilterRange\n\n@docs Resolve\n\n@docs Padding\n@docs ScaleRange\n\n@docs Window\n@docs WindowProperty\n@docs WindowSortField\n\n",
    "aliases": [
      {
        "name": "Data",
        "comment": " Convenience type annotation label for use with data generation functions.\n\n    myRegion : List DataColumn -> Data\n    myRegion =\n        dataFromColumns []\n            << dataColumn \"easting\" (nums [ -3, 4, 4, -3, -3 ])\n            << dataColumn \"northing\" (nums [ 52, 52, 45, 45, 52 ])\n\n",
        "args": [],
        "type": "( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "DataColumn",
        "comment": " A single column of data. Used when generating inline data with [dataColumn](#dataColumn).\n",
        "args": [],
        "type": "List VegaLite.LabelledSpec"
      },
      {
        "name": "DataRow",
        "comment": " A single row of data. Used when generating inline data with [dataRow](#dataRow).\n",
        "args": [],
        "type": "VegaLite.Spec"
      },
      {
        "name": "LabelledSpec",
        "comment": " A named Vega-Lite specification, usually generated by an elm-vega\nfunction. You shouldn't need to create `LabelledSpec` tuples directly, but are\nuseful for type annotations.\n",
        "args": [],
        "type": "( String, VegaLite.Spec )"
      },
      {
        "name": "Spec",
        "comment": " Part or all of Vega-Lite specification. Specs are usually nested\nand can range from a single Boolean value up to the entire Vega-Lite specification.\n",
        "args": [],
        "type": "Json.Encode.Value"
      }
    ],
    "types": [
      {
        "name": "APosition",
        "comment": " Anchor position for some text.\n",
        "args": [],
        "cases": [
          [
            "AStart",
            []
          ],
          [
            "AMiddle",
            []
          ],
          [
            "AEnd",
            []
          ]
        ]
      },
      {
        "name": "Arrangement",
        "comment": " Row or column arrangment in a repeated/faceted view.\n",
        "args": [],
        "cases": [
          [
            "Column",
            []
          ],
          [
            "Row",
            []
          ]
        ]
      },
      {
        "name": "Autosize",
        "comment": " The auto-sizing characteristics of a visualization such as amount of padding,\nwhether it should fill the parent container etc.\n",
        "args": [],
        "cases": [
          [
            "AContent",
            []
          ],
          [
            "AFit",
            []
          ],
          [
            "ANone",
            []
          ],
          [
            "APad",
            []
          ],
          [
            "APadding",
            []
          ],
          [
            "AResize",
            []
          ]
        ]
      },
      {
        "name": "AxisConfig",
        "comment": " Generated by [axcoBandPosition](#axcoBandPosition),\n[axcoDomain](#axcoDomain), [axcoDomainColor](#axcoDomainColor), [axcoDomainWidth](#axcoDomainWidth),\n[axcoMaxExtent](#axcoMaxExtent), [axcoMinExtent](#axcoMinExtent), [axcoGrid](#axcoGrid),\n[axcoGridColor](#axcoGridColor), [axcoGridDash](#axcoGridDash), [axcoGridOpacity](#axcoGridOpacity),\n[axcoGridWidth](#axcoGridWidth), [axcoLabels](#axcoLabels), [axcoLabelAngle](#axcoLabelAngle),\n[axcoLabelColor](#axcoLabelColor), [axcoLabelFont](#axcoLabelFont), [axcoLabelFontSize](#axcoLabelFontSize),\n[axcoLabelLimit](#axcoLabelLimit), [axcoLabelOverlap](#axcoLabelOverlap),\n[axcoLabelPadding](#axcoLabelPadding), [axcoShortTimeLabels](#axcoShortTimeLabels),\n[axcoTicks](#axcoTicks), [axcoTickColor](#axcoTickColor), [axcoTickRound](#axcoTickRound),\n[axcoTickSize](#axcoTickSize), [axcoTickWidth](#axcoTickWidth), [axcoTitleAlign](#axcoTitleAlign),\n[axcoTitleAngle](#axcoTitleAngle), [axcoTitleBaseline](#axcoTitleBaseline),\n[axcoTitleColor](#axcoTitleColor), [axcoTitleFont](#axcoTitleFont), [axcoTitleFontSize](#axcoTitleFontSize),\n[axcoTitleFontWeight](#axcoTitleFontWeight), [axcoTitleLimit](#axcoTitleLimit),\n[axcoTitleMaxLength](#axcoTitleMaxLength), [axcoTitlePadding](#axcoTitlePadding),\n[axcoTitleX](#axcoTitleX), [axcoTitleY](#axcoTitleY).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "AxisProperty",
        "comment": " Generated by [axDomain](#axDomain), [axFormat](#AxFormat), [axGrid](#axGrid),\n[axLabelAngle](#axLabelAngle), [axLabelOverlap](#axLabelOverlap), [axLabelPadding](#axLabelPadding),\n[axLabels](#axLabels), [axMaxExtent](#axMaxExtent), [axMinExtent](#axMinExtent),\n[axOffset](#axOffset), [axOrient](#axOrient), [axPosition](#axPosition), [axTicks](#axTicks),\n[axTickCount](#axTickCount), [axTickSize](#axTickSize), [axTitle](#axTitle),\n[AxTitleAlign](#axTitleAlign), [axTitleAngle](#axTitleAngle), [axTitleMaxLength](#axTitleMaxLength),\n[axTitlePadding](#axTitlePadding), [axValues](#axValues), [axDates](#axDates) and\n[axZIndex](#axZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "BinProperty",
        "comment": " Generated by [biBase](#biBase), [biDivide](#biDivide),\n[biExtent](#biExtent), [biMaxBins](#biMaxBins), [biMinStep](#biMinStep), [biNice](#biNice),\n[biStep](#biStep) and [biSteps](#biSteps).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Binding",
        "comment": " Generated by [iRange](#iRange), [iCheckbox](#iCheckbox),\n[iRadio](#iRadio), [iSelect](#iSelect), [iText](#iText), [iNumber](#iNumber),\n[iDate](#iDate), [iTime](#iTime), [iMonth](#iMonth), [iWeek](#iWeek), [iDateTimeLocal](#iDateTimeLocal),\n[iTel](#iTel) and [iColor](#iColor).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "BooleanOp",
        "comment": " Generated by [expr](#expr), [selected](#selected),\n[selectionName](#selectionName), [and](#and), [or](#or) and [not](#not).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Bounds",
        "comment": " The bounds calculation method to use for determining the extent of a sub-plot\nin a composed view.\n",
        "args": [],
        "cases": [
          [
            "Full",
            []
          ],
          [
            "Flush",
            []
          ]
        ]
      },
      {
        "name": "CInterpolate",
        "comment": " Type of color interpolation to apply when mapping a data field onto a color\nscale. Note that color interpolation cannot be applied with the default `sequential`\ncolor scale, so additionally, you should set the `sType` to another continuous scale\nsuch as `linear`, `pow` etc.\n\nOptions that require a `gamma` value (with 1 being a recommended default to provide)\nare generated by [cubeHelix](#cubeHelix), [cubeHelixLong](#cubeHelixLong) and [rgb](#rgb).\n\nFor details see the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/scale.html#continuous).\n\n",
        "args": [],
        "cases": [
          [
            "Hcl",
            []
          ],
          [
            "HclLong",
            []
          ],
          [
            "Hsl",
            []
          ],
          [
            "HslLong",
            []
          ],
          [
            "Lab",
            []
          ]
        ]
      },
      {
        "name": "Channel",
        "comment": " Channel type to be used in a resolution specification.\n",
        "args": [],
        "cases": [
          [
            "ChX",
            []
          ],
          [
            "ChY",
            []
          ],
          [
            "ChX2",
            []
          ],
          [
            "ChY2",
            []
          ],
          [
            "ChColor",
            []
          ],
          [
            "ChOpacity",
            []
          ],
          [
            "ChShape",
            []
          ],
          [
            "ChSize",
            []
          ]
        ]
      },
      {
        "name": "ClipRect",
        "comment": " Specify that no clipping is to be applied. To specify a clipping rectangle\ndimenstions, see [clipRect](#clipRect).\n",
        "args": [],
        "cases": [
          [
            "NoClip",
            []
          ]
        ]
      },
      {
        "name": "CompositionAlignment",
        "comment": " Alignment to apply to grid rows and columns generated by composition (faceting etc.).\n",
        "args": [],
        "cases": [
          [
            "CANone",
            []
          ],
          [
            "CAEach",
            []
          ],
          [
            "CAAll",
            []
          ]
        ]
      },
      {
        "name": "ConfigurationProperty",
        "comment": " Generated with [coArea](#coArea),\n[coAutosize](#coAutosize), [coAxis](#coAxis), [coAxisX](#coAxisX), [coAxisY](#coAxisY),\n[coAxisLeft](#coAxisLeft), [coAxisRight](#coAxisRight), [coAxisTop](#coAxisTop),\n[coAxisBottom](#coAxisBottom), [coAxisBand](#coAxisBand), [coBackground](#coBackground),\n[coBar](#coBar), [coCircle](#coCircle), [coCountTitle](#coCountTitle), [coFieldTitle](#coFieldTitle),\n[coGeoshape](#coGeoshape), [coLegend](#coLegend), [coLine](#coLine), [coMark](#coMark),\n[coNamedStyle](#coNamedStyle), [coNumberFormat](#coNumberFormat), [coPadding](#coPadding),\n[coPoint](#coPoint), [coProjection](#coProjection), [coRange](#coRange), [coRect](#coRect),\n[coRemoveInvalid](#coRemoveInvalid), [coRule](#coRule), [coScale](#coScale), [coSelection](#coSelection),\n[coSquare](#coSquare), [coStack](#coStack), [coText](#coText), [coTick](#coTick),\n[coTitle](#coTitle), [coTimeFormat](#coTimeFormat), [coTrail](#coTrail) and [coView](#coView).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Cursor",
        "comment": " Type of cursor to display. See the\n[CSS cursor documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)\n",
        "args": [],
        "cases": [
          [
            "CAuto",
            []
          ],
          [
            "CDefault",
            []
          ],
          [
            "CNone",
            []
          ],
          [
            "CContextMenu",
            []
          ],
          [
            "CHelp",
            []
          ],
          [
            "CPointer",
            []
          ],
          [
            "CProgress",
            []
          ],
          [
            "CWait",
            []
          ],
          [
            "CCell",
            []
          ],
          [
            "CCrosshair",
            []
          ],
          [
            "CText",
            []
          ],
          [
            "CVerticalText",
            []
          ],
          [
            "CAlias",
            []
          ],
          [
            "CCopy",
            []
          ],
          [
            "CMove",
            []
          ],
          [
            "CNoDrop",
            []
          ],
          [
            "CNotAllowed",
            []
          ],
          [
            "CAllScroll",
            []
          ],
          [
            "CColResize",
            []
          ],
          [
            "CRowResize",
            []
          ],
          [
            "CNResize",
            []
          ],
          [
            "CEResize",
            []
          ],
          [
            "CSResize",
            []
          ],
          [
            "CWResize",
            []
          ],
          [
            "CNEResize",
            []
          ],
          [
            "CNWResize",
            []
          ],
          [
            "CSEResize",
            []
          ],
          [
            "CSWResize",
            []
          ],
          [
            "CEWResize",
            []
          ],
          [
            "CNSResize",
            []
          ],
          [
            "CNESWResize",
            []
          ],
          [
            "CNWSEResize",
            []
          ],
          [
            "CZoomIn",
            []
          ],
          [
            "CZoomOut",
            []
          ],
          [
            "CGrab",
            []
          ],
          [
            "CGrabbing",
            []
          ]
        ]
      },
      {
        "name": "DataType",
        "comment": " Data type to be parsed when reading input data. To parse dates, see\n[foDate](#FoDate) and [foUtc](#foUtc).\n",
        "args": [],
        "cases": [
          [
            "FoNumber",
            []
          ],
          [
            "FoBoolean",
            []
          ]
        ]
      },
      {
        "name": "DataValue",
        "comment": " Generated by [boo](#boo), [true](#true), [false](#false), [dt](#dt),\n[num](#num) and [str](#str).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DataValues",
        "comment": " Generated by [boos](#boos), [dts](#dts), [nums](#nums) and [strs](#strs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DateTime",
        "comment": " Generated by [dtYear](#dtYear), [dtQuarter](#dtQuarter), [dtMonth](#dtMonth),\n[dtDate](#DTDate), [dtDay](#dtDay), [dtHour](#dtHour), [dtMinute](#dtMinute),\n[dtSecond](#dtSecond) and [dtMillisecond](#dtMillisecond).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DayName",
        "comment": " Day of the week.\n",
        "args": [],
        "cases": [
          [
            "Mon",
            []
          ],
          [
            "Tue",
            []
          ],
          [
            "Wed",
            []
          ],
          [
            "Thu",
            []
          ],
          [
            "Fri",
            []
          ],
          [
            "Sat",
            []
          ],
          [
            "Sun",
            []
          ]
        ]
      },
      {
        "name": "DetailChannel",
        "comment": " Generated by [dName](#dName), [dMType](#dMType), [dAggregate](#dAggregate),\n[DBin](#DBin) and [dTimeUnit](#dTimeUnit). For details see the\n[Vega-Lite level of detail channel documentation](https://vega.github.io/vega-lite/docs/encoding.html#detail)\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FacetChannel",
        "comment": " Generated by [fName](#fName), [fMType](#fMType), [fAggregate](#fAggregate),\n[fBin](#fBin), [fHeader](#fHeader) and [fTimeUnit](#fTimeUnit).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FacetMapping",
        "comment": " Generated by [columnBy](#columnBy) and [rowBy](#rowBy).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FieldTitleProperty",
        "comment": " Style in which field names are displayed. The `Verbal` style is 'Sum of field',\n'Year of date' etc. The `Function` style is 'SUM(field)', 'YEAR(date)' etc. The\n`Plain` style is just the field name without any additional text.\n",
        "args": [],
        "cases": [
          [
            "Verbal",
            []
          ],
          [
            "Function",
            []
          ],
          [
            "Plain",
            []
          ]
        ]
      },
      {
        "name": "Filter",
        "comment": " Generated by [fiEqual](#fiEqual), [fiLessThan](#fiLessThan),\n[fiLessThanEq](#fiLessThanEq), [fiGreaterThan](#fiEqGreaterThan),\n[fiGreaterThanEq](#fiGreaterThanEq), [fiExpr](#fiExpr), [fiCompose](#fiCompose),\n[fiSelection](#fiSelection), [fiOneOf](#fiOneOf) and [fiRange](#fiRange).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FilterRange",
        "comment": " Generated by [numRange](#numRange) and [dtRange](#dtRange).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FontWeight",
        "comment": " Weight options for a font.\n",
        "args": [],
        "cases": [
          [
            "Bold",
            []
          ],
          [
            "Bolder",
            []
          ],
          [
            "Lighter",
            []
          ],
          [
            "Normal",
            []
          ],
          [
            "W100",
            []
          ],
          [
            "W200",
            []
          ],
          [
            "W300",
            []
          ],
          [
            "W400",
            []
          ],
          [
            "W500",
            []
          ],
          [
            "W600",
            []
          ],
          [
            "W700",
            []
          ],
          [
            "W800",
            []
          ],
          [
            "W900",
            []
          ]
        ]
      },
      {
        "name": "Format",
        "comment": " Specify the type of format of a data file (only necessary if the file extension\ndoes not indicate the type, such as `.txt`). To read a file with a delimiter other\nthan comma or tab, use [dsv](#dsv). To customise the parsing of a file use\n[parse](#parse), [jsonProperty](#jsonProperty), [topojsonFeature](#topojsonFeature)\nor [topojsonMesh](#topojsonMesh).\n",
        "args": [],
        "cases": [
          [
            "CSV",
            []
          ],
          [
            "TSV",
            []
          ]
        ]
      },
      {
        "name": "Geometry",
        "comment": " Generated by [geoPoint](#geoPoint), [geoPoints](#geoPoints),\n[geoLine](#geoLine), [geoLines](#geoLines), [geoPolygon](#geoPolygon) and\n[geoPolygons](#geoPolygons).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "HAlign",
        "comment": " Horizontal alignment of some text such as on an axis or legend.\n",
        "args": [],
        "cases": [
          [
            "AlignCenter",
            []
          ],
          [
            "AlignLeft",
            []
          ],
          [
            "AlignRight",
            []
          ]
        ]
      },
      {
        "name": "HeaderProperty",
        "comment": " Generated by [hdFormat](#hdFormat),\n[hdLabelAngle](#hdLabelAngle), [hdLabelColor](#hdLabelColor), [hdLabelFont](#hdLabelFont),\n[hdLabelFontSize](#hdLabelFontSize), [hdLabelLimit](#hdLabelLimit), [hdTitle](#hdTitle),\n[hdTitleAnchor](#hdTitleAnchor), [hdTitleAngle](#hdTitleAngle), [hdTitleBaseline](#hdTitleBaseline),\n[hdTitleColor](#hdTitleColor), [hdTitleFont](#hdTitleFont), [hdTitleFontWeight](#hdTitleFontWeight),\n[hdTitleFontSize](#hdTitleFontSize) and [hdTitleLimit](#hdTitleLimit).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "HyperlinkChannel",
        "comment": " Generated by [hName](#hName), [hRepeat](#hRepeat), [hMType](#hMType), [HBin](#hBin),\n[hAggregate](#hAggregate), [hTimeUnit](#hTimeUnit), [hDataCondition](#hDataCondition),\n[hSelectionCondition](#hSelectionCondition) and [hStr](#hStr).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "InputProperty",
        "comment": " Generated by [inDebounce](#inDebounce), [inElement](#inElement),\n[inOptions](#inOptions), [inMin](#inMin), [inMax](#inMax), [inName](#inName),\n[inStep](#inStep) and [inPlaceholder](#inPlaceholder).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Legend",
        "comment": " Type of legend. Gradient legends are usually used for continuous quantitative\ndata while symbol legends used for categorical data.\n",
        "args": [],
        "cases": [
          [
            "Gradient",
            []
          ],
          [
            "Symbol",
            []
          ]
        ]
      },
      {
        "name": "LegendConfig",
        "comment": " Generated by [lecoCornerRadius](#lecoCornerRadius),\n[lecoFillColor](#lecoFillColor), [lecoOrient](#lecoOrient), [lecoOffset](#lecoOffset),\n[lecoStrokeColor](#lecoStrokeColor), [lecoStrokeDash](#lecoStrokeDash), [lecoStrokeWidth](#lecoStrokeWidth),\n[lecoPadding](#lecoPadding), [lecoGradientLabelBaseline](#lecoGradientLabelBaseline),\n[lecoGradientLabelLimit](#lecoGradientLabelLimit), [lecoGradientLabelOffset](#lecoGradientLabelOffset),\n[lecoGradientStrokeColor](#lecoGradientStrokeColor), [lecoGradientStrokeWidth](#lecoGradientStrokeWidth),\n[lecoGradientHeight](#lecoGradientHeight), [lecoGradientWidth](#lecoGradientWidth),\n[lecoLabelAlign](#lecoLabelAlign), [lecoLabelBaseline](#lecoLabelBaseline),\n[lecoLabelColor](#lecoLabelColor), [lecoLabelFont](#lecoLabelFont), [lecoLabelFontSize](#lecoLabelFontSize),\n[lecoLabelLimit](#lecoLabelLimit), [lecoLabelOffset](#lecoLabelOffset),\n[lecoShortTimeLabels](#lecoShortTimeLabels), [lecoEntryPadding](#lecoEntryPadding),\n[lecoSymbolColor](#lecoSymbolColor), [lecoSymbolType](#lecoSymbolType), [lecoSymbolSize](#lecoSymbolSize),\n[lecoSymbolStrokeWidth](#lecoSymbolStrokeWidth), [lecoTitleAlign](#lecoTitleAlign),\n[lecoTitleBaseline](#lecoTitleBaseline), [lecoTitleColor](#lecoTitleColor),\n[lecoTitleFont](#lecoTitleFont), [lecoTitleFontSize](#lecoTitleFontSize),\n[lecoTitleFontWeight](#lecoTitleFontWeight), [lecoTitleLimit](#lecoTitleLimit)\nand [lecoTitlePadding](#lecoTitlePadding).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendOrientation",
        "comment": " Legend position relative to data rectangle.\nfor more details.\n",
        "args": [],
        "cases": [
          [
            "BottomLeft",
            []
          ],
          [
            "BottomRight",
            []
          ],
          [
            "Left",
            []
          ],
          [
            "None",
            []
          ],
          [
            "Right",
            []
          ],
          [
            "TopLeft",
            []
          ],
          [
            "TopRight",
            []
          ]
        ]
      },
      {
        "name": "LegendProperty",
        "comment": " Generated by [leFormat](#leFormat), [leOffset](#LeOffset), [leOrient](#leOrient),\n[lePadding](#lePadding), [leTickCount](#leTickCount), [leTitle](#leTitle),\n[leType](#leType), [leValues](#leValues) and [leZIndex](#leZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendValues",
        "comment": " Generated by [leNums](#leNums), [leStrs](#leStrs) and [leDts](#leDts).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LineMarker",
        "comment": " Specify the appearance of a line marker that is overlaid on to an area mark.\nAlso generated by [lmLine](#lmLine).\n",
        "args": [],
        "cases": [
          [
            "LMNone",
            []
          ]
        ]
      },
      {
        "name": "Mark",
        "comment": " Generated by\n[area](#area), [bar](#bar), [boxplot](#boxplot), [circle](#circle), [errorband](#errorband),\n[errorbar](#errorbar), [geoshape](#geoshape), [line](#line), [point](#point), [rect](#rect),\n[rule](#rule),[square](#square), [textMark](#textMark), [tick](#tick) and [trail](#trail).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "MarkChannel",
        "comment": " Generated by [mName](#mName), [mRepeat](#mRepeat), [mMType](#mMType), [mScale](#mScale),\n[mBin](#MBin), [mTimeUnit](#mTimeUnit), [mTitle](#mTitle), [mAggregate](#mAggregate),\n[mLegend](#mLegend), [mSelectionCondition](#mSelectionCondition),\n[mDataCondition](#mDataCondition), [mPath](#mPath), [mNum](#mNum), [mStr](#mStr)\nand [mBoo](#mBoo).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "MarkInterpolation",
        "comment": " Mark interpolation style.\n",
        "args": [],
        "cases": [
          [
            "Basis",
            []
          ],
          [
            "BasisClosed",
            []
          ],
          [
            "BasisOpen",
            []
          ],
          [
            "Bundle",
            []
          ],
          [
            "Cardinal",
            []
          ],
          [
            "CardinalClosed",
            []
          ],
          [
            "CardinalOpen",
            []
          ],
          [
            "Linear",
            []
          ],
          [
            "LinearClosed",
            []
          ],
          [
            "Monotone",
            []
          ],
          [
            "StepAfter",
            []
          ],
          [
            "StepBefore",
            []
          ],
          [
            "Stepwise",
            []
          ]
        ]
      },
      {
        "name": "MarkOrientation",
        "comment": " Desired orientation of a mark (e.g. horizontally or vertically oriented bars.)\n",
        "args": [],
        "cases": [
          [
            "Horizontal",
            []
          ],
          [
            "Vertical",
            []
          ]
        ]
      },
      {
        "name": "MarkProperty",
        "comment": " Generated by [maAlign](#maAlign), [maAngle](#maAngle), [maBandSize](#maBandSize),\n[maBaseline](#maBaseline), [maBinSpacing](#maBinSpacing), [maBorders](#maBorders),\n[maClip](#maClip), [maColor](#maColor), [maCursor](#maCursor), [maHRef](#maHRef),\n[maContinuousBandSize](#maContinuousBandSize), [maDiscreteBandSize](#maDiscreteBandSize),\n[maDx](#maDx), [maDy](#maDy), [maExtent](#maExtent), [maFill](#maFill), [maFilled](#maFilled),\n[maFillOpacity](#maFillOpacity), [maFont](#maFont), [maFontSize](#maFontSize),\n[maFontStyle](#maFontStyle), [maFontWeight](#maFontWeight), [maInterpolate](#maInterpolate),\n[maLine](#maLine), [maOpacity](#maOpacity), [maOrient](#maOrient), [maPoint](#maPoint),\n[maRadius](#maRadius), [maRule](#maRule), [maShape](#maShape), [maShortTimeLabels](#maShortTimeLabels),\n[maSize](#maSize), [maStroke](#maStroke), [maStrokeCap](#maStrokeCap), [maStrokeDash](#maStrokeDash),\n[maStrokeDashOffset](#maStrokeDashOffset), [maStrokeJoin](#maStrokeJoin),\n[maStrokeMiterLimit](#maStrokeMiterLimit), [maStrokeOpacity](#maStrokeOpacity),\n[maStrokeWidth](#maStrokeWidth), [maStyle](#maStyle), [maTension](#maTension),\n[maText](#maText), [maTheta](#maTheta), [maThickness](#maThickness), [maTicks](#maTicks),\n[maXOffset](#maXOffset), [maYOffset](#maYOffset), [maX2Offset](#maX2Offset) and\n[maY2Offset](#maY2Offset).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Measurement",
        "comment": " Type of measurement to be associated with some channel. `Nominal` data are\nunordered categories identified by name alone. `Ordinal` data are ordered categories\n`Quantitative` data are numeric measurements typically on a continuous scale.\n\nGeospatial position encoding (`Longitude` and `Latitude`) should specify the `pMType`\nas `Quantitative`. Geographically referenced features encoded as `shape` marks\nshould specify `mMType` as `GeoFeature`.\n\n",
        "args": [],
        "cases": [
          [
            "Nominal",
            []
          ],
          [
            "Ordinal",
            []
          ],
          [
            "Quantitative",
            []
          ],
          [
            "Temporal",
            []
          ],
          [
            "GeoFeature",
            []
          ]
        ]
      },
      {
        "name": "MonthName",
        "comment": " Idntifies a month of the year.\n",
        "args": [],
        "cases": [
          [
            "Jan",
            []
          ],
          [
            "Feb",
            []
          ],
          [
            "Mar",
            []
          ],
          [
            "Apr",
            []
          ],
          [
            "May",
            []
          ],
          [
            "Jun",
            []
          ],
          [
            "Jul",
            []
          ],
          [
            "Aug",
            []
          ],
          [
            "Sep",
            []
          ],
          [
            "Oct",
            []
          ],
          [
            "Nov",
            []
          ],
          [
            "Dec",
            []
          ]
        ]
      },
      {
        "name": "Operation",
        "comment": " Type of aggregation operation. See the\n",
        "args": [],
        "cases": [
          [
            "ArgMax",
            []
          ],
          [
            "ArgMin",
            []
          ],
          [
            "Average",
            []
          ],
          [
            "CI0",
            []
          ],
          [
            "CI1",
            []
          ],
          [
            "Count",
            []
          ],
          [
            "Distinct",
            []
          ],
          [
            "Max",
            []
          ],
          [
            "Mean",
            []
          ],
          [
            "Median",
            []
          ],
          [
            "Min",
            []
          ],
          [
            "Missing",
            []
          ],
          [
            "Q1",
            []
          ],
          [
            "Q3",
            []
          ],
          [
            "Stderr",
            []
          ],
          [
            "Stdev",
            []
          ],
          [
            "StdevP",
            []
          ],
          [
            "Sum",
            []
          ],
          [
            "Valid",
            []
          ],
          [
            "Variance",
            []
          ],
          [
            "VarianceP",
            []
          ]
        ]
      },
      {
        "name": "OrderChannel",
        "comment": " Generated by [OName](#oName), [oRepeat](#oRepeat), [oMType](#oMType), [oBin](#oBin),\n[oAggregate](#oAggregate), [oTimeUnit](#oTimeUnit) and [oSort](#oSort).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "OverlapStrategy",
        "comment": " Type of overlap strategy to be applied when there is not space to show all items\non an axis. See the\n",
        "args": [],
        "cases": [
          [
            "ONone",
            []
          ],
          [
            "OParity",
            []
          ],
          [
            "OGreedy",
            []
          ]
        ]
      },
      {
        "name": "Padding",
        "comment": " Generated by [paSize](#paSize) and [paEdges](#paEdges).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PointMarker",
        "comment": " Specify the appearance of a point marker that is overlaid on a line or area\nmark. Also generated by [pmMarker](#pmMarker).\n",
        "args": [],
        "cases": [
          [
            "PMTransparent",
            []
          ],
          [
            "PMNone",
            []
          ]
        ]
      },
      {
        "name": "Position",
        "comment": " Type of position channel, `X` and `Y` represent horizontal and vertical axis\ndimensions on a plane and `X2` and `Y2` represent secondary axis dimensions where\ntwo scales are overlaid in the same space. Geographic positions represented by\nlongitude and latitude values are identified with `Longitude`, `Latitude` and\ntheir respective secondary equivalents. Such geographic position channels are\nsubject to a map projection before being placed graphically.\n",
        "args": [],
        "cases": [
          [
            "X",
            []
          ],
          [
            "Y",
            []
          ],
          [
            "X2",
            []
          ],
          [
            "Y2",
            []
          ],
          [
            "Longitude",
            []
          ],
          [
            "Latitude",
            []
          ],
          [
            "Longitude2",
            []
          ],
          [
            "Latitude2",
            []
          ]
        ]
      },
      {
        "name": "PositionChannel",
        "comment": " Generated by [pName](#pName), [pRepeat](#pRepeat), [pMType](#pMType), [pBin](#PBin),\n[pTimeUnit](#pTimeUnit), [pTitle](#pTitle), [pAggregate](#pAggregate),\n[pScale](#pScale), [pAxis](#pAxis), [pSort](#pSort), [pStack](#pStack), [pWidth](#pWidth)\nand [pHeight](#pHeight).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Projection",
        "comment": " Types of geographic map projection. These are based on a subset of those provided\nby the [d3-geo library](https://github.com/d3/d3-geo). To generate a custom projection\nuse [customProjection](#customProjection).\n",
        "args": [],
        "cases": [
          [
            "Albers",
            []
          ],
          [
            "AlbersUsa",
            []
          ],
          [
            "AzimuthalEqualArea",
            []
          ],
          [
            "AzimuthalEquidistant",
            []
          ],
          [
            "ConicConformal",
            []
          ],
          [
            "ConicEqualArea",
            []
          ],
          [
            "ConicEquidistant",
            []
          ],
          [
            "Equirectangular",
            []
          ],
          [
            "Gnomonic",
            []
          ],
          [
            "Mercator",
            []
          ],
          [
            "Orthographic",
            []
          ],
          [
            "Stereographic",
            []
          ],
          [
            "TransverseMercator",
            []
          ]
        ]
      },
      {
        "name": "ProjectionProperty",
        "comment": " Generated by\n[prType](#prType), [prClipAngle](#prClipAngle), [prClipExtent](#prClipExtent),\n[prCenter](#prCenter), [prRotate](#prRotate), [prPrecision](#prPrecision),\n[prCoefficient](#prCoefficient), [prDistance](#prDistance), [prFraction](#prFraction),\n[prLobes](#prLobes), [prParallel](#prParallel), [prRadius](#prRadius), [prRatio](#prRatio),\n[prSpacing](#prSpacing) and [prTilt](#prTilt).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RangeConfig",
        "comment": " Generated by [racoCategory](#racoCategory),\n[racoDiverging](#racoDiverging), [racoHeatmap](#racoHeatmap), [racoOrdinal](#racoOrdinal),\n[racoRamp](#racoRamp) and [racoSymbol](#racoSymbol).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RepeatFields",
        "comment": " Generated by [rowFields](#rowFields) and [columnFields](#columnFields).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Resolution",
        "comment": " Indicated whether or not a scale domain should be independent of others in a\ncomposite visualization. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/resolve.html) for\ndetails.\n",
        "args": [],
        "cases": [
          [
            "Shared",
            []
          ],
          [
            "Independent",
            []
          ]
        ]
      },
      {
        "name": "Resolve",
        "comment": " Generated by [reAxis](#reAxis), [reLegend](#reLegend) and [reScale](#reScale).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Scale",
        "comment": " Used to indicate the type of scale transformation to apply.\n",
        "args": [],
        "cases": [
          [
            "ScLinear",
            []
          ],
          [
            "ScPow",
            []
          ],
          [
            "ScSqrt",
            []
          ],
          [
            "ScLog",
            []
          ],
          [
            "ScTime",
            []
          ],
          [
            "ScUtc",
            []
          ],
          [
            "ScSequential",
            []
          ],
          [
            "ScOrdinal",
            []
          ],
          [
            "ScBand",
            []
          ],
          [
            "ScPoint",
            []
          ],
          [
            "ScBinLinear",
            []
          ],
          [
            "ScBinOrdinal",
            []
          ]
        ]
      },
      {
        "name": "ScaleConfig",
        "comment": " Generated by [sacoBandPaddingInner](#sacoBandPaddingInner), [sacoBandPaddingOuter](#sacoBandPaddingOuter),\n[sacoClamp](#sacoClamp), [sacoMaxBandSize](#sacoMaxBandSize), [sacoMinBandSize](#sacoMinBandSize),\n[sacoMaxFontSize](#sacoMaxFontSize), [sacoMinFontSize](#sacoMinFontSize), [sacoMaxOpacity](#sacoMaxOpacity),\n[sacoMinOpacity](#sacoMinOpacity), [sacoMaxSize](#sacoMaxSize), [sacoMinSize](#sacoMinSize),\n[sacoMaxStrokeWidth](#sacoMaxStrokeWidth), [sacoMinStrokeWidth](#sacoMinStrokeWidth),\n[sacoPointPadding](#sacoPointPadding), [sacoRangeStep](#sacoRangeStep), [sacoRound](#sacoRound),\n[sacoTextXRangeStep](#sacoTextXRangeStep) and [sacoUseUnaggregatedDomain](#sacoUseUnaggregatedDomain).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleDomain",
        "comment": " Describes a scale domain (type of data in scale). To specify scale domain\nvalues explicitly, use the functions [doNums](#doNums), [doStrs](#doStrs),\n[doDts](#doDts) or [doSelection](#doSelection).\n",
        "args": [],
        "cases": [
          [
            "Unaggregated",
            []
          ]
        ]
      },
      {
        "name": "ScaleNice",
        "comment": " Describes the way a scale can be rounded to 'nice' numbers. To specify nice\ntime intervals use [scNiceInterval](#scNiceInterval) and to set a nice tick count\nuse [scNiceTickCount](#scNiceTickCount).\n",
        "args": [],
        "cases": [
          [
            "NMillisecond",
            []
          ],
          [
            "NSecond",
            []
          ],
          [
            "NMinute",
            []
          ],
          [
            "NHour",
            []
          ],
          [
            "NDay",
            []
          ],
          [
            "NWeek",
            []
          ],
          [
            "NMonth",
            []
          ],
          [
            "NYear",
            []
          ],
          [
            "NTrue",
            []
          ],
          [
            "NFalse",
            []
          ]
        ]
      },
      {
        "name": "ScaleProperty",
        "comment": " Generated by [scType](#scType), [scDomain](#scDomain), [scRange](#scRange),\n[scScheme](#scScheme), [scPadding](#scPadding), [scPaddingInner](#scPaddingInner),\n[scPaddingOuter](#scPaddingOuter), [scRangeStep](#scRangeStep), [scRound](#scRound),\n[scClamp](#scClamp), [scInterpolate](#scInterpolate), [scNice](#scNice), [scZero](#scZero)\nand [scReverse](#scReverse).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleRange",
        "comment": " Generated by [raNums](#raNums), [raStrs](#raStrs) and [raName](#raName).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Selection",
        "comment": " Type of selection to be generated by the user. `Single` allows\none mark at a time to be selected. 'Multi' allows multiple items to be selected\n(e.g. with shift-click). 'Interval' allows a bounding rectangle to be dragged by\nuser to select all items intersecting with it.\n",
        "args": [],
        "cases": [
          [
            "Single",
            []
          ],
          [
            "Multi",
            []
          ],
          [
            "Interval",
            []
          ]
        ]
      },
      {
        "name": "SelectionMarkProperty",
        "comment": " Generated by [smFill](#smFill), [smFillOpacity](#smFillOpacity), [smStroke](#smStroke),\n[smStrokeDash](#smStrokeDash), [smStrokeDashOffset](#smStrokeDashOffset),\n[smStrokeOpacity](#smStrokeOpacity) and [smStrokeWidth](#smStrokeWidth).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "SelectionProperty",
        "comment": " Properties for customising the nature of an interactive selection. Parameterised\nproperties generated by [seBind](#seBind), [seEncodings](#seEncodings), [seFields](#seFields),\n[seNearest](#seNearest), [seOn](#seOn), [seResolve](#seResolve), [seSelectionMark](#seSelectionMark),\n[seToggle](#seToggle), [seTranslate](#seTranslate) and [seZoom](#seZoom).\n",
        "args": [],
        "cases": [
          [
            "Empty",
            []
          ],
          [
            "BindScales",
            []
          ]
        ]
      },
      {
        "name": "SelectionResolution",
        "comment": " Determines how selections in faceted or repeated views are resolved. See the\n[Vege-Lite documentation](https://vega.github.io/vega-lite/docs/selection.html#resolve)\nfor details\n",
        "args": [],
        "cases": [
          [
            "Global",
            []
          ],
          [
            "Union",
            []
          ],
          [
            "Intersection",
            []
          ]
        ]
      },
      {
        "name": "Side",
        "comment": " One side of a rectangular space.\n",
        "args": [],
        "cases": [
          [
            "STop",
            []
          ],
          [
            "SBottom",
            []
          ],
          [
            "SLeft",
            []
          ],
          [
            "SRight",
            []
          ]
        ]
      },
      {
        "name": "SortProperty",
        "comment": " Allow type of sorting to be customised. To sort a field by the aggregated\nvalues of another use [soByField](#soByField) or [soByRepeat](#soByRepeat). Custom\nsorting by explicit values can be provided by [soCustom](#soCustom).\n",
        "args": [],
        "cases": [
          [
            "Ascending",
            []
          ],
          [
            "Descending",
            []
          ]
        ]
      },
      {
        "name": "StackProperty",
        "comment": " Describes the type of stacking to apply to a bar chart.\n",
        "args": [],
        "cases": [
          [
            "StZero",
            []
          ],
          [
            "StNormalize",
            []
          ],
          [
            "StCenter",
            []
          ],
          [
            "NoStack",
            []
          ]
        ]
      },
      {
        "name": "StrokeCap",
        "comment": " Type of stroke cap.\n",
        "args": [],
        "cases": [
          [
            "CButt",
            []
          ],
          [
            "CRound",
            []
          ],
          [
            "CSquare",
            []
          ]
        ]
      },
      {
        "name": "StrokeJoin",
        "comment": " Type of stroke join.\n",
        "args": [],
        "cases": [
          [
            "JMiter",
            []
          ],
          [
            "JRound",
            []
          ],
          [
            "JBevel",
            []
          ]
        ]
      },
      {
        "name": "SummaryExtent",
        "comment": " Type of extent summary of a statistical distribution. Additionally generated\nby [iqrScale](#iqrScale).\n",
        "args": [],
        "cases": [
          [
            "ExCI",
            []
          ],
          [
            "ExStderr",
            []
          ],
          [
            "ExStdev",
            []
          ],
          [
            "ExIqr",
            []
          ],
          [
            "ExRange",
            []
          ]
        ]
      },
      {
        "name": "Symbol",
        "comment": " Type of symbol. To create a user defined path for a symbol use\n[symPath](#symPath).\n",
        "args": [],
        "cases": [
          [
            "SymCircle",
            []
          ],
          [
            "SymSquare",
            []
          ],
          [
            "Cross",
            []
          ],
          [
            "Diamond",
            []
          ],
          [
            "TriangleUp",
            []
          ],
          [
            "TriangleDown",
            []
          ]
        ]
      },
      {
        "name": "TextChannel",
        "comment": " Generated by [tName](#tName), [tRepeat](#tRepeat), [tMType](#tMType),\n[tBin](#tBin), [tAggregate](#tAggregate), [tTimeUnit](#tTimeUnit),[tTitle](#tTitle),\n[tSelectionCondition](#tSelectionCondition), [tDataCondition](#tDataCondition)\nand [tFormat](#tFormat).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TimeUnit",
        "comment": " Describes a unit of time. Useful for encoding and transformations. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/timeunit.html)\nfor further details.\n\nTo encode a time as UTC (coordinated universal time, independent of local time\nzones or daylight saving), provide a time unit to the `utc` function.\nFor example,\n\n    encoding\n        << position X [ pName \"date\", pMType Temporal, pTimeUnit (utc YearMonthDateHours) ]\n\n",
        "args": [],
        "cases": [
          [
            "Year",
            []
          ],
          [
            "YearQuarter",
            []
          ],
          [
            "YearQuarterMonth",
            []
          ],
          [
            "YearMonth",
            []
          ],
          [
            "YearMonthDate",
            []
          ],
          [
            "YearMonthDateHours",
            []
          ],
          [
            "YearMonthDateHoursMinutes",
            []
          ],
          [
            "YearMonthDateHoursMinutesSeconds",
            []
          ],
          [
            "Quarter",
            []
          ],
          [
            "QuarterMonth",
            []
          ],
          [
            "Month",
            []
          ],
          [
            "MonthDate",
            []
          ],
          [
            "Date",
            []
          ],
          [
            "Day",
            []
          ],
          [
            "Hours",
            []
          ],
          [
            "HoursMinutes",
            []
          ],
          [
            "HoursMinutesSeconds",
            []
          ],
          [
            "Minutes",
            []
          ],
          [
            "MinutesSeconds",
            []
          ],
          [
            "Seconds",
            []
          ],
          [
            "SecondsMilliseconds",
            []
          ],
          [
            "Milliseconds",
            []
          ]
        ]
      },
      {
        "name": "TitleConfig",
        "comment": " Generated by [ticoAnchor](#ticoAnchor),\n[ticoAngle](#ticoAngle), [ticoBaseline](#ticoBaseline), [ticoColor](#ticoColor),\n[ticoFont](#ticoFont), [ticoFontSize](#ticoFontSize), [ticoFontWeight](#ticoFontWeight),\n[ticoLimit](#ticoLimit), [ticoOffset](#ticoOffset) and [ticoOrient](#ticoOrient).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "VAlign",
        "comment": " Vertical alignment of some text that may be attached to a mark.\n",
        "args": [],
        "cases": [
          [
            "AlignTop",
            []
          ],
          [
            "AlignMiddle",
            []
          ],
          [
            "AlignBottom",
            []
          ]
        ]
      },
      {
        "name": "VLProperty",
        "comment": " Top-level Vega-Lite properties. These are the ones that define the core of the\nvisualization grammar. All `VLProperties` are created by functions in seven broad groups.\n\n**Data properties** relate to the input data to be visualized. Generated by\n[`dataFromColumns`](#dataFromColumns), [`dataFromRows`](#dataFromRows),\n[`dataFromUrl`](#dataFromUrl), [`dataFromSource`](#dataFromSource) and\n[`dataFromJson`](#dataFromJson).\n\n**Transform properties** indicate that some transformation of input data should\nbe applied before encoding them visually. Generated by [`transform`](#transform)\nand [`projection`](#projection) they can include data transformations such as\n[filter](#filter), [binAs](#binAs) and [calculateAs](#calculateAs) and geo\ntransformations of longitude, latitude coordinates used by marks such as those\ngenerated by [geoshape](#geoshape), [point](#point) and [line](#line).\n\n**Mark functions** specify the symbols used to visualize data items. Generated\nby functions such as [`circle`](#circle), [`bar`](#bar) and [`line`](#line).\n\n**Encoding properties** specify which data elements are mapped to which mark\ncharacteristics (known as _channels_). Generated by [`encoding`](#encoding) they\ninclude encodings such as `position`, `color`, `size`, `shape` `text` and `hyperlink`.\n\n**Composition properties** allow visualization views to be combined to form more\ncomplex visualizations. Generated by [`layer`](#layer), [`repeat`](#repeat),\n[`facet`](#facet), [`hConcat`](#hConcat), [`vConcat`](#vConcat), [`spec`](#spec)\nand [`resolve`](#resolve).\n\n**Interaction properties** allow clicking, dragging and other interactions generated\nvia a GUI or data stream to influence the visualization. Generated by\n[`selection`](#selection).\n\n**Supplementary and configuration properties** provide a means to add metadata and\nstyling to one or more visualizations. Generated by [`name`](#name), [`title`](#title),\n[`description`](#description), [`background`](#background), [`width`](#width),\n[`height`](#height), [`padding`](#padding), [`autosize`](#autosize) and\n[`configure`](#configure).\n\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ViewConfig",
        "comment": " Generated by [vicoWidth](#vicoWidth), [vicoHeight](#vicoHeight), [vicoClip](#vicoClip),\n[vicoFill](#vicoFill), [vicoFillOpacity](#vicoFillOpacity), [vicoStroke](#vicoStroke),\n[vicoStrokeOpacity](#vicoStrokeOpacity), [vicoStrokeWidth](#vicoStrokeWidth),\n[vicoStrokeDash](#vicoStrokeDash) and [vicoStrokeDashOffset](#vicoStrokeDashOffset).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Window",
        "comment": " Generated by [wiAggregateOp](#wiAggregateOp), [wiOp](#wiOp), [wiParam](#wiParam)\nand [wiField](#wiField).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WindowOperation",
        "comment": " Operations that may be applied during a window transformation.\n",
        "args": [],
        "cases": [
          [
            "RowNumber",
            []
          ],
          [
            "Rank",
            []
          ],
          [
            "DenseRank",
            []
          ],
          [
            "PercentRank",
            []
          ],
          [
            "CumeDist",
            []
          ],
          [
            "Ntile",
            []
          ],
          [
            "Lag",
            []
          ],
          [
            "Lead",
            []
          ],
          [
            "FirstValue",
            []
          ],
          [
            "LastValue",
            []
          ],
          [
            "NthValue",
            []
          ]
        ]
      },
      {
        "name": "WindowProperty",
        "comment": " Generated by [wiFrame](#wiFrame), [wiIgnorePeers](#wiIgnorePeers), [wiGroupBy](#wiGroupBy)\nand [wiSort](#wiSort).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WindowSortField",
        "comment": " Generated by [wiAscending](#wiAscending) and [wiDescending](#wiDescending).\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "aggregate",
        "comment": " Specify a set of named aggregation transformations to be used when encoding\nchannels. Useful when, for example, you wish to apply the same transformation\nto a number of channels but do not want to define it each time. The first parameter is\na list of the named aggregation operations to apply. The second is a list of\n'group by' fields. The third is the list of transformations to which this is to\nbe added.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs Min \"people\" \"lowerBound\", opAs Max \"people\" \"upperBound\" ]\n                [ \"age\" ]\n\n",
        "type": "List VegaLite.Spec -> List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "align",
        "comment": " Specify the alignment to apply to grid rows and columns generated by a composition\noperator. This version sets the same alignment for rows and columns.\n",
        "type": "VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "alignRC",
        "comment": " Similar to [align](#align) but with independent alignments for rows (first\nparameter) and columns (second parameter).\n",
        "type": "VegaLite.CompositionAlignment -> VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "and",
        "comment": " Apply an 'and' Boolean operation as part of a logical composition.\n\n    and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\")\n\n",
        "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"
      },
      {
        "name": "area",
        "comment": " Specify an [area mark](https://vega.github.io/vega-lite/docs/area.html) for\nrepresenting a series of data elements, such as in a stacked area chart or streamgraph.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "asSpec",
        "comment": " Create a specification sufficient to define an element in a composed visualization\nsuch as a superposed layer or juxtaposed facet. Typically a layer will contain a\nfull set of specifications that define a visualization with the exception of the\ndata specification which is usually defined outside of any one\nlayer. For repeated and faceted specs, the entire specification is provided.\n",
        "type": "List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"
      },
      {
        "name": "autosize",
        "comment": " Declare the way the view is sized. See the\n[Vega-Lite autosize documentation](https://vega.github.io/vega-lite/docs/size.html#autosize).\n\n    enc = ...\n    toVegaLite\n        [ width 250\n        , height 300\n        , autosize [ AFit, APadding, AResize ]\n        , dataFromUrl \"data/population.json\" []\n        , bar []\n        , enc []\n        ]\n\n",
        "type": "List VegaLite.Autosize -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "axDates",
        "comment": " Specify the date/times to appear along an axis.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.AxisProperty"
      },
      {
        "name": "axDomain",
        "comment": " Specify whether or not the axis baseline (domain) should be included as part\nof an axis.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axFormat",
        "comment": " Specify the [format](https://vega.github.io/vega-lite/docs/format.html)\nto apply to labels on an axis.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axGrid",
        "comment": " Specify whether or not grid lones should be included as part of an axis.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelAngle",
        "comment": " Specify the rotation angle in degrees of axis labels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelOverlap",
        "comment": " Specify the overlap strategy for labels when they are too large to fit within\nthe space devoted to an axis.\n",
        "type": "VegaLite.OverlapStrategy -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelPadding",
        "comment": " Specify the padding in pixels between an axis and its text labels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabels",
        "comment": " Specify whether or not axis labels should be displayed.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axMaxExtent",
        "comment": " Specify the maximum extent in pixels that axis ticks and labels should use.\nThis determines a maximum offset value for axis titles.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axMinExtent",
        "comment": " Specify the minimum extent in pixels that axis ticks and labels should use.\nThis determines a minimum offset value for axis titles.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axOffset",
        "comment": " Specify the offset, in pixels, by which to displace the axis from the edge\nof the enclosing group or data rectangle.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axOrient",
        "comment": " Specify the orientation of an axis relative to the plot it is describing.\n",
        "type": "VegaLite.Side -> VegaLite.AxisProperty"
      },
      {
        "name": "axPosition",
        "comment": " Specify the anchor position of the axis in pixels. For x-axis with top or\nbottom orientation, this sets the axis group x coordinate. For y-axis with left\nor right orientation, this sets the axis group y coordinate.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickCount",
        "comment": " Specify the desired number of ticks, for axes visualizing quantitative scales.\nThe resulting number may be different so that values are âniceâ (multiples of 2, 5, 10)\nand lie within the underlying scaleâs range.\n",
        "type": "Int -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickSize",
        "comment": " Specify the tick mark size in pixels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTicks",
        "comment": " Specify whether or not an axis should include tick marks.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitle",
        "comment": " Specify the title to display as part of an axis. An empty string can be used\nto prevent a title being displayed.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleAlign",
        "comment": " Specify the horizontal alignment of an axis title.\n",
        "type": "VegaLite.HAlign -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleAngle",
        "comment": " Specify the angle in degrees of an axis title.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleMaxLength",
        "comment": " Specify the maximum length for an axis title for cases where the title is\nautomatically generated from a fieldâs description.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitlePadding",
        "comment": " Specify the padding in pixels between a title and axis.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axValues",
        "comment": " Specify the numeric values to appear along an axis.\n",
        "type": "List Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axZIndex",
        "comment": " Specify the drawing order of the axis relative to the other chart elements.\nA value of 1 indicates axis is drawn in front of chart marks, 0 indicates it is\ndrawn behind them.\n",
        "type": "Int -> VegaLite.AxisProperty"
      },
      {
        "name": "axcoBandPosition",
        "comment": " Specify a default axis band position.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoDomain",
        "comment": " Specify whether or not an axis domain should be displayed by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoDomainColor",
        "comment": " Specify a default axis domain color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoDomainWidth",
        "comment": " Specify a default axis domain width style.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGrid",
        "comment": " Specify whether or not an axis grid is displayed by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridColor",
        "comment": " Specify a default axis grid color style.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridDash",
        "comment": " Specify a default axis line dash style.\n",
        "type": "List Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridOpacity",
        "comment": " Specify a default axis grid line opacity.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridWidth",
        "comment": " Specify a default axis grid line width.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelAngle",
        "comment": " Specify a default axis label angle.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelColor",
        "comment": " Specify a default axis label color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelFont",
        "comment": " Specify a default axis label font.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelFontSize",
        "comment": " Specify a default axis label font size.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelLimit",
        "comment": " Specify a default axis label limit (how much a label can extend beyond the\nleft/bottom or right/top of the axis line).\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelOverlap",
        "comment": " Specify a default axis label overlap strategy for cases where labels cannot\nfit within the allotted space.\n",
        "type": "VegaLite.OverlapStrategy -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelPadding",
        "comment": " Specify a default axis label padding (space between labels in pixels).\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabels",
        "comment": " Specify whether or not an axis has labels by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoMaxExtent",
        "comment": " Specify a default maximum extent style.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoMinExtent",
        "comment": " Specify a default minimum extent style.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoShortTimeLabels",
        "comment": " Specify whether or not an axis should use short time labels by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickColor",
        "comment": " Specify a default axis tick mark color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickRound",
        "comment": " Specify whether or not axis tick labels use rounded values by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickSize",
        "comment": " Specify a default axis tick mark size in pixel units.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickWidth",
        "comment": " Specify a default axis tick mark width in pixel units.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTicks",
        "comment": " Specify whether or not an axis should show ticks by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleAlign",
        "comment": " Specify a default axis tick label horizontal alignment.\n",
        "type": "VegaLite.HAlign -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleAngle",
        "comment": " Specify a default axis title angle.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleBaseline",
        "comment": " Specify a default axis title vertical alignment.\n",
        "type": "VegaLite.VAlign -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleColor",
        "comment": " Specify a default axis title color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleFont",
        "comment": " Specify a default axis title font.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleFontSize",
        "comment": " Specify a default axis title font size.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleFontWeight",
        "comment": " Specify a default axis title font weight.\n",
        "type": "VegaLite.FontWeight -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleLimit",
        "comment": " Specify a default axis title maximum size.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleMaxLength",
        "comment": " Specify a default axis title maximum length when generated automatically from\na field's description.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitlePadding",
        "comment": " Specify a default axis title padding between axis line and text.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleX",
        "comment": " Specify a default axis x-position relative to the axis group.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleY",
        "comment": " Specify a default axis y-position relative to the axis group.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "background",
        "comment": " Set the background color of the visualization. Should be specified with a CSS\nstring such as `#ffe` or `rgb(200,20,150)`. If not specified the background will\nbe transparent.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "bar",
        "comment": " Specify a [bar mark](https://vega.github.io/vega-lite/docs/bar.html) for histograms,\nbar charts etc.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "biBase",
        "comment": " Specify the number base to use for automatic bin determination (default is\nbase 10).\n",
        "type": "Float -> VegaLite.BinProperty"
      },
      {
        "name": "biDivide",
        "comment": " Specify the scale factors indicating allowable subdivisions for binning.\nThe default value is [5, 2], which indicates that for base 10 numbers (the\ndefault base), binning will consider dividing bin sizes by 5 and/or 2.\n",
        "type": "List Float -> VegaLite.BinProperty"
      },
      {
        "name": "biExtent",
        "comment": " Specify the desired range of bin values when binning a collection of values.\nThe first and second parameters indicate the minimum and maximum range values\nrespectively.\n",
        "type": "Float -> Float -> VegaLite.BinProperty"
      },
      {
        "name": "biMaxBins",
        "comment": " Specify the maximum number of bins when binning a collection of values.\n",
        "type": "Int -> VegaLite.BinProperty"
      },
      {
        "name": "biMinStep",
        "comment": " Specify the step size between bins when binning a collection of values.\n",
        "type": "Float -> VegaLite.BinProperty"
      },
      {
        "name": "biNice",
        "comment": " Specify whether or not binning boundaries use human-friendly values such as\nmultiples of ten.\n",
        "type": "Bool -> VegaLite.BinProperty"
      },
      {
        "name": "biStep",
        "comment": " Specify an exact step size between bins when binning a collection of values.\n",
        "type": "Float -> VegaLite.BinProperty"
      },
      {
        "name": "biSteps",
        "comment": " Specify the allowable step sizes between bins when binning a collection of\nvalues.\n",
        "type": "List Float -> VegaLite.BinProperty"
      },
      {
        "name": "binAs",
        "comment": " Create a named binning transformation that may be referenced in other Transformations\nor encodings. The type of binning can be customised with a list of `BinProperty`\ngenerating functions ([biBase](#biBase), [biDivide](#biDivide) etc.) or an empty\nlist to use the default binning.\n\n    trans =\n        transform\n            << binAs [ MaxBins 3 ] \"IMDB_Rating\" \"ratingGroup\"\n\nNote that usually, direct binning within an encoding is preferred over this form\nof bin transformation.\n\n",
        "type": "List VegaLite.BinProperty -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "boo",
        "comment": " Specify a boolean data value. This is used when a function can accept values\nof different types.\n",
        "type": "Bool -> VegaLite.DataValue"
      },
      {
        "name": "boos",
        "comment": " Specify a list of boolean data values. This is used when a function can\naccept lists of different types.\n",
        "type": "List Bool -> VegaLite.DataValues"
      },
      {
        "name": "bounds",
        "comment": " Specify the bounds calculation method to use for determining the extent of\na sub-plot in a composed view. If set to `Full` (the default) the entire calculated\nbounds including axes, title and legend are used, if `Flush` only the width and\nheight values for the sub-view will be used. `Flush` can be useful when laying out\nsub-plots without axes or legends into a uniform grid structure.\n",
        "type": "VegaLite.Bounds -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "boxplot",
        "comment": " Specify a [boxplot composite mark](https://vega.github.io/vega-lite/docs/boxplot.html)\nfor showing summaries of statistical distibutions.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "calculateAs",
        "comment": " Generate a new data field based on calculations from existing fields.\nThe first parameter is an expression representing the calculation and the second\nis the name to give the newly calculated field. The third is a list of\ntransformations to which this is to be added.\n\n    trans =\n        transform << calculateAs \"datum.sex == 2 ? 'F' : 'M'\" \"gender\"\n\n",
        "type": "String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "categoricalDomainMap",
        "comment": " Create a set of discrete domain to color mappings suitable for customising categorical\nscales. The first item in each tuple should be a domain value and the second the\ncolor value with which it should be associated. It is a convenience function equivalent\nto specifying separate `SDomain` and `SRange` lists and is safer as it guarantees\na one-to-one correspondence between domain and range values.\n\n    color\n        [ mName \"weather\"\n        , mMType Nominal\n        , mScale <|\n            categoricalDomainMap\n                [ ( \"sun\", \"yellow\" )\n                , ( \"rain\", \"blue\" )\n                , ( \"fog\", \"grey\" )\n                ]\n        ]\n\n",
        "type": "List ( String, String ) -> List VegaLite.ScaleProperty"
      },
      {
        "name": "center",
        "comment": " Specify whether or not sub-views specified in a composition operator should\nbe centred relative to their respective rows or columns. This version sets the same\ncentring for rows and columns.\n",
        "type": "Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "centerRC",
        "comment": " Similar to [center](#center) but with independent centring for rows and columns.\n",
        "type": "Bool -> Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "circle",
        "comment": " Specify a [circle mark](https://vega.github.io/vega-lite/docs/circle.html)\nfor symbolising points.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "clipRect",
        "comment": " Specify a clipping rectangle in pixel units. The four parameters are respectively\n'left', 'top', 'right' and 'bottom' of the rectangular clipping bounds.\n",
        "type": "Float -> Float -> Float -> Float -> VegaLite.ClipRect"
      },
      {
        "name": "coArea",
        "comment": " Configure the default appearance of area marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAutosize",
        "comment": " Configure the default sizing of visualizations.\n",
        "type": "List VegaLite.Autosize -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxis",
        "comment": " Configure the default appearance of axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisBand",
        "comment": " Configure the default appearance of axes with band scaling.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisBottom",
        "comment": " Configure the default appearance of bottom-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisLeft",
        "comment": " Configure the default appearance of left-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisRight",
        "comment": " Configure the default appearance of right-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisTop",
        "comment": " Configure the default appearance of top-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisX",
        "comment": " Configure the default appearance of x-axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisY",
        "comment": " Configure the default appearance of y-axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coBackground",
        "comment": " Configure the default background color of visualizations.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coBar",
        "comment": " Configure the default appearance of bar marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coCircle",
        "comment": " Configure the default appearance of circle marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coCountTitle",
        "comment": " Configure the default title style for count fields.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coFieldTitle",
        "comment": " Configure the default title generation style for fields.\n",
        "type": "VegaLite.FieldTitleProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coGeoshape",
        "comment": " Configure the default appearance of geoshape marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coLegend",
        "comment": " Configure the default appearance of legends.\n",
        "type": "List VegaLite.LegendConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coLine",
        "comment": " Configure the default appearance of line marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coMark",
        "comment": " Configure the default mark appearance.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coNamedStyle",
        "comment": " Configure the default appearance of a named style.\n",
        "type": "String -> List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coNumberFormat",
        "comment": " Configure the default number formatting for axis and text labels.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coPadding",
        "comment": " Configure the default padding in pixels from the edge of the of visualization\nto the data rectangle.\n",
        "type": "VegaLite.Padding -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coPoint",
        "comment": " Configure the default appearance of point marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coProjection",
        "comment": " Configure the default style of map projections.\n",
        "type": "List VegaLite.ProjectionProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRange",
        "comment": " Configure the default range properties used when scaling.\n",
        "type": "List VegaLite.RangeConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRect",
        "comment": " Configure the default appearance of rectangle marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRemoveInvalid",
        "comment": " Configure the default handling of invalid (`null` and `NaN`) values. If `true`,\ninvalid values are skipped or filtered out when represented as marks.\n",
        "type": "Bool -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRule",
        "comment": " Configure the default appearance of rule marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coScale",
        "comment": " Configure the default scale properties used when scaling.\n",
        "type": "List VegaLite.ScaleConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coSelection",
        "comment": " Configure the default appearance of selection marks.\n",
        "type": "List ( VegaLite.Selection, List VegaLite.SelectionProperty ) -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coSquare",
        "comment": " Configure the default appearance of square marks.)\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coStack",
        "comment": " Configure the default stack offset style for stackable marks.\n",
        "type": "VegaLite.StackProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coText",
        "comment": " Configure the default appearance of text marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTick",
        "comment": " Configure the default appearance of tick marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTimeFormat",
        "comment": " Configure the default time format for axis and legend labels.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTitle",
        "comment": " Configure the default style of visualization titles.\n",
        "type": "List VegaLite.TitleConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTrail",
        "comment": " Specify the default style of trail marks.\n\n    config =\n        configure << coTrail [ maOpacity 0.5, maStrokeDash [ 1, 2 ] ]\n\n",
        "type": "List VegaLite.MarkProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "coView",
        "comment": " Configure the default single view style.\n",
        "type": "List VegaLite.ViewConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "color",
        "comment": " Encode a color channel. The first parameter is a list of mark channel properties\nthat characterise the way a data field is encoded by color. The second is a list of\nchannels to which this should be added.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "column",
        "comment": " Encodes a new facet to be arranged in columns. The first parameter is a list\nof properties that define the faceting channel. This should include at least the\nname of the data field and its measurement type. The second is a list of channels\nto which this is to be added.\n",
        "type": "List VegaLite.FacetChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "columnBy",
        "comment": " Specify the mapping between a column and its field definitions in a set of\nfaceted small multiples.\n",
        "type": "List VegaLite.FacetChannel -> VegaLite.FacetMapping"
      },
      {
        "name": "columnFields",
        "comment": " Create a list of fields to use in set of repeated small multiples arranged in\ncolumns. The list of fields named here can be referenced in an encoding with\n`pRepeat Column`, `mRepeat Column` etc.\n",
        "type": "List String -> VegaLite.RepeatFields"
      },
      {
        "name": "combineSpecs",
        "comment": " Combines a list of labelled specifications that may be passed to JavaScript\nfor rendering. This is useful when you wish to create a single page with multiple\nvisulizualizations.\n\n    combineSpecs\n        [ ( \"vis1\", myFirstVis )\n        , ( \"vis2\", mySecondVis )\n        , ( \"vis3\", myOtherVis )\n        ]\n\n",
        "type": "List VegaLite.LabelledSpec -> VegaLite.Spec"
      },
      {
        "name": "configuration",
        "comment": " Specify a single configuration option to be applied globally across the visualization.\nThe first parameter identifies the type of configuration, the second a list of previous\nconfigurations to which this may be added.\n",
        "type": "VegaLite.ConfigurationProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "configure",
        "comment": " Create a single global configuration from a list of configuration specifications.\nConfigurations are applied to all relevant items in the specification. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html) for\nmore details.\n\n    config =\n        configure\n            << configuration (coAxis [ axcoDomainWidth 1 ])\n            << configuration (coView [ vicoStroke Nothing ])\n            << configuration (coSelection [ ( Single, [ seOn \"dblclick\" ] ) ])\n\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "cubeHelix",
        "comment": " Specify a cube helix color interpolation for continuous color scales. The\nparameter is the gamma value to use in interpolation (anchored at 1).\n",
        "type": "Float -> VegaLite.CInterpolate"
      },
      {
        "name": "cubeHelixLong",
        "comment": " Specify a long-path cube helix color interpolation for continuous color scales.\nThe parameter is the gamma value to use in interpolation (anchored at 1).\n",
        "type": "Float -> VegaLite.CInterpolate"
      },
      {
        "name": "customProjection",
        "comment": " Specify a custom projection type. Additional custom projections from d3 can\nbe defined via the [Vega API](https://vega.github.io/vega/docs/projections/#register)\nand called from with this function where the parameter is the name of the D3\nprojection to use (e.g. `customProjection \"winkel3\"`).\n",
        "type": "String -> VegaLite.Projection"
      },
      {
        "name": "dAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nlevel of detail (grouping) channel. The type of aggregation is determined by the\ngiven operation parameter.\n",
        "type": "VegaLite.Operation -> VegaLite.DetailChannel"
      },
      {
        "name": "dBin",
        "comment": " Discretize numeric values into bins when encoding with a level of detail\n(grouping) channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.DetailChannel"
      },
      {
        "name": "dMType",
        "comment": " Specify the field type (level of measurement) when encoding with a level of\ndetail (grouping) channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.DetailChannel"
      },
      {
        "name": "dName",
        "comment": " Provide the name of the field used for encoding with a level of detail\n(grouping) channel.\n",
        "type": "String -> VegaLite.DetailChannel"
      },
      {
        "name": "dTimeUnit",
        "comment": " Specify the form of time unit aggregation of field values when encoding\nwith a level of detail (grouping) channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.DetailChannel"
      },
      {
        "name": "dataColumn",
        "comment": " Create a column of data. A column has a name and a list of values. The final\nparameter is the list of columns to which this is added.\n",
        "type": "String -> VegaLite.DataValues -> List VegaLite.DataColumn -> List VegaLite.DataColumn"
      },
      {
        "name": "dataFromColumns",
        "comment": " Declare a data source from a list of column values. Each column should contain\nvalues of the same type, but columns each with a different type are permitted.\nIf columns do not contain the same number of items the dataset will be truncated\nto the length of the shortest. A list of field formatting instructions can be\nprovided as the first parameter or an empty list to use the default formatting.\nThe columns are most easily generated with [dataColumn](#dataColumn):\n\n    data =\n        dataFromColumns [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataColumn \"Animal\" (strs [ \"Fish\", \"Dog\", \"Cat\" ])\n            << dataColumn \"Age\" (nums [ 28, 12, 6 ])\n            << dataColumn \"Year\" (strs [ \"2010\", \"2014\", \"2015\" ])\n\nFor more complex inline data tables, such as mixures of arrays and objects, consider\nusing [dataFromJson](#dataFromJson).\n\n",
        "type": "List VegaLite.Format -> List VegaLite.DataColumn -> VegaLite.Data"
      },
      {
        "name": "dataFromJson",
        "comment": " Declare a data source from a json specification. The most likely use-case is\ncreating [geojson](http://geojson.org) objects with [`geometry`](#geometry),\n[`geometryCollection`](#geometryCollection) and [`geoFeatureCollection`](#geoFeatureCollection).\nFor more general cases of json creation such as data tables that mix arrays and\nobjects, consider\n[`Json.Encode`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Encode).\n\n    let\n        geojson =\n            geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n    in\n    toVegaLite\n        [ width 200\n        , height 200\n        , dataFromJson geojson []\n        , projection [ prType Orthographic ]\n        , geoshape []\n        ]\n\n",
        "type": "VegaLite.Spec -> List VegaLite.Format -> VegaLite.Data"
      },
      {
        "name": "dataFromRows",
        "comment": " Declare a data source from a list of row values. Each row should contain a\nlist of tuples in the form (_column name_, _value_). Each column can have a value\nof a different type but you must ensure that values are of the same type as others\nin the same column. A list of field formatting instructions can be provided as\nthe first parameter or an empty list to use the default formatting. Rows are most\neasily generated with [dataRow](#dataRow).\n\n    data =\n        dataFromRows [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataRow [ ( \"Animal\", str \"Fish\" ), ( \"Age\", num 28 ), ( \"Year\", str \"2010\" ) ]\n            << dataRow [ ( \"Animal\", str \"Dog\" ), ( \"Age\", num 12 ), ( \"Year\", str \"2014\" ) ]\n            << dataRow [ ( \"Animal\", str \"Cat\" ), ( \"Age\", num 6 ), ( \"Year\", str \"2015\" ) ]\n\nGenerally, adding data by column is more efficient and less error-prone. For more\ncomplex inline data tables, such as mixures of arrays and objects, consider using\n[dataFromJson](#dataFromJson).\n\n",
        "type": "List VegaLite.Format -> List VegaLite.DataRow -> VegaLite.Data"
      },
      {
        "name": "dataFromSource",
        "comment": " Declare data from a named source. The source may be from named `datasets` within\na specification or one created via the [Vega View API](https://vega.github.io/vega/docs/api/view/#data).\nA list of field formatting instructions can be provided as the second parameter\nor an empty list to use the default formatting.\n\n    data = ...\n    json = ...\n    enc = ...\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , bar []\n        , enc []\n        ]\n\n",
        "type": "String -> List VegaLite.Format -> VegaLite.Data"
      },
      {
        "name": "dataFromUrl",
        "comment": " Declare a data source from a url. The URL can be a local path on a web server\nor an external (CORS) URL. A list of field formatting instructions can be provided\nas the second parameter or an empty list to use the default formatting.\n",
        "type": "String -> List VegaLite.Format -> VegaLite.Data"
      },
      {
        "name": "dataName",
        "comment": " Provide name for a data source. Useful when a specification needs to reference\na data source, such as one generated via an API call.\n\n    data =\n        dataFromUrl \"myData.json\" [] |> dataName \"myName\"\n\n",
        "type": "String -> VegaLite.Data -> VegaLite.Data"
      },
      {
        "name": "dataRow",
        "comment": " Create a row of data. A row comprises a list of (_columnName_, _value_) pairs.\nThe final parameter is the list of rows to which this is added.\n",
        "type": "List ( String, VegaLite.DataValue ) -> List VegaLite.DataRow -> List VegaLite.DataRow"
      },
      {
        "name": "datasets",
        "comment": " Create a dataset comprising a collection of named `Data` items. Each data item\ncan be created with normal data generating functions such as [dataFromRows](#dataFromRows)\nor [dataFromJson](#dataFromJson). These can be later referred to using\n[dataFromSource](#dataFromSource).\n\n    import Json.Encode as JE\n\n    let\n        data =\n            dataFromRows []\n                << dataRow [ ( \"cat\", str \"a\" ), ( \"val\", num 10 ) ]\n                << dataRow [ ( \"cat\", str \"b\" ), ( \"val\", num 18 ) ]\n        json =\n            JE.list\n                [ JE.object [ ( \"cat\", JE.string \"a\" ), ( \"val\", JE.float 120 ) ]\n                , JE.object [ ( \"cat\", JE.string \"b\" ), ( \"val\", JE.float 180 ) ]\n                ]\n\n        enc = ...\n\n    in\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , bar []\n        , enc []\n        ]\n\n",
        "type": "List ( String, VegaLite.Data ) -> VegaLite.Data"
      },
      {
        "name": "description",
        "comment": " Provides an optional description to be associated with the visualization.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "detail",
        "comment": " Encode a 'level of detail' channel. This provides a way of grouping by a field\nbut unlike, say `color`, all groups have the same visual properties. The first\nparameter is a list of the field characteristics to be grouped. The second is a\nlist of channels to which this is to be added.\n",
        "type": "List VegaLite.DetailChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "doDts",
        "comment": " Specify the date-time values that define a scale domain.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.ScaleDomain"
      },
      {
        "name": "doNums",
        "comment": " Specify the numeric values that define a scale domain.\n",
        "type": "List Float -> VegaLite.ScaleDomain"
      },
      {
        "name": "doSelection",
        "comment": " Specify a scale domain based on a named interactive selection.\n",
        "type": "String -> VegaLite.ScaleDomain"
      },
      {
        "name": "doStrs",
        "comment": " Specify the string values that define a scale domain.\n",
        "type": "List String -> VegaLite.ScaleDomain"
      },
      {
        "name": "domainRangeMap",
        "comment": " Create a pair of continuous domain to color mappings suitable for customising\nordered scales. The first parameter is a tuple representing the mapping of the lowest\nnumeric value in the domain to its equivalent color; the second tuple the mapping\nof the highest numeric value to color. If the domain contains any values between\nthese lower and upper bounds they are interpolated according to the scale's interpolation\nfunction. This is a convenience function equivalent to specifying separate `SDomain`\nand `SRange` lists and is safer as it guarantees a one-to-one correspondence between\ndomain and range values.\n\n    color\n        [ mName \"year\"\n        , mMType Ordinal\n        , mScale (domainRangeMap ( 1955, \"#e6959c\" ) ( 2000, \"#911a24\" ))\n        ]\n\n",
        "type": "( Float, String ) -> ( Float, String ) -> List VegaLite.ScaleProperty"
      },
      {
        "name": "dsv",
        "comment": " Specify a delimited file format (DSV) with a given separator.\n",
        "type": "Char -> VegaLite.Format"
      },
      {
        "name": "dt",
        "comment": " Specify a date-time data value. This is used when a function can accept values\nof different types.\n",
        "type": "List VegaLite.DateTime -> VegaLite.DataValue"
      },
      {
        "name": "dtDate",
        "comment": " Specify a day of the month as an integer. For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtDay",
        "comment": " Specify a day of the week. For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "VegaLite.DayName -> VegaLite.DateTime"
      },
      {
        "name": "dtHour",
        "comment": " Specify an hour of the day (0=midnight, 1=1am, 23=11pm etc.) an integer. For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtMillisecond",
        "comment": " Specify a millisecond of a second (0-999). For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtMinute",
        "comment": " Specify a minute of an hour (0-59). For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtMonth",
        "comment": " Specify a month as an integer (1=January, 2=February etc.). For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "VegaLite.MonthName -> VegaLite.DateTime"
      },
      {
        "name": "dtQuarter",
        "comment": " Specify a year quarter as an integer. For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtRange",
        "comment": " Specify the min max date-time range to be used in data filtering. If either\nparameter is an empty list, it is assumed to be unbounded.\n",
        "type": "List VegaLite.DateTime -> List VegaLite.DateTime -> VegaLite.FilterRange"
      },
      {
        "name": "dtSecond",
        "comment": " Specify a second of a minute (0-59). For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtYear",
        "comment": " Specify a year as an integer. For details, see the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dts",
        "comment": " Specify a list of date-time data values. This is used when a function can\naccept lists of different types.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.DataValues"
      },
      {
        "name": "encoding",
        "comment": " Create an encoding specification from a list of channel encodings.\n\n    enc =\n        encoding\n            << position X [ pName \"Animal\", pMType Ordinal ]\n            << position Y [ pName \"Age\", pMType Quantitative ]\n            << size [ mName \"Population\", mMType Quantitative ]\n\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "errorband",
        "comment": " Specify an [errorband composite mark](https://vega.github.io/vega-lite/docs/errorband.html)\nfor showing summaries of (error) variation along a signal. By default no border is\ndrawn. To add a border with default properties add [maBorders](#maBorders) with an empty list.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "errorbar",
        "comment": " Specify an [errorbar composite mark](https://vega.github.io/vega-lite/docs/errorbar.html)\nfor showing summaries of (error) variation along a signal. By default no ticks are\ndrawn. To add ticks with default properties add [maTicks](#maTicks) with an empty list.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "expr",
        "comment": " Specify an expression that should evaluate to either true or false. Can use\nany valid [Vega expression](https://vega.github.io/vega/docs/expressions/).\n",
        "type": "String -> VegaLite.BooleanOp"
      },
      {
        "name": "fAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nfacet channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.FacetChannel"
      },
      {
        "name": "fBin",
        "comment": " Discretize numeric values into bins when encoding with a facet channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.FacetChannel"
      },
      {
        "name": "fHeader",
        "comment": " Specify the 'axis' for a series of faceted plots. This is the guide that spans\nthe collection of faceted plots, each of which may have their own axes.\n",
        "type": "List VegaLite.HeaderProperty -> VegaLite.FacetChannel"
      },
      {
        "name": "fMType",
        "comment": " Specify the field type (level of measurement) when encoding with a facet channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.FacetChannel"
      },
      {
        "name": "fName",
        "comment": " Provide the name of the field used for encoding with a facet channel.\n",
        "type": "String -> VegaLite.FacetChannel"
      },
      {
        "name": "fTimeUnit",
        "comment": " Specify the form of time unit aggregation of field values when encoding\nwith a facet channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.FacetChannel"
      },
      {
        "name": "facet",
        "comment": " Defines the fields that will be used to facet a view in rows or columns to create\na set of small multiples. This is used where the encoding of the visualization in small\nmultiples is identical, but data for each is grouped by the given fields. When\ncreating a faceted view in this way you also need to define a full specification\nto apply to each of those facets using `asSpec`.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"Origin\", fMType Nominal ] ]\n        , specifcation spec\n        ]\n\n",
        "type": "List VegaLite.FacetMapping -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "false",
        "comment": " A false value used for functions that can accept a Boolean literal or a\nreference to something that generates a Boolean value. This is a convenience\nfunction equivalent to `boo False`\n",
        "type": "VegaLite.DataValue"
      },
      {
        "name": "fiCompose",
        "comment": " Build up a filtering predicate through logical composition (`and`, `or` etc.).\n",
        "type": "VegaLite.BooleanOp -> VegaLite.Filter"
      },
      {
        "name": "fiEqual",
        "comment": " Filter a data stream so that only data in a given field equal to the given\nvalue are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiExpr",
        "comment": " Filter a data stream so that only data that satisfy the given predicate\nexpression are used.\n",
        "type": "String -> VegaLite.Filter"
      },
      {
        "name": "fiGreaterThan",
        "comment": " Filter a data stream so that only data in a given field greater than the given\nvalue are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiGreaterThanEq",
        "comment": " Filter a data stream so that only data in a given field greater than or equal\nto the given value are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiLessThan",
        "comment": " Filter a data stream so that only data in a given field less than the given\nvalue are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiLessThanEq",
        "comment": " Filter a data stream so that only data in a given field less than or equal to\nthe given value are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiOneOf",
        "comment": " Filter a data stream so that only data in a given field contained in the given\nlist of values are used.\n",
        "type": "String -> VegaLite.DataValues -> VegaLite.Filter"
      },
      {
        "name": "fiRange",
        "comment": " Filter a data stream so that only data in a given field that are within the\ngiven range are used.\n",
        "type": "String -> VegaLite.FilterRange -> VegaLite.Filter"
      },
      {
        "name": "fiSelection",
        "comment": " Filter a data stream so that only data in a given field that are within the\ngiven interactive selection are used.\n",
        "type": "String -> VegaLite.Filter"
      },
      {
        "name": "fill",
        "comment": " Encode a fill channel. This acts in a similar way to encoding by `color` but\nonly affects the interior of closed shapes. If both `fill` and `color` encodings\nare specified, `fill` takes precedence.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "filter",
        "comment": " Apply a filter to a channel or field. The first parameter is the filter to apply,\nthe second a list of transformations to which this is added.\n",
        "type": "VegaLite.Filter -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "flatten",
        "comment": " Map array-valued fields to a set of individual data objects, one per array entry.\n",
        "type": "List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "flattenAs",
        "comment": " Similar to [flatten](#flatten) but allows the new output fields to be named\n(second parameter).\n",
        "type": "List String -> List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "foDate",
        "comment": " Specify a date format for parsing input data using\n[D3's formatting specifiers](https://vega.github.io/vega-lite/docs/data.html#format)\nor left as an empty string for default formatting. Care should be taken when\nassuming default parsing because different browsers can parse dates differently.\nBeing explicit about the format is usually safer.\n",
        "type": "String -> VegaLite.DataType"
      },
      {
        "name": "foUtc",
        "comment": " Similar to [foDate](#foDate) but for UTC format dates.\n",
        "type": "String -> VegaLite.DataType"
      },
      {
        "name": "fold",
        "comment": " Collapse one or more data fields into two properties: a _key_ (containing\nthe original data field name) and a _value_ (containing the data value). Useful\nfor mapping matrix or cross-tabulation data into a standardized format.\n",
        "type": "List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "foldAs",
        "comment": " Similar to [fold](#fold) but allows the new output `key` and `value` fields\nto be given alternative names\n",
        "type": "List String -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "geoFeatureCollection",
        "comment": " Specify a list of geo features to be used in a `geoshape` specification.\nEach feature object in this collection can be created with [geometry](#geometry).\n\n    geojson =\n        geoFeatureCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( -3, 52 ), ( 4, 52 ), ( -3, 59 ) ] ])\n                [ ( \"myRegionName\", str \"Northern region\" ) ]\n            , geometry (geoPolygon [ [ ( -3, 52 ), ( 4, 52 ), ( 4, 45 ), ( -3, 52 ) ] ])\n                [ ( \"myRegionName\", str \"Southern region\" ) ]\n            ]\n\n",
        "type": "List VegaLite.Spec -> VegaLite.Spec"
      },
      {
        "name": "geoLine",
        "comment": " Specify line geometry for programmatically creating GeoShapes. Equivalent to\nthe [GeoJson geometry `line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List ( Float, Float ) -> VegaLite.Geometry"
      },
      {
        "name": "geoLines",
        "comment": " Specify multi-line geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List (List ( Float, Float )) -> VegaLite.Geometry"
      },
      {
        "name": "geoPoint",
        "comment": " Specify point geometry for programmatically creating GeoShapes. Equivalent to\nthe [GeoJson geometry `point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "Float -> Float -> VegaLite.Geometry"
      },
      {
        "name": "geoPoints",
        "comment": " Specify multi-point geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List ( Float, Float ) -> VegaLite.Geometry"
      },
      {
        "name": "geoPolygon",
        "comment": " Specify polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List (List ( Float, Float )) -> VegaLite.Geometry"
      },
      {
        "name": "geoPolygons",
        "comment": " Specify multi-polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List (List (List ( Float, Float ))) -> VegaLite.Geometry"
      },
      {
        "name": "geometry",
        "comment": " Specify a geometric object to be used in a `geoshape`. The first parameter is\nthe geometric type, the second an optional list of properties to be associated\nwith the object.\n\n      geojson =\n          geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n\n",
        "type": "VegaLite.Geometry -> List ( String, VegaLite.DataValue ) -> VegaLite.Spec"
      },
      {
        "name": "geometryCollection",
        "comment": " Specify a list of geometry objects to be used in a `geoshape` specification.\nEach geometry object with [geometry](#geometry).\n\n    geojson =\n        geometryCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n            , geometry (geoPoint -3.5 55.5) []\n            ]\n\n",
        "type": "List VegaLite.Spec -> VegaLite.Spec"
      },
      {
        "name": "geoshape",
        "comment": " Specify a [geoshape](https://vega.github.io/vega-lite/docs/geoshape.html)\ndetermined by georaphically referenced coordinates.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "hAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nhyperlink channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hBin",
        "comment": " Discretize numeric values into bins when encoding with a hyperlink channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hConcat",
        "comment": " Assigns a list of specifications to be juxtaposed horizontally in a visualization.\n",
        "type": "List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "hDataCondition",
        "comment": " Specify the properties of a hyperlink channel conditional on some predicate\nexpression. The first parameter provides the expression to evaluate, the second the encoding\nto apply if the expression is true, the third the encoding if the expression is\nfalse.\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.HyperlinkChannel -> List VegaLite.HyperlinkChannel -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hMType",
        "comment": " Specify the field type (level of measurement) when encoding with a hyperlink\nchannel.\n",
        "type": "VegaLite.Measurement -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hName",
        "comment": " Provide the name of the field used for encoding with a hyperlink channel.\n",
        "type": "String -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hRepeat",
        "comment": " Reference in a hyperlink channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields being laid out\nin columns or in rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hSelectionCondition",
        "comment": " Specify the properties of a hyperlink channel conditional on interactive selection.\nThe first parameter provides the selection to evaluate, the second the encoding\nto apply if the hyperlink has been selected, the third the encoding if it is not selected.\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.HyperlinkChannel -> List VegaLite.HyperlinkChannel -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hStr",
        "comment": " Provide a literal string value when encoding with a hyperlink channel.\n",
        "type": "String -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hTimeUnit",
        "comment": " Specify the form of time unit aggregation of field values when encoding\nwith a hyperlink channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hdFormat",
        "comment": " Specify the header format specifier for a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelAngle",
        "comment": " Specify the header label rotation angle (in degrees) for a faceted view. A\n'label' is the title for each sub-plot in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelColor",
        "comment": " Specify the header label text color for a faceted view. A 'label' is the title\nfor each sub-plot in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelFont",
        "comment": " Specify the header label font for a faceted view. A 'label' is the title for\neach sub-plot in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelFontSize",
        "comment": " Specify the header label font size for a faceted view. A 'label' is the title\nfor each sub-plot in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelLimit",
        "comment": " Specify the maximum length (in pixels) of a header label in a faceted view.\nA 'label' is the title for each sub-plot in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitle",
        "comment": " Specify a header title in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleAnchor",
        "comment": " Specify the anchor position of a header title in a faceted view.\nA 'title' is the overall title describing the collection of faceted plots.\n",
        "type": "VegaLite.APosition -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleAngle",
        "comment": " Specify the text angle of a header title in a faceted view. A 'title' is the\noverall title describing the collection of faceted plots.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleBaseline",
        "comment": " Specify the vertical alignment of a header title in a faceted view.\n",
        "type": "VegaLite.VAlign -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleColor",
        "comment": " Specify the text color of a header title in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleFont",
        "comment": " Specify the title font in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleFontSize",
        "comment": " Specify the title font size in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleFontWeight",
        "comment": " Specify the title font weight in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleLimit",
        "comment": " Specify the maximum length (in pixels) of a header title in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "height",
        "comment": " Override the default height of the visualization. If not specified the height\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "hyperlink",
        "comment": " Encode a hyperlink channel. The first parameter is a list of hyperlink channel\nproperties that characterise the hyperlinking such as the destination URL and cursor\ntype. The second is a list of encoding channels to which this should be added.\n",
        "type": "List VegaLite.HyperlinkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "iCheckbox",
        "comment": " Specify a checkbox input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iColor",
        "comment": " Specify a color input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iDate",
        "comment": " Specify a date input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iDateTimeLocal",
        "comment": " Specify a local time input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iMonth",
        "comment": " Specify a month input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iNumber",
        "comment": " Specify a number input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iRadio",
        "comment": " Specify a radio box input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iRange",
        "comment": " Specify a range slider input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iSelect",
        "comment": " Specify a select input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iTel",
        "comment": " Specify a telephone number input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iText",
        "comment": " Specify a text input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iTime",
        "comment": " Specify a time input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iWeek",
        "comment": " Specify a week input element that can bound to a named field value (first\nparameter.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "inDebounce",
        "comment": " Specify the delay in input event handling when processing input events in\norder to avoid unnecessary event broadcasting.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "inElement",
        "comment": " Specify an optional CSS selector indicating the parent element to which an\ninput element should be added. This allows the option of the input element to be\noutside the visualization container.\n",
        "type": "String -> VegaLite.InputProperty"
      },
      {
        "name": "inMax",
        "comment": " Specify the maximum slider value for a range input element. Defaults to the\nlarger of the signal value and 100.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "inMin",
        "comment": " Specify the minimum slider value for a range input element. Defaults to the\nsmaller of the signal value and 0.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "inName",
        "comment": " Specify a custom label for a radio or select input element.\n",
        "type": "String -> VegaLite.InputProperty"
      },
      {
        "name": "inOptions",
        "comment": " Specify a range of options for a radio or select input element.\n",
        "type": "List String -> VegaLite.InputProperty"
      },
      {
        "name": "inPlaceholder",
        "comment": " Specify the initial placeholding text for input elements such as text fields.\n",
        "type": "String -> VegaLite.InputProperty"
      },
      {
        "name": "inStep",
        "comment": " Specify the minimum input element range slider increment. If undefined,\nthe step size will be automatically determined based on the min and max values.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "iqrScale",
        "comment": " A scaling of the interquartile range to be used as whiskers in a boxplot.\nFor example a value of 1.5 would extend whiskers to Â±1.5x the IQR from the mean.\n",
        "type": "Float -> VegaLite.SummaryExtent"
      },
      {
        "name": "jsonProperty",
        "comment": " Specify the property to be extracted from some JSON when it has some\nsurrounding structure or meta-data. For example, specifying the property\n`values.features` is equivalent to retrieving `json.values.features` from the\nloaded JSON object with a custom delimiter.\n",
        "type": "String -> VegaLite.Format"
      },
      {
        "name": "layer",
        "comment": " Assigns a list of specifications to superposed layers in a visualization.\n\n    let\n        spec1 = ...\n        spec2 = ...\n    in\n    toVegaLite\n        [ dataFromUrl \"data/driving.json\" []\n        , layer [ spec1, spec2 ]\n        ]\n\n",
        "type": "List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "leDts",
        "comment": " Specify a set of legend date-times explicitly.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.LegendValues"
      },
      {
        "name": "leFormat",
        "comment": " Specify the formatting pattern for legend labels.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leNums",
        "comment": " Specify a set of legend numeric values explicitly.\n",
        "type": "List Float -> VegaLite.LegendValues"
      },
      {
        "name": "leOffset",
        "comment": " Specify the offset in pixels of a legend from the edge of its enclosing group\n/ data rectangle.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leOrient",
        "comment": " Specify the position of a legend in a scene.\n",
        "type": "VegaLite.LegendOrientation -> VegaLite.LegendProperty"
      },
      {
        "name": "lePadding",
        "comment": " Specify the padding in pixels between a legend and axis.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leStrs",
        "comment": " Specify a set of legend strings explicitly.\n",
        "type": "List String -> VegaLite.LegendValues"
      },
      {
        "name": "leTickCount",
        "comment": " Specify the number of tick marks in a quantitative legend.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitle",
        "comment": " Specify the title of a legend.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leType",
        "comment": " Specify the type of legend (discrete symbols or continuous gradients).\n",
        "type": "VegaLite.Legend -> VegaLite.LegendProperty"
      },
      {
        "name": "leValues",
        "comment": " Specify the legend values explicitly.\n",
        "type": "VegaLite.LegendValues -> VegaLite.LegendProperty"
      },
      {
        "name": "leZIndex",
        "comment": " Specify the drawing order of a legend relative to other chart elements. To\nplace a legend in front of others use a positive integer, or 0 to draw behind.\n",
        "type": "Int -> VegaLite.LegendProperty"
      },
      {
        "name": "lecoCornerRadius",
        "comment": " Specify a default legend corner radius.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoEntryPadding",
        "comment": " Specify a default spacing between legend items.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoFillColor",
        "comment": " Specify a default background legend color.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientHeight",
        "comment": " Specify a default height of a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientLabelBaseline",
        "comment": " Specify a default vertical alignment for labels in a color ramp legend.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientLabelLimit",
        "comment": " Specify a default maximum allowable length for labels in a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientLabelOffset",
        "comment": " Specify a default vertical offset in pixel units for labels in a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientStrokeColor",
        "comment": " Specify a default color for strokes in a color ramp legend.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientStrokeWidth",
        "comment": " Specify a default width for strokes in a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientWidth",
        "comment": " Specify a default width of a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelAlign",
        "comment": " Specify a default horizontal alignment of legend labels.\n",
        "type": "VegaLite.HAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelBaseline",
        "comment": " Specify a default vertical alignment of legend labels.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelColor",
        "comment": " Specify a default color for legend labels.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelFont",
        "comment": " Specify a default font for legend labels.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelFontSize",
        "comment": " Specify a default font size legend labels.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelLimit",
        "comment": " Specify a default maximum width for legend labels in pixel units.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelOffset",
        "comment": " Specify a default offset for legend labels.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoOffset",
        "comment": " Specify a default offset in pixel units between the legend and the enclosing\ngroup or data rectangle.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoOrient",
        "comment": " Specify a default legend position relative to the main plot content.\n",
        "type": "VegaLite.LegendOrientation -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoPadding",
        "comment": " Specify a default spacing in pixel units between a legend and axis.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoShortTimeLabels",
        "comment": " Specify whether or not time labels are abbreviated by default in a legend.\n",
        "type": "Bool -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoStrokeColor",
        "comment": " Specify a default legend border color.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoStrokeDash",
        "comment": " Specify a default legend border stroke dash style.\n",
        "type": "List Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoStrokeWidth",
        "comment": " Specify a default legend border stroke width.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolColor",
        "comment": " Specify a default legend symbol color.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolSize",
        "comment": " Specify a default legend symbol size.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolStrokeWidth",
        "comment": " Specify a default legend symbol stroke width.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolType",
        "comment": " Specify a default legend symbol type.\n",
        "type": "VegaLite.Symbol -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleAlign",
        "comment": " Specify a default horizontal alignment for legend titles.\n",
        "type": "VegaLite.HAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleBaseline",
        "comment": " Specify a default vertical alignment for legend titles.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleColor",
        "comment": " Specify a default color legend titles.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleFont",
        "comment": " Specify a default font for legend titles.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleFontSize",
        "comment": " Specify a default font size for legend titles.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleFontWeight",
        "comment": " Specify a default font weight for legend titles.\n",
        "type": "VegaLite.FontWeight -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleLimit",
        "comment": " Specify a default maximum size in pixel units for legend titles.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitlePadding",
        "comment": " Specify a default spacing in pixel units between title and legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "line",
        "comment": " Specify a [line mark](https://vega.github.io/vega-lite/docs/line.html) for\nsymbolising a sequence of values.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "lmMarker",
        "comment": " Specify the properties of a line marker that is overlaid on an area mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.LineMarker"
      },
      {
        "name": "lookup",
        "comment": " Perform a lookup of named fields between two data sources. This allows you to\nfind values in one data source based on the values in another. The first parameter\nis the field in the primary data source to act as key, the second is the secondary\ndata source which can be specified with a call to `dataFromUrl` or other data\ngenerating function. The third is the name of the field in the secondary\ndata source to match values with the primary key. The fourth parameter is the list\nof fields to be stored when the keys match. The final parameter is a list of any\nother transformations to which this is to be added.\n\nThe following would return the values in the `age` and `height` fields from\n`lookup_people.csv` for all rows where the value in the `name` column in that\nfile matches the value of `person` in the primary data source.\n\n    data =\n        dataFromUrl \"data/lookup_groups.csv\" []\n\n    trans =\n        transform\n            << lookup \"person\"\n                (dataFromUrl \"data/lookup_people.csv\" [])\n                \"name\"\n                [ \"age\", \"height\" ]\n\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec ) -> String -> List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "lookupAs",
        "comment": " Similar to [lookup](#lookup) but returns the entire set of field values from\nthe secondary data source when keys match. Accessed with via name provided in the\nfourth parameter.\n",
        "type": "String -> VegaLite.Data -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "mAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nmark property channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.MarkChannel"
      },
      {
        "name": "mBin",
        "comment": " Discretize numeric values into bins when encoding with a mark property channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.MarkChannel"
      },
      {
        "name": "mBoo",
        "comment": " Provide a literal Boolean value when encoding with a mark property channel.\n",
        "type": "Bool -> VegaLite.MarkChannel"
      },
      {
        "name": "mDataCondition",
        "comment": " Specify the properties of a mark channel conditional on one or more predicate\nexpressions. The first parameter is a list of tuples each pairing a test condition\nwith the encoding if that condition evaluates to true. The second is the encoding\nif none of the tests are true.\n\n    color\n        [ mDataCondition [ ( expr \"datum.myField === null\", [ mStr \"grey\" ] ) ]\n            [ mStr \"black\" ]\n        ]\n\n",
        "type": "List ( VegaLite.BooleanOp, List VegaLite.MarkChannel ) -> List VegaLite.MarkChannel -> VegaLite.MarkChannel"
      },
      {
        "name": "mLegend",
        "comment": " Specify the properties of a legend that describes a mark's encoding. To stop\na legend from appearing provide an empty list as a parameter.\n",
        "type": "List VegaLite.LegendProperty -> VegaLite.MarkChannel"
      },
      {
        "name": "mMType",
        "comment": " Specify the field type (level of measurement) when encoding with a mark\nproperty channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.MarkChannel"
      },
      {
        "name": "mName",
        "comment": " Provide the name of the field used for encoding with a mark property channel.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "mNum",
        "comment": " Provide a literal numeric value when encoding with a mark property channel.\n",
        "type": "Float -> VegaLite.MarkChannel"
      },
      {
        "name": "mPath",
        "comment": " Provide an SVG path string when encoding with a mark property channel. Useful\nwhen providing custom shapes.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "mRepeat",
        "comment": " Reference in a mark channel to a field name generated by `repeat`. The\nparameter identifies whether fields are to be laid out in columns or rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.MarkChannel"
      },
      {
        "name": "mScale",
        "comment": " Specify the scaling applied to a field when encoding with a mark property channel.\nThe scale will transform a field's value into a color, shape, size etc.\n",
        "type": "List VegaLite.ScaleProperty -> VegaLite.MarkChannel"
      },
      {
        "name": "mSelectionCondition",
        "comment": " Specify the properties of a mark channel conditional on interactive selection.\nThe first parameter is a selection condition to evaluate; the second the encoding\nto apply if that selection is true; the third parameter is the encoding if the\nselection is false.\n\n    color\n        [ mSelectionCondition ( selectionName \"myBrush\")\n            [ mName \"myField\", mMType Ordinal ]\n            [ mStr \"grey\" ]\n        ]\n\nFor details, see the\n[Vega-Lite condition documentation](https://vega.github.io/vega-lite/docs/condition.html)\n\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.MarkChannel -> List VegaLite.MarkChannel -> VegaLite.MarkChannel"
      },
      {
        "name": "mStr",
        "comment": " Provide a literal string value when encoding with a mark property channel.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "mTimeUnit",
        "comment": " Specify the form of time unit aggregation of field values when encoding\nwith a mark property channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.MarkChannel"
      },
      {
        "name": "mTitle",
        "comment": " Specify the title of a field when encoding with a mark property channel. If\nan axis or legend title is defined, it will override any title defined here.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "maAlign",
        "comment": " Specify the horizontal alignment of a text mark.\n",
        "type": "VegaLite.HAlign -> VegaLite.MarkProperty"
      },
      {
        "name": "maAngle",
        "comment": " Specify the rotation angle in degrees of a text mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maBandSize",
        "comment": " Specify the band size in pixels of a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maBaseline",
        "comment": " Specify the vertical alignment of a text mark.\n",
        "type": "VegaLite.VAlign -> VegaLite.MarkProperty"
      },
      {
        "name": "maBinSpacing",
        "comment": " Specify the offset between bars for a binned field using a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maBorders",
        "comment": " Specify the border properties for the errorband mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.MarkProperty"
      },
      {
        "name": "maClip",
        "comment": " Specify whether or not a makr should be clipped to the enclosing group's\ndimensions.\n",
        "type": "Bool -> VegaLite.MarkProperty"
      },
      {
        "name": "maColor",
        "comment": " Specify the default color of a mark. Note that `maFill` and `maStroke` have\nhigher precedence and will override this if specified.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maContinuousBandSize",
        "comment": " Specify the continuous band size in pixels of a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maCursor",
        "comment": " Specify the cursor to be associated with a hyperlink mark.\n",
        "type": "VegaLite.Cursor -> VegaLite.MarkProperty"
      },
      {
        "name": "maDiscreteBandSize",
        "comment": " Specify the discrete band size in pixels of a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maDx",
        "comment": " Specify the horizontal offset in pixels between a text mark and its anchor.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maDy",
        "comment": " Specify the vertical offset in pixels between a text mark and its anchor.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maExtent",
        "comment": " Specify the extent of whiskers used in a boxplot, error bars or error bands.\n",
        "type": "VegaLite.SummaryExtent -> VegaLite.MarkProperty"
      },
      {
        "name": "maFill",
        "comment": " Specify the default fill color of a mark.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maFillOpacity",
        "comment": " Specify the fill opacity of a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maFilled",
        "comment": " Specify whether or not a mark's color should be used as the fill color\ninstead of stroke color.\n",
        "type": "Bool -> VegaLite.MarkProperty"
      },
      {
        "name": "maFont",
        "comment": " Specify the font of a text mark. This can be any font name made accessible via\na css file (or one of the generic fonts `serif`, `monospace` etc.).\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maFontSize",
        "comment": " Specify the font size in pixels used by a text mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maFontStyle",
        "comment": " Specify the font style (e.g. `italic`) used by a text mark.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maFontWeight",
        "comment": " Specify the font wight used by a text mark.\n",
        "type": "VegaLite.FontWeight -> VegaLite.MarkProperty"
      },
      {
        "name": "maHRef",
        "comment": " Specify the hyperlink to be associated with a mark. When specified, the mark\nbecomes a clickable hyperlink.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maInterpolate",
        "comment": " Specify the interpolation method used by line and area marks.\n",
        "type": "VegaLite.MarkInterpolation -> VegaLite.MarkProperty"
      },
      {
        "name": "maLine",
        "comment": " Specify the appearance of a line marker placed on the vertices of an area mark.\n",
        "type": "VegaLite.LineMarker -> VegaLite.MarkProperty"
      },
      {
        "name": "maOpacity",
        "comment": " Specify the overal opacity of a mark in the range 0 to 1.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maOrient",
        "comment": " Specify the orientation of a non-stacked bar, tick, area or line mark.\n",
        "type": "VegaLite.MarkOrientation -> VegaLite.MarkProperty"
      },
      {
        "name": "maPoint",
        "comment": " Specify the appearance of a point marker placed on the vertices of a line\nor area mark.\n",
        "type": "VegaLite.PointMarker -> VegaLite.MarkProperty"
      },
      {
        "name": "maRadius",
        "comment": " Specify the polar coordinate radial offset of a text mark from its origin.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maRule",
        "comment": " Specify the rule (main line) properties for the errorbar mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.MarkProperty"
      },
      {
        "name": "maShape",
        "comment": " Specify the shape of a point mark.\n",
        "type": "VegaLite.Symbol -> VegaLite.MarkProperty"
      },
      {
        "name": "maShortTimeLabels",
        "comment": " Specify whether or not month and weekday names are abbreviated in a text mark.\n",
        "type": "Bool -> VegaLite.MarkProperty"
      },
      {
        "name": "maSize",
        "comment": " Specify the size of a mark in square units.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStroke",
        "comment": " Specify the default stroke color of a mark.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeCap",
        "comment": " Specify the cap style of a mark's stroke.\n",
        "type": "VegaLite.StrokeCap -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeDash",
        "comment": " Specify the stroke dash style used by a mark. A stroke dash style is determined\nby an alternating 'on-off' sequence of line lengths in pixel units.\n",
        "type": "List Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeDashOffset",
        "comment": " Specify the stroke dash offset used by a mark. This is the number of pixels\nbefore which the first line dash is drawn.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeJoin",
        "comment": " Specify the line segment join style of a mark's stroke.\n",
        "type": "VegaLite.StrokeJoin -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeMiterLimit",
        "comment": " Specify the miter limit at which to bevel a join between line segments of a\nmark's stroke.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeOpacity",
        "comment": " Specify the stroke opacity of a mark in the range 0 to 1.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeWidth",
        "comment": " Specify the stroke width of a mark in pixel units.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStyle",
        "comment": " Specify the names of custom styles to apply to the mark. Each name should\nrefer to a named style defined in a separate style configuration.\n",
        "type": "List String -> VegaLite.MarkProperty"
      },
      {
        "name": "maTension",
        "comment": " Specify the interpolation tension used if interpolating line and area marks.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maText",
        "comment": " Specify the placeholder text for a text mark for when a text channel is not specified.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maTheta",
        "comment": " Specify the polar coordinate angle (clockwise from north in radians) of a\ntext mark from the origin determined by its x and y properties.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maThickness",
        "comment": " Specify the thickness of a tick mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maTicks",
        "comment": " Specify the tick properties for the errorbar mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.MarkProperty"
      },
      {
        "name": "maX2Offset",
        "comment": " Specify the x2 position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maXOffset",
        "comment": " Specify the x position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maY2Offset",
        "comment": " Specify the y2 position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maYOffset",
        "comment": " Specify the y position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "name",
        "comment": " Provides an optional name to be associated with the visualization.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "not",
        "comment": " Apply a negation Boolean operation as part of a logical composition. Boolean\noperations can be nested to any level.\n\n    not (and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\") )\n\n",
        "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp"
      },
      {
        "name": "num",
        "comment": " Specify a numeric data value. This is used when a function can accept values\nof different types.\n",
        "type": "Float -> VegaLite.DataValue"
      },
      {
        "name": "numRange",
        "comment": " Specify the minimum maximum number range to be used in data filtering.\n",
        "type": "Float -> Float -> VegaLite.FilterRange"
      },
      {
        "name": "nums",
        "comment": " Specify a list of numeric data values. This is used when a function can\naccept lists of different types.\n",
        "type": "List Float -> VegaLite.DataValues"
      },
      {
        "name": "oAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with an\norder channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.OrderChannel"
      },
      {
        "name": "oBin",
        "comment": " Discretize numeric values into bins when encoding with an order channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.OrderChannel"
      },
      {
        "name": "oMType",
        "comment": " Specify the field type (level of measurement) when encoding with an order\nchannel.\n",
        "type": "VegaLite.Measurement -> VegaLite.OrderChannel"
      },
      {
        "name": "oName",
        "comment": " Provide the name of the field used for encoding with an order channel.\nFor details, see the\n[Vega-Lite field documentation](https://vega.github.io/vega-lite/docs/field.html)\n",
        "type": "String -> VegaLite.OrderChannel"
      },
      {
        "name": "oRepeat",
        "comment": " Reference in a order channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields that are to be\nlaid out in columns or in rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.OrderChannel"
      },
      {
        "name": "oSort",
        "comment": " Specify the sort order to be used by an order channel.\n",
        "type": "List VegaLite.SortProperty -> VegaLite.OrderChannel"
      },
      {
        "name": "oTimeUnit",
        "comment": " Specify the form of time unit aggregation of field values when encoding\nwith an order channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.OrderChannel"
      },
      {
        "name": "opAs",
        "comment": " Create a named aggregation operation on a field that can be added to a transformation.\nThe first parameter is the aggregation operation to use; the second the name of\nthe field in which to apply it and the third the name to be given to this transformation.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs Min \"people\" \"lowerBound\"\n                , opAs Max \"people\" \"upperBound\"\n                ]\n                [ \"age\" ]\n\nIf the operation is `Count`, it does not apply to any specific field, so the second\nparameter can be an empty string.\n\n",
        "type": "VegaLite.Operation -> String -> String -> VegaLite.Spec"
      },
      {
        "name": "opacity",
        "comment": " Encode an opacity channel.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "or",
        "comment": " Apply an 'or' Boolean operation as part of a logical composition.\n",
        "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"
      },
      {
        "name": "order",
        "comment": " Encode an order channel. The first parameter is a list of order field definitions\nto define the channel. The second is a list of channels to which this is to be added.\n",
        "type": "List VegaLite.OrderChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "pAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nposition channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.PositionChannel"
      },
      {
        "name": "pAxis",
        "comment": " Specify the axis properties used when encoding with a position channel. To\nprevent an axis from appearing, provide an empty list of axis properties.\n",
        "type": "List VegaLite.AxisProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pBin",
        "comment": " Discretize numeric values into bins when encoding with a position channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pHeight",
        "comment": " Set the position to the height of the enclosing data space. Useful for placing\na mark relative to the bottom edge of a view.\n",
        "type": "VegaLite.PositionChannel"
      },
      {
        "name": "pMType",
        "comment": " Specify the field type (level of measurement) when encoding with a position\nchannel.\n",
        "type": "VegaLite.Measurement -> VegaLite.PositionChannel"
      },
      {
        "name": "pName",
        "comment": " Provide the name of the field used for encoding with a position channel.\n",
        "type": "String -> VegaLite.PositionChannel"
      },
      {
        "name": "pRepeat",
        "comment": " Provide the name of the fields from a repeat operator used for encoding\nwith a position channel.\n",
        "type": "VegaLite.Arrangement -> VegaLite.PositionChannel"
      },
      {
        "name": "pScale",
        "comment": " Specify the scaling applied to a field when encoding with a position channel.\nThe scale will transform a field's value into a position along one axis.\n",
        "type": "List VegaLite.ScaleProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pSort",
        "comment": " Specify the sort order for field when encoding with a position channel.\n",
        "type": "List VegaLite.SortProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pStack",
        "comment": " Specify the type of stacking offset for field when encoding with a position\nchannel.\n",
        "type": "VegaLite.StackProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pTimeUnit",
        "comment": " Specify the form of time unit aggregation of field values when encoding\nwith a position channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.PositionChannel"
      },
      {
        "name": "pTitle",
        "comment": " Specify the title of a field when encoding with a position channel. If an axis\ntitle is defined, it will override any title defined here.\n",
        "type": "String -> VegaLite.PositionChannel"
      },
      {
        "name": "pWidth",
        "comment": " Set the position to the width of the enclosing data space. Useful for justifying\na mark to the right hand edge of a view. For example to position a mark at the\nright of the data rectangle:\n\n    enc =\n        encoding\n            << position X [ pWidth ]\n\n",
        "type": "VegaLite.PositionChannel"
      },
      {
        "name": "paEdges",
        "comment": " Specify padding around a visualization in pixel units. The four parameters\nrefer to _left_, _top_, _right_, and _bottom_ edges respectively.\n",
        "type": "Float -> Float -> Float -> Float -> VegaLite.Padding"
      },
      {
        "name": "paSize",
        "comment": " Specify a uniform padding around a visualization in pixel units.\n",
        "type": "Float -> VegaLite.Padding"
      },
      {
        "name": "padding",
        "comment": " Set the padding around the visualization in pixel units. The way padding is\ninterpreted will depend on the `autosize` properties.\n",
        "type": "VegaLite.Padding -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "parse",
        "comment": " Specify the parsing rules when processing some data text. The parameter is\na list of tuples in the form (_fieldname_, _datatype_). If an empty list is provided,\ntype inference is based on the data.\n",
        "type": "List ( String, VegaLite.DataType ) -> VegaLite.Format"
      },
      {
        "name": "pmMarker",
        "comment": " Specify the properties of a point marker that is overlaid on a line or area\nmark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.PointMarker"
      },
      {
        "name": "point",
        "comment": " Specify a [point mark](https://vega.github.io/vega-lite/docs/point.html) for\nsymbolising a data point with a symbol.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "position",
        "comment": " Encode a position channel. The first parameter identifies the channel,\nthe second a list of qualifying options. Usually these will include at least the\nname of the data field associated with it and its measurement type (either the field\nname directly, or a reference to a row / column repeat field). The final parameter\nis a list of any previous channels to which this should be added.\n\n      enc =\n          encoding\n            << position X [ pName \"Animal\", pMType Ordinal ]\n\n",
        "type": "VegaLite.Position -> List VegaLite.PositionChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "prCenter",
        "comment": " Specify a projectionâs center as longitude and latitude in degrees. The default\nvalue is `0,0`.\n",
        "type": "Float -> Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prClipAngle",
        "comment": " Specify a projectionâs clipping circle radius to the specified angle in degrees.\nA value of `Nothing` will switch to antimeridian cutting rather than small-circle\nclipping.\n",
        "type": "Maybe.Maybe Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prClipExtent",
        "comment": " Specify a projectionâs viewport clip extent to the specified bounds in pixels.\n",
        "type": "VegaLite.ClipRect -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prCoefficient",
        "comment": " Specify a 'Hammer' map projection coefficient.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prDistance",
        "comment": " Specify a 'Satellite' map projection distance.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prFraction",
        "comment": " Specify a `Bottomley` map projection fraction.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prLobes",
        "comment": " Specify the number of lobes in lobed map projections such as the 'Berghaus star'.\n",
        "type": "Int -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prParallel",
        "comment": " Specify a parallel for map projections such as the 'Armadillo'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prPrecision",
        "comment": " Specify a threshold for the projectionâs adaptive resampling in pixels.\nCorresponds to the DouglasâPeucker distance. If precision is not specified, the\nprojectionâs current resampling precision which defaults to â0.5 â 0.70710 is used.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prRadius",
        "comment": " Specify a radius value for map projections such as the 'Gingery'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prRatio",
        "comment": " Specify a ratio value for map projections such as the 'Hill'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prRotate",
        "comment": " Specify a projectionâs three-axis rotation angle. This should be in order\n_lambda phi gamma_ specifying the rotation angles in degrees about each\nspherical axis (corresponding to yaw, pitch and roll.).\n",
        "type": "Float -> Float -> Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prSpacing",
        "comment": " Specify a spacing value for map projections such as the 'Lagrange'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prTilt",
        "comment": " Specify a 'Satellite' map projection tilt.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prType",
        "comment": " Specify the type of global map projection.\n",
        "type": "VegaLite.Projection -> VegaLite.ProjectionProperty"
      },
      {
        "name": "projection",
        "comment": " Sets the cartographic projection used for geospatial coordinates. A projection\ndefines the mapping from _(longitude, latitude)_ to an _(x, y)_ plane used for rendering.\nUseful when using [geoshape](#geoshape).\n",
        "type": "List VegaLite.ProjectionProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "raName",
        "comment": " Specify the name of a pre-defined scale range (e.g. `symbol` or `diverging`).\n",
        "type": "String -> VegaLite.ScaleRange"
      },
      {
        "name": "raNums",
        "comment": " Specify a numeric scale range. Depending on the scaling this may be a min,max\npair, or a list of explicit numerical values.\n",
        "type": "List Float -> VegaLite.ScaleRange"
      },
      {
        "name": "raStrs",
        "comment": " Specify a text scale range for discrete scales.\n",
        "type": "List String -> VegaLite.ScaleRange"
      },
      {
        "name": "racoCategory",
        "comment": " Specify the default color scheme for categorical ranges.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoDiverging",
        "comment": " Specify the default diverging color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoHeatmap",
        "comment": " Specify the default 'heatmap' color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoOrdinal",
        "comment": " Specify the default ordinal color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoRamp",
        "comment": " Specify the default ramp (contnuous) color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoSymbol",
        "comment": " Specify the default color scheme symbols.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "reAxis",
        "comment": " Specify how a channel's axes should be resolved when defined in more\nthan one view in a composite visualization.\n",
        "type": "List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
      },
      {
        "name": "reLegend",
        "comment": " Specify how a channel's legends should be resolved when defined in more\nthan one view in a composite visualization.\n",
        "type": "List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
      },
      {
        "name": "reScale",
        "comment": " Specify how a channel's scales should be resolved when defined in more\nthan one view in a composite visualization.\n",
        "type": "List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
      },
      {
        "name": "rect",
        "comment": " Specify a [rectangle mark](https://vega.github.io/vega-lite/docs/rect.html).\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "repeat",
        "comment": " Define the fields that will be used to compose rows and columns of a set of\nsmall multiples. This is used where the encoding of the visualization in small\nmultiples is largely identical, but the data field used in each might vary. When\na list of fields is identified with `repeat` you also need to define a full specification\nto apply to each of those fields using `asSpec`.\n\n    spec = ...\n    toVegaLite\n        [ repeat [ columnFields [ \"Cat\", \"Dog\", \"Fish\" ] ]\n        , specification (asSpec spec)\n        ]\n\n",
        "type": "List VegaLite.RepeatFields -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "resolution",
        "comment": " Define a single resolution option to be applied when scales, axes or legends\nin composite views share channel encodings. This allows, for example, two different\ncolor encodings to be created in a layered view, which would otherwise share color\nchannels between layers. Each resolution rule should be in a tuple pairing the channel\nto which it applies and the rule type. The first parameter identifies the type of\nresolution, the second a list of resolutions to which this may be added.\n\n    resolve\n        << resolution (reScale [ ( ChY, Independent ) ])\n\n",
        "type": "VegaLite.Resolve -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "resolve",
        "comment": " Determine whether scales, axes or legends in composite views should share channel\nencodings.\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "rgb",
        "comment": " Specify an RGB color interpolation for continuous color scales. The parameter\nis the gamma value to use in interpolation (anchored at 1).\n",
        "type": "Float -> VegaLite.CInterpolate"
      },
      {
        "name": "row",
        "comment": " Encode a new facet to be arranged in rows. The first parameter is a list of\nfacet properties that define the faceting channel. This should include at least\nthe name of data the field and its measurement type. The final parameter is a list\nof any channels to which this is to be added.\n",
        "type": "List VegaLite.FacetChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "rowBy",
        "comment": " Specify the mapping between a row and its field definitions in a set of\nfaceted small multiples.\n",
        "type": "List VegaLite.FacetChannel -> VegaLite.FacetMapping"
      },
      {
        "name": "rowFields",
        "comment": " Create a list of fields to use in set of repeated small multiples arranged in\nrows. The list of fields named here can be referenced in an encoding with\n`pRepeat Row`, `mRepeat Row` etc.\n",
        "type": "List String -> VegaLite.RepeatFields"
      },
      {
        "name": "rule",
        "comment": " Specify a [rule line](https://vega.github.io/vega-lite/docs/rule.html) connecting\ntwo vertices. Can be used to span either the entire width or height of a view, or\nto connect two arbitrary positions.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "sacoBandPaddingInner",
        "comment": " Specify the default inner padding for x and y band-ordinal scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoBandPaddingOuter",
        "comment": " Specify the default outer padding for x and y band-ordinal scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoClamp",
        "comment": " Specify whether or not by default values that exceed the data domain are\nclamped to the min/max range value.\n",
        "type": "Bool -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxBandSize",
        "comment": " Specify the default maximum value for mapping quantitative fields to a bar's\nsize/bandSize.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxFontSize",
        "comment": " Specify the default maximum value for mapping a quantitative field to a text\nmark's size.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxOpacity",
        "comment": " Specify the default maximum opacity (in the range [0, 1]) for mapping a field\nto opacity.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxSize",
        "comment": " Specify the default maximum size for point-based scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxStrokeWidth",
        "comment": " Specify the default maximum stroke width for rule, line and trail marks.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinBandSize",
        "comment": " Specify the default minimum value for mapping quantitative fields to a bar's\nsize/bandSize.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinFontSize",
        "comment": " Specify the default minimum value for mapping a quantitative field to a text\nmark's size.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinOpacity",
        "comment": " Specify the default minimum opacity (in the range [0, 1]) for mapping a field\nto opacity.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinSize",
        "comment": " Specify the default minimum size for point-based scales (when not forced to\nstart at zero).\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinStrokeWidth",
        "comment": " Specify the default minimum stroke width for rule, line and trail marks.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoPointPadding",
        "comment": " Specify the default padding for point-ordinal scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoRangeStep",
        "comment": " Specify the default range step for band and point scales when the mark is\nnot text.\n",
        "type": "Maybe.Maybe Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoRound",
        "comment": " Specify whether or not by default numeric values are rounded to integers\nwhen scaling. Useful for snapping to the pixel grid.\n",
        "type": "Bool -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoTextXRangeStep",
        "comment": " Specify the default range step for x band and point scales of text marks.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoUseUnaggregatedDomain",
        "comment": " Specify whether or not to use the source data range before aggregation.\n",
        "type": "Bool -> VegaLite.ScaleConfig"
      },
      {
        "name": "scClamp",
        "comment": " Specify that when scaling, values outside the data domain are clamped to the\nminimum or maximum value.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "scDomain",
        "comment": " Specify a custom scaling domain.\n",
        "type": "VegaLite.ScaleDomain -> VegaLite.ScaleProperty"
      },
      {
        "name": "scInterpolate",
        "comment": " Specify an interpolation method for scaling range values.\n",
        "type": "VegaLite.CInterpolate -> VegaLite.ScaleProperty"
      },
      {
        "name": "scNice",
        "comment": " Specify 'nice' minimum and maximum values in a scaling (e.g. multiples of 10).\n",
        "type": "VegaLite.ScaleNice -> VegaLite.ScaleProperty"
      },
      {
        "name": "scNiceInterval",
        "comment": " Specify the 'nice' temporal interval values when scaling.\n",
        "type": "VegaLite.TimeUnit -> Int -> VegaLite.ScaleNice"
      },
      {
        "name": "scNiceTickCount",
        "comment": " Specify the desired number of tick marks in a 'nice' scaling.\n",
        "type": "Int -> VegaLite.ScaleNice"
      },
      {
        "name": "scPadding",
        "comment": " Specify the padding in pixels to apply to a scaling.\n",
        "type": "Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scPaddingInner",
        "comment": " Specify the inner padding in pixels to apply to a band scaling.\n",
        "type": "Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scPaddingOuter",
        "comment": " Specify the outer padding in pixels to apply to a band scaling.\n",
        "type": "Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scRange",
        "comment": " Specify the range of a scaling. The type of range depends on the encoding\nchannel.\n",
        "type": "VegaLite.ScaleRange -> VegaLite.ScaleProperty"
      },
      {
        "name": "scRangeStep",
        "comment": " Specify the distance in pixels between the starts of adjacent bands in a band\nscaling. If `Nothing` is provided the distance is determined automatically.\n",
        "type": "Maybe.Maybe Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scReverse",
        "comment": " Reverse the order of a scaling.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "scRound",
        "comment": " Specify whether or not numeric values in a scaling are rounded to integers.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "scScheme",
        "comment": " Specify the color scheme used by a color scaling.\n",
        "type": "String -> List Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scType",
        "comment": " Specify the type of scaling to apply.\n",
        "type": "VegaLite.Scale -> VegaLite.ScaleProperty"
      },
      {
        "name": "scZero",
        "comment": " Specify whether or not a numeric scaling should be forced to include a zero\nvalue.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "seBind",
        "comment": " Specify a binding to some input elements as part of a named selection.\n",
        "type": "List VegaLite.Binding -> VegaLite.SelectionProperty"
      },
      {
        "name": "seEncodings",
        "comment": " Specify a encoding channels that form a named selection.\n",
        "type": "List VegaLite.Channel -> VegaLite.SelectionProperty"
      },
      {
        "name": "seFields",
        "comment": " Specify the field names for projecting a selection.\n",
        "type": "List String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seNearest",
        "comment": " Specify whether or not a selection should capture nearest marks to a pointer\nrather than an exact position match. This allows 'accelerated' selection for\ndiscrete marks.\n",
        "type": "Bool -> VegaLite.SelectionProperty"
      },
      {
        "name": "seOn",
        "comment": " Specify a [Vega event stream](https://vega.github.io/vega/docs/event-streams)\nthat triggers a selection.\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seResolve",
        "comment": " Specify a strategy that determines how selectionsâ data queries are resolved\nwhen applied in a filter transform, conditional encoding rule, or scale domain.\n",
        "type": "VegaLite.SelectionResolution -> VegaLite.SelectionProperty"
      },
      {
        "name": "seSelectionMark",
        "comment": " Specify the appearance of an interval selection mark (dragged rectangle).\n",
        "type": "List VegaLite.SelectionMarkProperty -> VegaLite.SelectionProperty"
      },
      {
        "name": "seToggle",
        "comment": " Specify a predicate expression that determines a toggled selection.\nSee the\n[Vega-Lite toggle documentation](https://vega.github.io/vega-lite/docs/toggle.html)\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seTranslate",
        "comment": " Specify a translation selection transformation used for panning a view.\nSee the\n[Vega-Lite translate documentation](https://vega.github.io/vega-lite/docs/translate.html)\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seZoom",
        "comment": " Specify a zooming selection transformation used for zooming a view.\nSee the\n[Vega-Lite zoom documentation](https://vega.github.io/vega-lite/docs/zoom.html)\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "select",
        "comment": " Create a single named selection that may be applied to a data query or transformation.\nThe first two parameters specify the name to be given to the selection for later\nreference and the type of selection made. The third allows additional selection options to\nbe specified. The fourth is a list of selections to which this is added.\n",
        "type": "String -> VegaLite.Selection -> List VegaLite.SelectionProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "selected",
        "comment": " Provide an interactive selection that will be true or false as part of a\nlogical composition. For example, to filter a dataset so that only items selected\ninteractively and that have a weight of more than 30:\n\n    transform\n        << filter (fCompose (and (selected \"brush\") (expr \"datum.weight > 30\")))\n\n",
        "type": "String -> VegaLite.BooleanOp"
      },
      {
        "name": "selection",
        "comment": " Create a full selection specification from a list of selections.\n\n    sel =\n        selection\n            << select \"view\" Interval [ BindScales ] []\n            << select \"myBrush\" Interval []\n            << select \"myPaintbrush\" Multi [ On \"mouseover\", Nearest True ]\n\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "selectionName",
        "comment": " Provide the name of a selection that is used as part of a conditional encoding.\n\n    color\n        [ mSelectionCondition ( selectionName \"myBrush\" )\n            [ mName \"myField\", mMType Nominal ]\n            [ mStr \"grey\" ]\n        ]\n\n",
        "type": "String -> VegaLite.BooleanOp"
      },
      {
        "name": "shape",
        "comment": " Encode a shape channel.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "size",
        "comment": " Encode a size channel. The first parameter is a list of mark channel properties\nthat characterise the way a data field is encoded by size. The second is a list of\nchannels to which this should be added.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "smFill",
        "comment": " Specify the fill color of the interval selection mark (dragged rectangular area).\n",
        "type": "String -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smFillOpacity",
        "comment": " Specify the fill opacity of the interval selection mark (dragged rectangular area)\nin the range [0, 1].\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStroke",
        "comment": " Specify the stroke color of the interval selection mark (dragged rectangular area).\n",
        "type": "String -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeDash",
        "comment": " Specify the stroke dash style of the interval selection mark (dragged\nrectangular area).\n",
        "type": "List Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeDashOffset",
        "comment": " Specify the stroke dash offset of the interval selection mark (dragged\nrectangular area).\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeOpacity",
        "comment": " Specify the stroke opacity of the interval selection mark (dragged rectangular\narea) in the range [0, 1].\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeWidth",
        "comment": " Specify the stroke width of the interval selection mark (dragged rectangular\narea).\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "soByField",
        "comment": " Specify a sorting by the aggregated summary of a given field using a given\naggregation operation. For example, the following sorts the categorical data\nfield `variety` by the mean age of the data in each variety category.\n\n    position Y [ pName \"variety\"\n               , pMType Ordinal\n               , pSort [ soByField \"age\" Mean, Descending ]\n               ]\n\n",
        "type": "String -> VegaLite.Operation -> VegaLite.SortProperty"
      },
      {
        "name": "soByRepeat",
        "comment": " Specify a sorting by the aggregated summaries of the given fields (referenced\nby a repeat iteration) using a given aggregation operation.\n",
        "type": "VegaLite.Arrangement -> VegaLite.Operation -> VegaLite.SortProperty"
      },
      {
        "name": "soCustom",
        "comment": " Provide a custom sort order by listing data values explicitly. This can be\nused in place of lists of [SortProperty](#SortProperty).\n",
        "type": "VegaLite.DataValues -> VegaLite.SortProperty"
      },
      {
        "name": "spacing",
        "comment": " Specify the spacing between sub-views in a composition operator. This version\nsets the same spacing (in pixel units) for rows and columns.\n",
        "type": "Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "spacingRC",
        "comment": " Similar to [spacing](#spacing) but with independent spacing for rows (first\nparameter) and columns (second parameter).\n",
        "type": "Float -> Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "specification",
        "comment": " Defines a specification object for use with faceted and repeated small multiples.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"Origin\", fMType Nominal ] ]\n        , specifcation spec\n        ]\n\n",
        "type": "VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "square",
        "comment": " Specify a [square mark](https://vega.github.io/vega-lite/docs/square.html) for\nsymbolising points.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "str",
        "comment": " Specify a string data value. This is used when a function can accept values\nof different types.\n",
        "type": "String -> VegaLite.DataValue"
      },
      {
        "name": "stroke",
        "comment": " Encode a stroke channel. This acts in a similar way to encoding by `color` but\nonly affects the exterior boundary of marks. If both `stroke` and `color` encodings\nare specified, `stroke` takes precedence.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "strs",
        "comment": " Specify a string data value. This is used when a function can accept values\nof different types.\n",
        "type": "List String -> VegaLite.DataValues"
      },
      {
        "name": "symbolPath",
        "comment": " Specify a custom symbol shape with an\n[SVG path description](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n",
        "type": "String -> VegaLite.Symbol"
      },
      {
        "name": "tAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\ntext channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.TextChannel"
      },
      {
        "name": "tBin",
        "comment": " Discretize numeric values into bins when encoding with a text channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.TextChannel"
      },
      {
        "name": "tDataCondition",
        "comment": " Specify the properties of a text channel conditional on one or more predicate\nexpressions. The first parameter is a list of tuples each pairing an expression to\nevaluate with the encoding if that expression is true. The second is the encoding\nif none of the expressions are evaluated as true.\n",
        "type": "List ( VegaLite.BooleanOp, List VegaLite.TextChannel ) -> List VegaLite.TextChannel -> VegaLite.TextChannel"
      },
      {
        "name": "tFormat",
        "comment": " Provide a [formatting pattern](https://vega.github.io/vega-lite/docs/format.html)\nfor a field when encoding with a text channel.\n",
        "type": "String -> VegaLite.TextChannel"
      },
      {
        "name": "tMType",
        "comment": " Specify the field type (level of measurement) when encoding with a text\nchannel.\n",
        "type": "VegaLite.Measurement -> VegaLite.TextChannel"
      },
      {
        "name": "tName",
        "comment": " Provide the name of the field used for encoding with a text channel.\n",
        "type": "String -> VegaLite.TextChannel"
      },
      {
        "name": "tRepeat",
        "comment": " Reference in a text channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields that are to be\nlaid out in columns or in rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.TextChannel"
      },
      {
        "name": "tSelectionCondition",
        "comment": " Specify the properties of a text channel conditional on interactive selection.\nThe first parameter is a selection condition to evaluate; the second the encoding\nto apply if that selection is true; the third parameter is the encoding if the\nselection is false.\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.TextChannel -> List VegaLite.TextChannel -> VegaLite.TextChannel"
      },
      {
        "name": "tTimeUnit",
        "comment": " Specify the form of time unit aggregation of field values when encoding with\na text channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.TextChannel"
      },
      {
        "name": "tTitle",
        "comment": " Specify the title of a field when encoding with a text or tooltip channel.\nIf an axis or legend title is defined, it will override any title defined\nhere.\n",
        "type": "String -> VegaLite.TextChannel"
      },
      {
        "name": "text",
        "comment": " Encode a text channel.\n",
        "type": "List VegaLite.TextChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "textMark",
        "comment": " Specify a [text mark](https://vega.github.io/vega-lite/docs/text.html) to be\ndisplayed at some point location.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "tick",
        "comment": " Specify a short line ([tick](https://vega.github.io/vega-lite/docs/tick.html))\nmark for symbolising point locations.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "ticoAnchor",
        "comment": " Specify the default anchor position when placing titles.\n",
        "type": "VegaLite.APosition -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoAngle",
        "comment": " Specify the default angle when orientating titles.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoBaseline",
        "comment": " Specify the default vertical alignment when placing titles.\n",
        "type": "VegaLite.VAlign -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoColor",
        "comment": " Specify the default color when showing titles.\n",
        "type": "String -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoFont",
        "comment": " Specify the default font when showing titles.\n",
        "type": "String -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoFontSize",
        "comment": " Specify the default font size when showing titles.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoFontWeight",
        "comment": " Specify the default font weight when showing titles.\n",
        "type": "VegaLite.FontWeight -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoLimit",
        "comment": " Specify the default maximim length in pixel units when showing titles.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoOffset",
        "comment": " Specify the default offset in pixel units of titles relative to the chart body.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoOrient",
        "comment": " Specify the default placement of titles relative to the chart body.\n",
        "type": "VegaLite.Side -> VegaLite.TitleConfig"
      },
      {
        "name": "timeUnitAs",
        "comment": " Create a new data field based on the given temporal binning. Unlike the\ndirect encoding binning, this transformation is named and so can be referred\nto in multiple encodings. The first parameter is the 'width' of each temporal bin,\nthe second is the field to bin and the third is name to give the newly binned\nfield. The third is a list of transformations to which this is added.\n\nIt is usually easer to apply temporal binning directly as part of the encoding\nas this will automatically format the temporal axis. See the\n\nThe following example takes a temporal dataset and encodes daily totals from it\ngrouping by month.\n\n    trans =\n        transform << timeUnitAs Month \"date\" \"monthly\"\n\n    enc =\n        encoding\n            << position X [ pName \"date\", pMType Temporal, pTimeUnit Day ]\n            << position Y [ pAggregate Sum, pMType Quantitative ]\n            << detail [ dName \"monthly\", dMType Temporal ]\n\n",
        "type": "VegaLite.TimeUnit -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "title",
        "comment": " Provide an optional title to be displayed in the visualization.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "toVegaLite",
        "comment": " Convert a list of Vega-Lite specifications into a single JSON object that may be\npassed to Vega-Lite for graphics generation. Commonly these will include at least\ndata, mark and encoding specifications.\n\nWhile simple functions like `bar` may be provided directly, it is usually clearer\nto label more complex ones such as encodings as separate expressions.\n\nSpecifications can be built up by chaining functions such as `dataColumn` or\n`position`. Functional composition using the `<<` operator allows this to be done\ncompactly.\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"a\" (strs [ \"C\", \"C\", \"D\", \"E\" ])\n                << dataColumn \"b\" (nums [ 2, 7, 1, 2 ])\n\n        enc =\n            encoding\n                << position X [ pName \"a\", pMType Nominal ]\n                << position Y [ pName \"b\", pMType Quantitative, pAggregate Mean ]\n    in\n    toVegaLite [ data [], bar [], enc [] ]\n\n",
        "type": "List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"
      },
      {
        "name": "tooltip",
        "comment": " Encode a tooltip channel. To encode multiple tooltip values with a mark, use\n[tooltips](#tooltips).\n",
        "type": "List VegaLite.TextChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "tooltips",
        "comment": " Encode a tooltip channel with multiple tooltips. The first parameter is a\nlist of the multiple tooltips, each of which is a list of text channel properties\nthat define the channel. The second is a list of channels to which this is to be added.\n",
        "type": "List (List VegaLite.TextChannel) -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "topojsonFeature",
        "comment": " Specify a topoJSON feature format extracting the object with the given name.\n",
        "type": "String -> VegaLite.Format"
      },
      {
        "name": "topojsonMesh",
        "comment": " Specify a topoJSON mesh format extracting the object with the given name.\nUnlike the `topojsonFeature`, the corresponding geo data are returned as a single\nunified mesh, not as individual GeoJSON features.\n",
        "type": "String -> VegaLite.Format"
      },
      {
        "name": "trail",
        "comment": " Specify a [trail mark](https://vega.github.io/vega-lite/docs/trail.html) (line\nwith variable width along its length).\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "transform",
        "comment": " Create a single transform from a list of transformation specifications. The\norder of transformations can be important, e.g. labels created with [calculateAs](#calculateas),\n[timeUnitAs](#timeUnitAs) and [binAs](#binAs) that are used in other transformations.\nUsing the functional composition pipeline idiom (as example below) allows you to\nprovide the transformations in the order intended in a clear manner.\n\n    trans =\n        transform\n            << filter (fiExpr \"datum.year == 2010\")\n            << calculateAs \"datum.sex == 2 ? 'Female' : 'Male'\" \"gender\"\n\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "true",
        "comment": " A true value used for functions that can accept a Boolean literal or a\nreference to something that generates a Boolean value. This is a convenience\nfunction equivalent to `boo True`\n",
        "type": "VegaLite.DataValue"
      },
      {
        "name": "utc",
        "comment": " Provides a UTC version of a given a time (coordinated universal time, independent\nof local time zones or daylight saving).\nFor example,\n\n    encoding\n        << position X [ pName \"date\", pMType Temporal, pTimeUnit (utc YearMonthDateHours) ]\n\n",
        "type": "VegaLite.TimeUnit -> VegaLite.TimeUnit"
      },
      {
        "name": "vConcat",
        "comment": " Assigns a list of specifications to be juxtaposed vertically in a visualization.\n",
        "type": "List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "vicoClip",
        "comment": " Specify whether or not by default single views should be clipped.\n",
        "type": "Bool -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoFill",
        "comment": " Specify the default fill color for single views.\n",
        "type": "Maybe.Maybe String -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoFillOpacity",
        "comment": " Specify the default fill opacity for single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoHeight",
        "comment": " Specify the default height of single views (e.g. each view in a trellis plot).\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStroke",
        "comment": " Specify the default stroke color for single views. If `Nothing` is provided,\nno strokes are drawn around the view.\n",
        "type": "Maybe.Maybe String -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeDash",
        "comment": " Specify the default stroke dash style for single views.\n",
        "type": "List Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeDashOffset",
        "comment": " Specify the default stroke dash offset for single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeOpacity",
        "comment": " Specify the default stroke opacity for single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeWidth",
        "comment": " Specify the default stroke width of single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoWidth",
        "comment": " Specify the default width of single views (e.g. each view in a trellis plot).\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "wiAggregateOp",
        "comment": " Specify an aggregrate operation as part of a window transformation.\n",
        "type": "VegaLite.Operation -> VegaLite.Window"
      },
      {
        "name": "wiAscending",
        "comment": " Specify that the given field should be sorted in ascending order when performing\na window transform.\n",
        "type": "String -> VegaLite.WindowSortField"
      },
      {
        "name": "wiDescending",
        "comment": " Specify that the given field should be sorted in descending order when performing\na window transform.\n",
        "type": "String -> VegaLite.WindowSortField"
      },
      {
        "name": "wiField",
        "comment": " Specify an data field for which to compute an operation. This is not needed\nfor operations that do not apply to fields such as `Count`, `Rank` and `DenseRank`.\n",
        "type": "String -> VegaLite.Window"
      },
      {
        "name": "wiFrame",
        "comment": " Specify a sliding window for use by a window transform. The two parameters\nshould either be `Just` a number indicating the offset from the current data object,\nor `Nothing` to indicate unbounded rows preceding or following the current data object.\nThe default value is equivalent to `Nothing (Just 0)`, indicating that the sliding\nwindow includes the current object and all preceding objects.\n",
        "type": "Maybe.Maybe Int -> Maybe.Maybe Int -> VegaLite.WindowProperty"
      },
      {
        "name": "wiGroupBy",
        "comment": " Specify the data fields for partioning data objects in a window transform\ninto separate windows. If unspecified, all points will be in a single group.\n",
        "type": "List String -> VegaLite.WindowProperty"
      },
      {
        "name": "wiIgnorePeers",
        "comment": " Specify whether or not the sliding window frame in a window transform should\nignore peer values (those considered identical by the sort criteria). The default\nis false, causing the window frame to expand to include all peer values. If set\nto be true, the window frame will be defined by offset values only.\n",
        "type": "Bool -> VegaLite.WindowProperty"
      },
      {
        "name": "wiOp",
        "comment": " Specify a window-specific operation as part of a window transformation.\n",
        "type": "VegaLite.WindowOperation -> VegaLite.Window"
      },
      {
        "name": "wiParam",
        "comment": " Specify the numeric parameter for those window-only operations that can be\nparameterised (`Ntile`, `Lag`, `Lead` and `NthValue`).\n",
        "type": "Int -> VegaLite.Window"
      },
      {
        "name": "wiSort",
        "comment": " Specify a comparator for sorting data objects within a window transform. If\ntwo data objects are considered equal by the comparator, they are considered `peer`\nvalues of equal rank. If not specified, data objects are processed in the order\nthey are observed and none are considered peers.\n",
        "type": "List VegaLite.WindowSortField -> VegaLite.WindowProperty"
      },
      {
        "name": "width",
        "comment": " Override the default width of the visualization. If not specified the width\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "windowAs",
        "comment": " Specify a window transform to be added to a list of data stream transformations.\nIt performs calculations over sorted groups of data objects such as ranking, lead/lag\nanalysis, running sums and averages.\n\nThe first parameter is the name to give the transformed output. The second is the\nwindow transform field definition and the third the window transform definition.\n\n    trans =\n        transform\n            << windowAs \"TotalTime\"\n                [ wiAggregateOp Sum, wiField \"Time\" ]\n                [ wiFrame Nothing Nothing ]\n\n",
        "type": "String -> List VegaLite.Window -> List VegaLite.WindowProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]