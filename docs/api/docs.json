[{"name":"Vega","comment":" Create Vega visualization specifications in Elm. This package allows you to\ngenerate the JSON specs that may be passed to the Vega runtime library to activate\nthe visualization.\n\n1.  [Creating a specification](#1-creating-a-vega-specification)\n2.  [Passing values into a specification](#2-passing-values-into-a-vega-specification)\n3.  [Specifying input data](#3-specifying-input-data)\n4.  [Transforming data](#4-transforming-data)\n5.  [Signals, triggers and interaction events](#5-signals-triggers-and-interaction-events)\n6.  [Scales](#6-scales)\n7.  [Layout composition](#7-layout-composition)\n8.  [Map projections](#8-map-projections)\n9.  [Titles](#9-titles)\n10. [Axes](#10-axes)\n11. [Legends](#11-legends)\n12. [Marks](#12-marks)\n13. [Configuration](#13-configuration)\n14. [Supplementary Properties](#14-supplementary-properties)\n15. [Type Reference](#15-type-reference)\n\n---\n\n\n# 1. Creating A Vega Specification\n\n@docs toVega\n@docs combineSpecs\n\n@docs VProperty\n\n---\n\n\n# 2. Passing Values into a Vega Specification\n\nData types such as numbers, strings and Booleans are generated by functions. For\nexample, _expressions_ generate new values based on operations applied to\nexisting ones; _fields_ reference a column of a data table; _signals_\nrespond dynamically to data or interaction.\n\n  - [2.1 Numbers](#2-1-numbers)\n  - [2.2 Strings](#2-2-strings)\n  - [2.3 Booleans](#2-3-booleans)\n  - [2.4 Generic values](#2-4-generic-values)\n  - [2.5 Indirect references](#2-5-indirect-references)\n  - [2.6 Thematic Data Types](#2-6-thematic-data-types)\n\n\n## 2.1 Numbers\n\n@docs num\n@docs nums\n@docs numSignal\n@docs numSignals\n@docs numExpr\n@docs numList\n@docs numNull\n\n\n## 2.2 Strings\n\n@docs str\n@docs strs\n@docs strSignal\n@docs strSignals\n@docs strExpr\n@docs strNull\n\n\n## 2.3 Booleans\n\n@docs true\n@docs false\n@docs boos\n@docs booSignal\n@docs booSignals\n@docs booExpr\n\n\n## 2.4 Generic Values\n\nUsed by functions that expect values of mixed types.\n\n@docs vNum\n@docs vNums\n@docs vStr\n@docs vStrs\n@docs vTrue\n@docs vFalse\n@docs vBoos\n@docs vSignal\n@docs vField\n@docs vBand\n@docs vObject\n@docs keyValue\n@docs vValues\n@docs ifElse\n@docs vNull\n@docs vMultiply\n@docs vExponent\n@docs vOffset\n@docs vRound\n@docs vScale\n@docs vScaleField\n\n\n## 2.5 Indirect References\n\nSee the\n[Vega field value documentation](https://vega.github.io/vega/docs/types/#FieldValue).\n\n@docs field\n@docs fSignal\n@docs fExpr\n@docs fDatum\n@docs fGroup\n@docs fParent\n@docs expr\n@docs exField\n\n\n## 2.6 Thematic Data Types\n\n\n### Temporal\n\n@docs year\n@docs quarter\n@docs month\n@docs date\n@docs week\n@docs day\n@docs dayOfYear\n@docs hour\n@docs minute\n@docs second\n@docs millisecond\n@docs tuSignal\n\n\n### Color\n\n@docs vColor\n@docs cHCL\n@docs cHSL\n@docs cLAB\n@docs cRGB\n\n@docs vGradient\n@docs grLinear\n@docs grRadial\n@docs grX1\n@docs grY1\n@docs grX2\n@docs grY2\n@docs grR1\n@docs grR2\n@docs grStops\n\n@docs vGradientScale\n@docs grStart\n@docs grStop\n@docs grCount\n\n---\n\n\n# 3. Specifying Input Data\n\nSee the [Vega data](https://vega.github.io/vega/docs/data) and the\n[Vega data reference](https://vega.github.io/vega/docs/scales/#dataref) documentation.\n\n  - [3.1 Data sources](#3-1-data-sources)\n  - [3.2 Data sorting](#3-2-data-sorting)\n  - [3.3 Data parsing and formatting](#3-3-data-parsing-and-formatting)\n\n\n## 3.1 Data Sources\n\n@docs dataSource\n@docs data\n\n@docs dataFromColumns\n@docs dataColumn\n\n@docs dataFromRows\n@docs dataRow\n\n@docs daUrl\n@docs daFormat\n@docs daSource\n@docs daSources\n@docs daValue\n@docs daOn\n@docs daSphere\n\n@docs daDataset\n@docs daField\n@docs daFields\n@docs daValues\n@docs daSignal\n@docs daReferences\n\n\n## 3.2 Data Sorting\n\nSee the\n[Vega sort ](https://vega.github.io/vega/docs/scales/#sort) and\n[Vega type comparison](https://vega.github.io/vega/docs/types/#Compare) documentation.\n\n@docs daSort\n@docs soAscending\n@docs soDescending\n@docs soOp\n@docs soByField\n@docs soSignal\n\n@docs ascend\n@docs descend\n@docs orderSignal\n\n\n## 3.3 Data Parsing and Formatting\n\n@docs csv\n@docs tsv\n@docs dsv\n@docs arrow\n@docs json\n@docs jsonProperty\n@docs topojsonMesh\n@docs topojsonMeshExterior\n@docs topojsonMeshInterior\n@docs topojsonFeature\n@docs fpSignal\n@docs parseAuto\n@docs parse\n@docs foNum\n@docs foBoo\n@docs foDate\n@docs foUtc\n\n---\n\n\n# 4. Transforming Data\n\nApplying a transform to a data stream can filter or generate new fields in the\nstream, or derive new data streams. Pipe (`|>`) the stream into the `transform`\nfunction and specify the transform to apply via one or more of these functions.\nSee the [Vega transform documentation](https://vega.github.io/vega/docs/transforms).\n\n  - [4.1 Basic Transforms](#4-1-basic-transforms)\n  - [4.2 Spatial Transforms](#4-2-spatial-transforms)\n  - [4.3 Layout Transforms](#4-3-layout-transforms)\n  - [4.4 Hierarchy Transforms](#4-4-hierarchy-transforms)\n\n@docs transform\n\n\n## 4.1 Basic Transforms\n\n  - [Aggregation](#aggregation)\n  - [Numeric binning](#numeric-binning)\n  - [Temporal binning](#temporal-binning)\n  - [Collection](#collection)\n  - [Text pattern counting](#text-pattern-counting)\n  - [Cross product](#cross-product)\n  - [Imputing missing values](#imputing-missing-values)\n  - [Probability density functions](#probability-density-function-calculation)\n  - [Quantile calculation](#quantile-calculation)\n  - [Regression](#regression)\n  - [Range calculation](#range-calculation)\n  - [Sampling](#sampling)\n  - [Filtering](#filtering)\n  - [Flattening](#flattening)\n  - [Folding and pivoting](#folding-and-pivoting)\n  - [Deriving new fields](#deriving-new-fields)\n  - [Data generation](#data-generation)\n\n\n### Aggregation\n\nSee the\n[Vega aggregate documentation](https://vega.github.io/vega/docs/transforms/aggregate/)\n\n@docs trAggregate\n@docs agGroupBy\n@docs agFields\n@docs agOps\n@docs agAs\n@docs agCross\n@docs agDrop\n@docs agKey\n\n@docs opArgMax\n@docs opArgMin\n@docs opCI0\n@docs opCI1\n@docs opCount\n@docs opDistinct\n@docs opMax\n@docs opMean\n@docs opMedian\n@docs opMin\n@docs opMissing\n@docs opProduct\n@docs opQ1\n@docs opQ3\n@docs opStderr\n@docs opStdev\n@docs opStdevP\n@docs opSum\n@docs opValid\n@docs opVariance\n@docs opVarianceP\n@docs opSignal\n\n\n### Join Aggregation\n\nSee the\n[Vega join aggregation documentation](https://vega.github.io/vega/docs/transforms/joinaggregate/).\n\n@docs trJoinAggregate\n@docs jaGroupBy\n@docs jaFields\n@docs jaOps\n@docs jaAs\n\n\n### Numeric Binning\n\nSee the\n[Vega bin](https://vega.github.io/vega/docs/transforms/bin/) and\n[Vega dotBin](https://vega.github.io/vega/docs/transforms/dotbin/) documentation.\n\n@docs trBin\n@docs bnInterval\n@docs bnAnchor\n@docs bnMaxBins\n@docs bnBase\n@docs bnSpan\n@docs bnStep\n@docs bnSteps\n@docs bnMinStep\n@docs bnDivide\n@docs bnNice\n@docs bnSignal\n@docs bnAs\n\n@docs trDotBin\n@docs dbroupBy\n@docs dbStep\n@docs dbSmooth\n@docs dbSignal\n@docs dbAs\n\n\n### Temporal Binning\n\n@docs trTimeUnit\n@docs tbUnits\n@docs tbStep\n@docs tbTimezone\n@docs tzLocal\n@docs tzUtc\n@docs tzSignal\n@docs tbInterval\n@docs tbExtent\n@docs dtMillis\n@docs dtExpr\n@docs tbMaxBins\n@docs tbSignal\n@docs tbAs\n\nSee the\n[Vega timeUnit documentation](https://vega.github.io/vega/docs/transforms/timeunit/).\n\n\n### Collection\n\nSee the\n[Vega collect documentation](https://vega.github.io/vega/docs/transforms/collect/).\n\n@docs trCollect\n\n\n### Text Pattern Counting\n\nSee the\n[Vega count pattern documentation](https://vega.github.io/vega/docs/transforms/countpattern/).\n\n@docs trCountPattern\n@docs cpPattern\n@docs cpCase\n@docs lowercase\n@docs uppercase\n@docs mixedcase\n@docs cpStopwords\n@docs cpAs\n\n\n### Cross Product\n\nSee the\n[Vega cross-product documentation](https://vega.github.io/vega/docs/transforms/cross/).\n\n@docs trCross\n@docs crFilter\n@docs crAs\n\n\n### Imputing Missing Values\n\nSee the\n[Vega impute documentation](https://vega.github.io/vega/docs/transforms/impute/).\n\n@docs trImpute\n@docs imByMin\n@docs imByMax\n@docs imByMean\n@docs imByMedian\n@docs imByValue\n@docs imKeyVals\n@docs imMethod\n@docs imGroupBy\n@docs imValue\n\n\n### Probability Density Function Calculation\n\n\n#### One-dimensional Probability Density\n\nSee the [Vega density documentation](https://vega.github.io/vega/docs/transforms/density/).\n\n@docs trDensity\n@docs dnExtent\n@docs dnMethod\n@docs dnPdf\n@docs dnCdf\n@docs dnSignal\n@docs dnSteps\n@docs dnMinSteps\n@docs dnMaxSteps\n@docs dnAs\n\n@docs diNormal\n@docs diUniform\n@docs diKde\n@docs diMixture\n\n\n#### One-dimensional Kernel Density Estimation\n\nSee the [Vega KDE transform](https://vega.github.io/vega/docs/transforms/kde/) documentation.\n\n@docs trKde\n@docs kdGroupBy\n@docs kdCumulative\n@docs kdCounts\n@docs kdBandwidth\n@docs kdExtent\n@docs kdMinSteps\n@docs kdMaxSteps\n@docs kdResolve\n@docs reIndependent\n@docs reShared\n@docs resolveSignal\n@docs kdSteps\n@docs kdAs\n\n\n#### Two-dimensional Kernel Density Estimation\n\nSee the [Vega 2d KDE transform](https://vega.github.io/vega/docs/transforms/kde2d/) documentation.\n\n@docs trKde2d\n@docs kd2GroupBy\n@docs kd2Weight\n@docs kd2CellSize\n@docs kd2Bandwidth\n@docs kd2Counts\n@docs kd2As\n\n\n### Quantile Calculation\n\n@docs trQuantile\n@docs quGroupBy\n@docs quProbs\n@docs quStep\n@docs quAs\n\n\n### Regression\n\n@docs trRegression\n@docs reGroupBy\n@docs reMethod\n@docs reLinear\n@docs reLog\n@docs reExp\n@docs rePow\n@docs reQuad\n@docs rePoly\n@docs reSignal\n@docs reMethodValue\n@docs reOrder\n@docs reExtent\n@docs reParams\n@docs reAs\n\n@docs trLoess\n@docs lsGroupBy\n@docs lsBandwidth\n@docs lsAs\n\n\n### Sampling\n\nSee the\n[Vega sample documentation](https://vega.github.io/vega/docs/transforms/sample/).\n\n@docs trSample\n\n\n### Range calculation\n\nSee the\n[Vega extent documentation](https://vega.github.io/vega/docs/transforms/extent/).\n\n@docs trExtent\n@docs trExtentAsSignal\n\n\n### Filtering\n\nSee the Vega [filter](https://vega.github.io/vega/docs/transforms/filter/) and\n[crossfilter](https://vega.github.io/vega/docs/transforms/crossfilter/) documentation.\n\n@docs trFilter\n@docs trCrossFilter\n@docs trCrossFilterAsSignal\n@docs trResolveFilter\n\n\n### Flattening\n\n@docs trFlatten\n@docs trFlattenWithIndex\n@docs trFlattenAs\n@docs trFlattenWithIndexAs\n\n\n### Folding and Pivoting\n\nSee the Vega [fold](https://vega.github.io/vega/docs/transforms/fold/) and\n[pivot](https://vega.github.io/vega/docs/transforms/pivot/) documentation.\n\n@docs trFold\n@docs trFoldAs\n@docs trPivot\n@docs piGroupBy\n@docs piLimit\n@docs piOp\n\n\n### Deriving New Fields\n\nSee the Vega [formula](https://vega.github.io/vega/docs/transforms/formula),\n[lookup](https://vega.github.io/vega/docs/transforms/lookup/),\n[identifier](https://vega.github.io/vega/docs/transforms/identifier/),\n[project](https://vega.github.io/vega/docs/transforms/project/) and\n[window](https://vega.github.io/vega/docs/transforms/window/) documentation.\n\n@docs trFormula\n@docs trFormulaInitOnly\n\n@docs trLookup\n@docs luAs\n@docs luValues\n@docs luDefault\n\n@docs trIdentifier\n@docs trProject\n\n@docs trWindow\n@docs wnAggOperation\n@docs wnOperation\n@docs wnOperationOn\n@docs woRowNumber\n@docs woRank\n@docs woDenseRank\n@docs woPercentRank\n@docs woCumeDist\n@docs woPercentile\n@docs woLag\n@docs woLead\n@docs woFirstValue\n@docs woLastValue\n@docs woNthValue\n@docs woPrevValue\n@docs woNextValue\n@docs woSignal\n@docs wnSort\n@docs wnGroupBy\n@docs wnFrame\n@docs wnIgnorePeers\n\n\n### Data Generation\n\nSee the\n[Vega sequence documentation](https://vega.github.io/vega/docs/transforms/sequence/).\n\n@docs trSequence\n@docs trSequenceAs\n\n\n## 4.2 Spatial Transforms\n\nTransformations that work with spatial, often geographic, data.\n\n  - [Contouring](#contouring)\n  - [Rasters](#rasters)\n  - [GeoJSON transformation](#geojson-transformation)\n  - [Graticule generation](#graticule-eneration)\n  - [Voronoi diagrams](#voronoi-diagrams)\n\n\n### Contouring\n\nSee the\n[Vega isocontour documentation](https://vega.github.io/vega/docs/transforms/isocontour)\n\n@docs trIsocontour\n@docs icField\n@docs icThresholds\n@docs icLevels\n@docs icNice\n@docs icResolve\n@docs icZero\n@docs icSmooth\n@docs icScale\n@docs icTranslate\n@docs icAs\n\n\n### Rasters\n\n@docs trHeatmap\n@docs hmField\n@docs hmColor\n@docs hmOpacity\n@docs hmResolve\n@docs hmAs\n\n\n### GeoJSON transformation\n\nSee the Vega\n[geoJSON](https://vega.github.io/vega/docs/transforms/geojson/),\n[geoPoint](https://vega.github.io/vega/docs/transforms/geopoint/),\n[geoshape](https://vega.github.io/vega/docs/transforms/geoshape/) and\n[geopath](https://vega.github.io/vega/docs/transforms/geopath/) documentation.\n\n@docs trGeoShape\n@docs trGeoPath\n@docs gpField\n@docs gpPointRadius\n@docs gpAs\n@docs trGeoJson\n@docs gjFields\n@docs gjFeature\n@docs gjSignal\n\n@docs trGeoPoint\n@docs trGeoPointAs\n\n\n### Graticule Generation\n\nSee the\n[Vega graticule documentation](https://vega.github.io/vega/docs/transforms/graticule/).\n\n@docs trGraticule\n@docs grExtent\n@docs grExtentMajor\n@docs grExtentMinor\n@docs grStep\n@docs grStepMajor\n@docs grStepMinor\n@docs grField\n@docs grPrecision\n\n\n## 4.3 Layout Transforms\n\n  - [Link paths](#link-paths)\n  - [Angular layouts](#angular-layouts)\n  - [Stacked layouts](#stacked-layouts)\n  - [Force generated layouts](#force-generated-layouts)\n  - [Word cloud layouts](#word-cloud-layouts)\n\n\n### Link Paths\n\nSee the\n[Vega link path documentation](https://vega.github.io/vega/docs/transforms/linkpath/).\n\n@docs trLinkPath\n@docs lpSourceX\n@docs lpSourceY\n@docs lpTargetX\n@docs lpTargetY\n@docs lpOrient\n@docs lpShape\n@docs lpRequire\n@docs lpAs\n@docs lsLine\n@docs lsArc\n@docs lsCurve\n@docs lsDiagonal\n@docs lsOrthogonal\n@docs lsSignal\n\n\n### Angular Layouts\n\nSee the\n[Vega pie documentation](https://vega.github.io/vega/docs/transforms/pie/).\n\n@docs trPie\n@docs piField\n@docs piStartAngle\n@docs piEndAngle\n@docs piSort\n@docs piAs\n\n\n### Stacked Layouts\n\nSee the\n[Vega stack documentation](https://vega.github.io/vega/docs/transforms/stack/).\n\n@docs trStack\n@docs stField\n@docs stGroupBy\n@docs stSort\n@docs stOffset\n@docs stAs\n@docs stZero\n@docs stCenter\n@docs stNormalize\n@docs stSignal\n\n\n### Force Generated Layouts\n\nSee the\n[Vega force documentation](https://vega.github.io/vega/docs/transforms/force/).\n\n@docs trForce\n\n@docs fsStatic\n@docs fsRestart\n@docs fsIterations\n@docs fsAlpha\n@docs fsAlphaMin\n@docs fsAlphaTarget\n@docs fsVelocityDecay\n@docs fsForces\n@docs fsAs\n\n@docs foCenter\n@docs foCollide\n@docs foNBody\n@docs foLink\n@docs foX\n@docs foY\n\n@docs fpStrength\n@docs fpDistance\n@docs fpIterations\n@docs fpTheta\n@docs fpDistanceMin\n@docs fpDistanceMax\n@docs fpId\n\n\n### Voronoi Diagrams\n\nSee the\n[Vega Voronoi documentation](https://vega.github.io/vega/docs/transforms/voronoi/).\n\n@docs trVoronoi\n@docs voSize\n@docs voExtent\n@docs voAs\n\n\n### Word Cloud Layouts\n\nSee the\n[Vega wordcloud documentation](https://vega.github.io/vega/docs/transforms/wordcloud/).\n\n@docs trWordcloud\n@docs wcFont\n@docs wcFontStyle\n@docs wcFontWeight\n@docs wcFontSize\n@docs wcFontSizeRange\n@docs wcPadding\n@docs wcRotate\n@docs wcText\n@docs wcSize\n@docs wcSpiral\n@docs spArchimedean\n@docs spRectangular\n@docs spSignal\n@docs wcAs\n\n\n## 4.4 Hierarchy Transforms\n\n  - [Nesting and Stratification](#nesting-and-stratification)\n  - [Packing](#packing)\n  - [Partitioning](#partitioning)\n  - [Trees](#trees)\n  - [Tree maps](#tree-maps)\n\n\n### Nesting and Stratification\n\nSee the Vega\n[nest](https://vega.github.io/vega/docs/transforms/nest/),\n[stratify](https://vega.github.io/vega/docs/transforms/stratify/) documentation.\n\n@docs trNest\n@docs trStratify\n\n\n### Packing\n\nSee the [Vega pack documentation](https://vega.github.io/vega/docs/transforms/pack/).\n\n@docs trPack\n@docs paField\n@docs paSort\n@docs paSize\n@docs paRadius\n@docs paPadding\n@docs paAs\n\n\n### Partitioning\n\nSee the [Vega partition documentation](https://vega.github.io/vega/docs/transforms/partition/).\n\n@docs trPartition\n@docs ptField\n@docs ptSort\n@docs ptPadding\n@docs ptRound\n@docs ptSize\n@docs ptAs\n\n\n### Trees\n\nSee the Vega\n[tree](https://vega.github.io/vega/docs/transforms/tree/) and\n[tree links](https://vega.github.io/vega/docs/transforms/treelinks/) documentation.\n\n@docs trTree\n@docs teField\n@docs teSort\n@docs teMethod\n@docs meCluster\n@docs meTidy\n@docs meSignal\n@docs teSeparation\n@docs teSize\n@docs teNodeSize\n@docs teAs\n\n@docs trTreeLinks\n\n\n## Tree Maps\n\nSee the [Vega treemap documentation](https://vega.github.io/vega/docs/transforms/treemap/).\n\n@docs trTreemap\n@docs tmField\n@docs tmSort\n@docs tmMethod\n@docs tmSquarify\n@docs tmResquarify\n@docs tmBinary\n@docs tmSlice\n@docs tmDice\n@docs tmSliceDice\n@docs tmSignal\n@docs tmPadding\n@docs tmPaddingInner\n@docs tmPaddingOuter\n@docs tmPaddingTop\n@docs tmPaddingLeft\n@docs tmPaddingBottom\n@docs tmPaddingRight\n@docs tmRatio\n@docs tmRound\n@docs tmSize\n@docs tmAs\n\n---\n\n\n# 5. Signals, Triggers and Interaction Events\n\nSee the [Vega signal documentation](https://vega.github.io/vega/docs/signals)\n\n  - [5.1 Signals](#5-1-signals)\n  - [5.2 User interface inputs](#5-2-user-interface-inputs)\n  - [5.3 Event handling](#5-3-event-handling)\n  - [5.4 Triggers](#5-4-triggers)\n\n\n## 5.1 Signals\n\n@docs signals\n@docs signal\n@docs siName\n@docs siValue\n@docs siBind\n@docs siDescription\n@docs siInit\n@docs siOn\n@docs siUpdate\n@docs siReact\n@docs siPushOuter\n\n\n## 5.2 User Interface Inputs\n\nSee the [Vega signal binding documentation](https://vega.github.io/vega/docs/signals/#bind).\n\n@docs iCheckbox\n@docs iText\n@docs iNumber\n@docs iDate\n@docs iDateTimeLocal\n@docs iTime\n@docs iMonth\n@docs iWeek\n@docs iRadio\n@docs iRange\n@docs iSelect\n@docs iTel\n@docs iColor\n\n@docs inDebounce\n@docs inElement\n@docs inOptions\n@docs inLabels\n@docs inMin\n@docs inMax\n@docs inStep\n@docs inPlaceholder\n@docs inAutocomplete\n\n\n## 5.3 Event Handling\n\n  - [Event streams](#event-streams)\n  - [Event types](#event-types)\n\nSee the Vega\n[event handler documentation](https://vega.github.io/vega/docs/signals/#handlers) documentation.\n\n@docs evHandler\n@docs evUpdate\n@docs evEncode\n@docs evForce\n\n\n### Event Streams\n\nSee the Vega [event stream documentation](https://vega.github.io/vega/docs/event-streams)\n\n@docs esObject\n@docs esSignal\n@docs esMerge\n@docs esStream\n@docs esSelector\n@docs esSource\n@docs esType\n@docs esBetween\n@docs esConsume\n@docs esFilter\n@docs esDebounce\n@docs esMarkName\n@docs esMark\n@docs esThrottle\n@docs evStreamSelector\n@docs esAll\n@docs esScope\n@docs esView\n@docs esWindow\n@docs esDom\n\n\n### Event types\n\n@docs etClick\n@docs etDblClick\n@docs etDragEnter\n@docs etDragLeave\n@docs etDragOver\n@docs etKeyDown\n@docs etKeyPress\n@docs etKeyUp\n@docs etMouseDown\n@docs etMouseMove\n@docs etMouseOut\n@docs etMouseOver\n@docs etMouseUp\n@docs etMouseWheel\n@docs etTouchEnd\n@docs etTouchMove\n@docs etTouchStart\n@docs etWheel\n@docs etTimer\n\n\n## 5.4 Triggers\n\nSee the [Vega trigger documentation](https://vega.github.io/vega/docs/triggers).\n\n@docs on\n@docs trigger\n@docs tgInsert\n@docs tgRemove\n@docs tgRemoveAll\n@docs tgToggle\n@docs tgModifyValues\n\n---\n\n\n# 6. Scales\n\nThe mapping of data values to visualization channels. See the\n[Vega scale documentation](https://vega.github.io/vega/docs/scales).\n\n  - [6.1 Scale properties](#6-1-scale-properties)\n  - [6.2 Scale types](#6-2-scale-types)\n  - [6.3 Scale domains](#6-3-scale-domains)\n  - [6.4 Scale ranges](#6-4-scale-ranges)\n  - [6.5 Color scales ](#6-5-color-scales)\n  - [6.6 Scale bins](#6-6-scale-bins)\n\n@docs scales\n@docs scale\n\n\n## 6.1 Scale Properties\n\n@docs scReverse\n@docs scRound\n@docs scClamp\n@docs scPadding\n@docs scNice\n@docs scZero\n@docs scExponent\n@docs scConstant\n@docs scBase\n@docs scAlign\n@docs scDomainImplicit\n@docs scPaddingInner\n@docs scPaddingOuter\n@docs scRangeStep\n\n\n### Aligning Scales to Nice Values.\n\n'Nice' values are ones rounded for easy interpretation, such as 100,200,300.\n\n@docs niTrue\n@docs niFalse\n@docs niMillisecond\n@docs niSecond\n@docs niMinute\n@docs niHour\n@docs niDay\n@docs niWeek\n@docs niMonth\n@docs niYear\n@docs niTickCount\n@docs niInterval\n@docs niSignal\n\n\n## 6.2 Scale Types\n\n@docs scType\n\n@docs scBand\n@docs scBins\n@docs scBinOrdinal\n@docs scLinear\n@docs scLog\n@docs scSymLog\n@docs scOrdinal\n@docs scPoint\n@docs scPow\n@docs scQuantile\n@docs scQuantize\n@docs scThreshold\n@docs scSqrt\n@docs scTime\n@docs scUtc\n@docs scCustom\n@docs scSignal\n\n\n## 6.3 Scale Domains\n\nThe extent scaling input data.\n\n@docs scDomain\n@docs scDomainMax\n@docs scDomainMin\n@docs scDomainMid\n@docs scDomainRaw\n@docs doNums\n@docs doStrs\n@docs doSignal\n@docs doSignals\n@docs doData\n\n\n## 6.4 Scale Ranges\n\nThe extent of scaled values after transformation.\n\n@docs scRange\n@docs raWidth\n@docs raHeight\n@docs raSymbol\n@docs raCategory\n@docs raDiverging\n@docs raOrdinal\n@docs raRamp\n@docs raHeatmap\n\n@docs raNums\n@docs raStrs\n@docs raValues\n@docs raSignal\n@docs raScheme\n@docs raData\n@docs raStep\n@docs raCustomDefault\n\n\n## 6.5 Color Scales\n\nSee the Vega [Vega color scale](https://vega.github.io/vega/docs/scales/#properties)\nand [color scheme](https://vega.github.io/vega/docs/schemes/) documentation.\n\n@docs csScheme\n@docs csCount\n@docs csExtent\n\n@docs scInterpolate\n@docs cubeHelix\n@docs cubeHelixLong\n@docs hcl\n@docs hclLong\n@docs hsl\n@docs hslLong\n@docs rgb\n@docs lab\n\n\n## 6.6 Scale Bins\n\n@docs bsNums\n@docs bsSignal\n@docs bsBins\n@docs bsStart\n@docs bsStop\n\n---\n\n\n# 7. Layout Composition\n\nFor arranging collections of marks in a grid to create small multiples, faceted plots etc.\nSee the [Vega layout documentation](https://vega.github.io/vega/docs/layout/).\n\n  - [7.1 Arrangement](#7-1-arrangement)\n  - [7.2 Headers, footers and titles](#7-2-headers-footers-and-titles)\n  - [7.3 Bounds calculation](#7-3-bounds-calculation)\n\n@docs layout\n\n\n## 7.1 Arrangement\n\n@docs loColumns\n@docs loPadding\n@docs loPaddingRC\n@docs loOffset\n@docs loOffsetRC\n\n\n## 7.2 Headers, Footers and Titles\n\n@docs loHeaderBand\n@docs loHeaderBandRC\n@docs loFooterBand\n@docs loFooterBandRC\n@docs loTitleBand\n@docs loTitleBandRC\n\n\n## 7.3 Bounds Calculation\n\n@docs loBounds\n@docs bcFlush\n@docs bcFull\n@docs bcSignal\n@docs loAlign\n\n\n### Grid Alignment\n\n@docs grAlignRow\n@docs grAlignColumn\n@docs grAlignAll\n@docs grAlignEach\n@docs grAlignNone\n@docs grAlignSignal\n\n---\n\n\n# 8. Map Projections\n\nThe transformation of global longitude/latitude locations into 2d screen position.\nSee the [Vega map projection documentation](https://vega.github.io/vega/docs/projections).\n\n  - [8.1 Projection properties](#8-1-projection-properties)\n  - [8.2 Projection types](#8-2-projection-types)\n\n@docs projections\n@docs projection\n\n\n## 8.1 Projection Properties\n\n@docs prType\n@docs prClipAngle\n@docs prClipExtent\n@docs prScale\n@docs prTranslate\n@docs prCenter\n@docs prRotate\n@docs prPointRadius\n@docs prPrecision\n@docs prCoefficient\n@docs prDistance\n@docs prFraction\n@docs prLobes\n@docs prParallel\n@docs prRadius\n@docs prRatio\n@docs prReflectX\n@docs prReflectY\n@docs prSpacing\n@docs prTilt\n@docs prExtent\n@docs prSize\n\n@docs prFit\n@docs feName\n@docs featureSignal\n\n\n## 8.2 Projection Types\n\n@docs albers\n@docs albersUsa\n@docs azimuthalEqualArea\n@docs azimuthalEquidistant\n@docs conicConformal\n@docs conicEqualArea\n@docs conicEquidistant\n@docs equalEarth\n@docs equirectangular\n@docs gnomonic\n@docs identityProjection\n@docs mercator\n@docs mollweide\n@docs naturalEarth1\n@docs orthographic\n@docs stereographic\n@docs transverseMercator\n@docs customProjection\n@docs prSignal\n@docs projectionValue\n\n---\n\n\n# 9. Titles\n\nSee the [Vega title documentation](https://vega.github.io/vega/docs/title/).\n\n  - [9.1 Title properties](#9-1-title-properties)\n  - [9.2 Text anchors](#9-2-test-anchors)\n\n@docs title\n\n\n## 9.1 Title Properties\n\n@docs tiAria\n@docs tiAnchor\n@docs tiAngle\n@docs tiAlign\n@docs tiBaseline\n@docs tiColor\n@docs tiDx\n@docs tiDy\n@docs tiEncodeElements\n@docs teTitle\n@docs teSubtitle\n@docs teGroup\n@docs tiFont\n@docs tiFontSize\n@docs tiFontStyle\n@docs tiFontWeight\n@docs tiFrame\n@docs tfBounds\n@docs tfGroup\n@docs tfSignal\n@docs tiSubtitle\n@docs tiSubtitleColor\n@docs tiSubtitleFont\n@docs tiSubtitleFontSize\n@docs tiSubtitleFontStyle\n@docs tiSubtitleFontWeight\n@docs tiSubtitleLineHeight\n@docs tiSubtitlePadding\n@docs tiLimit\n@docs tiLineHeight\n@docs tiOffset\n@docs tiOrient\n@docs tiZIndex\n\n\n## 9.2 Text Anchors\n\n@docs anStart\n@docs anMiddle\n@docs anEnd\n@docs anchorSignal\n\n---\n\n\n# 10. Axes\n\nThe visual appearance of chart axes. See the\n[Vega axis documentation](https://vega.github.io/vega/docs/axes/).\n\n  - [10.1 Axis positioning and extent](#10-1-axis-positioning-and-extent)\n  - [10.2 Axis line](#10-2-axis-line)\n  - [10.3 Axis grid Lines](#10-3-axis-grid-lines)\n  - [10.4 Axis labels](#10-4-axis-labels)\n  - [10.5 Axis ticks](#10-5-axis-ticks)\n  - [10.6 Axis title](#10-6-axis-title)\n  - [10.7 Axis elements](#10-7-axis-elements)\n\n@docs axes\n@docs axis\n\n@docs axEncode\n@docs axAria\n\n\n## 10.1 Axis Positioning and Extent\n\n@docs axMinExtent\n@docs axMaxExtent\n@docs axOffset\n@docs axPosition\n@docs axZIndex\n\n\n### Positioning\n\n@docs siLeft\n@docs siRight\n@docs siTop\n@docs siBottom\n@docs siSignal\n\n\n### Overlap Strategies\n\n@docs osNone\n@docs osParity\n@docs osGreedy\n@docs osSignal\n\n\n## 10.2 Axis line\n\n@docs axDomain\n@docs axDomainCap\n@docs axDomainColor\n@docs axDomainDash\n@docs axDomainDashOffset\n@docs axDomainOpacity\n@docs axDomainWidth\n\n@docs strokeCapStr\n\n\n## 10.3 Axis Grid Lines\n\n@docs axGrid\n@docs axGridCap\n@docs axGridColor\n@docs axGridOpacity\n@docs axGridDash\n@docs axGridDashOffset\n@docs axGridScale\n@docs axGridWidth\n\n\n## 10.4 Axis Labels\n\n@docs axLabels\n@docs axLabelBound\n@docs axLabelAlign\n@docs axLabelBaseline\n@docs axLabelAngle\n@docs axLabelColor\n@docs axLabelOpacity\n@docs axLabelFont\n@docs axLabelFontSize\n@docs axLabelFontStyle\n@docs axLabelFontWeight\n@docs axLabelFlush\n@docs axLabelFlushOffset\n@docs axLabelLimit\n@docs axLabelLineHeight\n@docs axLabelOffset\n@docs axLabelPadding\n@docs axLabelOverlap\n@docs axLabelSeparation\n@docs axFormat\n@docs axFormatAsNum\n@docs axFormatAsTemporal\n@docs axFormatAsTemporalUtc\n@docs axValues\n\n\n## 10.5 Axis Ticks\n\n@docs axTicks\n@docs axTickBand\n@docs abCenter\n@docs abExtent\n@docs axTickCount\n@docs axTemporalTickCount\n@docs axTickCap\n@docs axTickColor\n@docs axTickDash\n@docs axTickDashOffset\n@docs axTickOpacity\n@docs axTickExtra\n@docs axTickMinStep\n@docs axTickOffset\n@docs axTickRound\n@docs axTickWidth\n@docs axTickSize\n@docs axBandPosition\n\n\n## 10.6 Axis Title\n\n@docs axTitle\n@docs axTitleAlign\n@docs axTitleAnchor\n@docs axTitleAngle\n@docs axTitleBaseline\n@docs axTitleColor\n@docs axTitleOpacity\n@docs axTitleFont\n@docs axTitleFontSize\n@docs axTitleFontStyle\n@docs axTitleFontWeight\n@docs axTitleLimit\n@docs axTitleLineHeight\n@docs axTitlePadding\n@docs axTitleX\n@docs axTitleY\n@docs axTranslate\n\n\n## 10.7 Axis Elements\n\n@docs aeAxis\n@docs aeTicks\n@docs aeGrid\n@docs aeLabels\n@docs aeTitle\n@docs aeDomain\n\n---\n\n\n# 11. Legends\n\nSee the [Vega legend documentation](https://vega.github.io/vega/docs/legends/)\n\n  - [11.1 Legend type](#11-1-legend-type)\n  - [11.2 Legend gradient](#11-2-legend-gradient)\n  - [11.3 Legend labels](#11-3-legend-labels)\n  - [11.4 Legend symbols](#11-4-legend-symbols)\n  - [11.5 Legend ticks](#11-5-legend-ticks)\n  - [11.6 Legend title](#11-6-legend-title)\n  - [11.7 Legend positioning and layout](#11-7-legend-positioning-and-layout)\n  - [11.8 Legend appearance](#11-8-legend-appearance)\n  - [11.9 Legend encoding](#11-9-legend-encoding)\n\n@docs legends\n@docs legend\n@docs leValues\n\n\n## 11.1 Legend Type\n\n@docs leType\n@docs ltSymbol\n@docs ltGradient\n@docs ltSignal\n\n\n## 11.2 Legend Gradient\n\n@docs leGradientOpacity\n@docs leGradientLabelLimit\n@docs leGradientLabelOffset\n@docs leGradientLength\n@docs leGradientThickness\n@docs leGradientStrokeColor\n@docs leGradientStrokeWidth\n\n\n## 11.3 Legend Labels\n\n@docs leLabelAlign\n@docs leLabelBaseline\n@docs leLabelColor\n@docs leLabelFont\n@docs leLabelFontSize\n@docs leLabelFontStyle\n@docs leLabelFontWeight\n@docs leLabelLimit\n@docs leLabelOpacity\n@docs leLabelOffset\n@docs leLabelOverlap\n@docs leLabelSeparation\n@docs leFormat\n@docs leFormatAsNum\n@docs leFormatAsTemporal\n@docs leFormatAsTemporalUtc\n\n\n## 11.4 Legend Symbols\n\n@docs leSymbolFillColor\n@docs leSymbolBaseFillColor\n@docs leSymbolBaseStrokeColor\n@docs leSymbolDash\n@docs leSymbolDashOffset\n@docs leSymbolDirection\n@docs leSymbolLimit\n@docs leSymbolOffset\n@docs leSymbolOpacity\n@docs leSymbolSize\n@docs leSymbolStrokeColor\n@docs leSymbolStrokeWidth\n@docs leSymbolType\n@docs leClipHeight\n\n\n## 11.5 Legend Ticks\n\n@docs leTickCount\n@docs leTickMinStep\n@docs leTemporalTickCount\n\n\n## 11.6 Legend Title\n\n@docs leTitle\n@docs leTitleAlign\n@docs leTitleAnchor\n@docs leTitleBaseline\n@docs leTitleColor\n@docs leTitleOpacity\n@docs leTitleFont\n@docs leTitleFontSize\n@docs leTitleFontStyle\n@docs leTitleFontWeight\n@docs leTitleLimit\n@docs leTitleLineHeight\n@docs leTitleOrient\n@docs leTitlePadding\n\n\n## 11.7 Legend Positioning and Layout\n\n@docs leDirection\n@docs leOrient\n@docs loLeft\n@docs loTopLeft\n@docs loTop\n@docs loTopRight\n@docs loRight\n@docs loBottomRight\n@docs loBottom\n@docs loBottomLeft\n@docs loNone\n@docs loSignal\n@docs leOffset\n@docs lePadding\n@docs leX\n@docs leY\n@docs leZIndex\n\n\n### Layout\n\n@docs leGridAlign\n@docs leColumns\n@docs leColumnPadding\n@docs leRowPadding\n@docs llAnchor\n@docs llBounds\n@docs llCenter\n@docs llDirection\n@docs llMargin\n@docs llOffset\n\n\n## 11.8 Legend Appearance\n\n@docs leFill\n@docs leOpacity\n@docs leShape\n@docs leSize\n@docs leStroke\n@docs leStrokeDash\n@docs leCornerRadius\n@docs leFillColor\n@docs leStrokeColor\n@docs leStrokeWidth\n@docs leAria\n\n\n## 11.9 Legend Encoding\n\nFor custom encoding of legend appearance.\n\n@docs leEncode\n@docs enLegend\n@docs enTitle\n@docs enLabels\n@docs enSymbols\n@docs enGradient\n@docs enName\n@docs enInteractive\n\n---\n\n\n# 12. Marks\n\nThe primary means of providing a visual representation of data values. See the\n[Vega mark documentation](https://vega.github.io/vega/docs/marks).\n\n  - [12.1 Top-level marks](#12-1-top-level-marks)\n  - [12.2 Faceting](#12-2-faceting)\n  - [12.3 Lower-level mark properties](#12-3-lower-level-mark-properties)\n  - [12.4 Mark encoding](#12-4-mark-encoding)\n  - [12.5 Cursors](#12-5-cursors)\n\n##Â 12.1 Top-Level Marks\n\n@docs marks\n@docs mark\n\n\n### Mark Types\n\n@docs arc\n@docs area\n@docs image\n@docs group\n@docs line\n@docs path\n@docs rect\n@docs rule\n@docs shape\n@docs symbol\n@docs text\n@docs trail\n\n\n### Top-Level Mark Properties\n\n@docs mAria\n@docs mClip\n@docs mDescription\n@docs mEncode\n@docs mFrom\n@docs mInteractive\n@docs mKey\n@docs mName\n@docs mOn\n@docs mSort\n@docs mTransform\n@docs mStyle\n@docs mGroup\n@docs mZIndex\n\n@docs clEnabled\n@docs clPath\n@docs clSphere\n@docs srData\n\n\n## 12.2 Faceting\n\nSplit up a data source between group mark items.\n\n@docs srFacet\n@docs faField\n@docs faGroupBy\n@docs faAggregate\n\n\n## 12.3 Lower-level Mark Properties\n\nSee the [Vega mark encoding documentation](https://vega.github.io/vega/docs/marks/#encode).\n\n\n### Mark Positioning and Size\n\n@docs maX\n@docs maX2\n@docs maXC\n@docs maWidth\n@docs maY\n@docs maY2\n@docs maYC\n@docs maHeight\n@docs maSize\n@docs maZIndex\n\n\n### Mark Coloring\n\n@docs maOpacity\n@docs maFill\n@docs maFillOpacity\n@docs maStroke\n@docs transparent\n@docs black\n@docs white\n@docs maStrokeOpacity\n\n\n### Blend Modes\n\n@docs maBlend\n@docs bmNormal\n@docs bmMultiply\n@docs bmScreen\n@docs bmOverlay\n@docs bmDarken\n@docs bmLighten\n@docs bmColorDodge\n@docs bmColorBurn\n@docs bmHardLight\n@docs bmSoftLight\n@docs bmDifference\n@docs bmExclusion\n@docs bmHue\n@docs bmSaturation\n@docs bmColor\n@docs bmLuminosity\n\n\n### Mark Stroke Appearance\n\n@docs maStrokeWidth\n@docs maStrokeCap\n@docs maStrokeDash\n@docs maStrokeDashOffset\n@docs maStrokeJoin\n@docs maStrokeMiterLimit\n\n\n### Mark Text\n\n@docs maFont\n@docs maFontSize\n@docs maFontWeight\n@docs maFontStyle\n@docs maLimit\n@docs maLineBreak\n@docs maLineHeight\n@docs maDir\n@docs maDx\n@docs maDy\n@docs maEllipsis\n@docs maRadius\n@docs maText\n@docs maTheta\n\n\n### Interaction Cues\n\n@docs maCursor\n@docs maHRef\n@docs maTooltip\n\n\n### Mark-Specific Properties\n\n@docs maAlign\n@docs maBaseline\n@docs maCornerRadius\n@docs maCornerRadiusTopLeft\n@docs maCornerRadiusTopRight\n@docs maCornerRadiusBottomLeft\n@docs maCornerRadiusBottomRight\n@docs maStrokeForeground\n@docs maStrokeOffset\n@docs maInterpolate\n@docs maTension\n@docs maDefined\n@docs maStartAngle\n@docs maEndAngle\n@docs maPadAngle\n@docs maInnerRadius\n@docs maOuterRadius\n@docs maOrient\n@docs maGroupClip\n@docs maUrl\n@docs maImage\n@docs maAspect\n@docs maSmooth\n@docs maPath\n@docs maShape\n@docs maSymbol\n@docs maAngle\n@docs maScaleX\n@docs maScaleY\n\n@docs maCustom\n\n\n## 12.4 Mark Encoding\n\nSee the [Vega mark encoding documentation](https://vega.github.io/vega/docs/marks/#encode).\n\n@docs enEnter\n@docs enUpdate\n@docs enHover\n@docs enExit\n@docs enCustom\n@docs miBasis\n@docs miBundle\n@docs miCardinal\n@docs miCatmullRom\n@docs miLinear\n@docs miMonotone\n@docs miNatural\n@docs miStepwise\n@docs miStepAfter\n@docs miStepBefore\n@docs markInterpolationValue\n@docs orHorizontal\n@docs orVertical\n@docs orRadial\n@docs orSignal\n@docs orientationValue\n@docs haLeft\n@docs haCenter\n@docs haRight\n@docs haSignal\n@docs hLeft\n@docs hCenter\n@docs hRight\n@docs vaTop\n@docs vaLineTop\n@docs vaMiddle\n@docs vaBottom\n@docs vaLineBottom\n@docs vaAlphabetic\n@docs vaSignal\n@docs vTop\n@docs vLineTop\n@docs vMiddle\n@docs vBottom\n@docs vLineBottom\n@docs vAlphabetic\n\n@docs symCircle\n@docs symCross\n@docs symDiamond\n@docs symSquare\n@docs symArrow\n@docs symWedge\n@docs symTriangle\n@docs symTriangleUp\n@docs symTriangleDown\n@docs symTriangleLeft\n@docs symTriangleRight\n@docs symStroke\n@docs symPath\n@docs symSignal\n@docs symbolValue\n\n@docs caButt\n@docs caSquare\n@docs caRound\n@docs caSignal\n@docs strokeCapValue\n@docs joMiter\n@docs joBevel\n@docs joRound\n@docs joSignal\n@docs strokeJoinValue\n@docs tdLeftToRight\n@docs tdRightToLeft\n@docs tdSignal\n@docs textDirectionValue\n\n\n## 12.5 Cursors\n\nSee the\n[CSS cursor documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)\n\n@docs cuAuto\n@docs cuDefault\n@docs cuNone\n@docs cuContextMenu\n@docs cuHelp\n@docs cuPointer\n@docs cuProgress\n@docs cuWait\n@docs cuCell\n@docs cuCrosshair\n@docs cuText\n@docs cuVerticalText\n@docs cuAlias\n@docs cuCopy\n@docs cuMove\n@docs cuNoDrop\n@docs cuNotAllowed\n@docs cuAllScroll\n@docs cuColResize\n@docs cuRowResize\n@docs cuNResize\n@docs cuEResize\n@docs cuSResize\n@docs cuWResize\n@docs cuNEResize\n@docs cuNWResize\n@docs cuSEResize\n@docs cuSWResize\n@docs cuEWResize\n@docs cuNSResize\n@docs cuNESWResize\n@docs cuNWSEResize\n@docs cuZoomIn\n@docs cuZoomOut\n@docs cuGrab\n@docs cuGrabbing\n@docs cursorValue\n\n---\n\n\n# 13. Configuration\n\nProviding consistent default settings across a specification. See the\n[Vega configuration documentation](https://vega.github.io/vega/docs/config/).\n\n  - [13.1 Configuring the view](#13-1-configuring-the-view)\n  - [13.2 Configuring events](#13-2-configuring-events)\n  - [13.3 Configuring marks](#13-3-configuring-marks)\n  - [13.4 Configuring axes](#13-4-configuring-axes)\n  - [13.5 Configuring legends](#13-5-configuring-legends)\n  - [13.6 Configuring titles](#13-6-configuring-titles)\n  - [13.7 Configuring scales](#13-7-configuring-scales)\n  - [13.8 Configuring styles](#13-8-configuring-styles)\n  - [13.9 Configuration signals](#13-9-configuration-signals)\n\n@docs config\n\n\n## 13.1 Configuring the View\n\n@docs cfAutosize\n@docs cfBackground\n@docs cfDescription\n@docs cfPadding\n@docs cfPaddings\n@docs cfPaddingSignal\n@docs cfWidth\n@docs cfWidthSignal\n@docs cfHeight\n@docs cfHeightSignal\n@docs cfGroup\n@docs cfLineBreak\n\n\n## 13.2 Configuring Events\n\n@docs cfEventHandling\n\n@docs cfeBind\n@docs sbAny\n@docs sbContainer\n@docs sbNone\n\n@docs cfeDefaults\n@docs efPrevent\n@docs efAllow\n\n@docs cfeSelector\n@docs cfeTimer\n@docs cfeView\n@docs cfeWindow\n\n\n## 13.3 Configuring Marks\n\n@docs cfMark\n@docs cfMarks\n\n\n## 13.4 Configuring Axes\n\n@docs cfAxis\n@docs axAll\n@docs axLeft\n@docs axTop\n@docs axRight\n@docs axBottom\n@docs axX\n@docs axY\n@docs axBand\n\n\n## 13.5 Configuring Legends\n\n@docs cfLegend\n@docs leBorderStrokeDash\n@docs leBorderStrokeWidth\n@docs leLayout\n@docs leOrientLayout\n\n\n## 13.6 Configuring Titles\n\n@docs cfTitle\n\n\n## 13.7 Configuring Scales\n\n@docs cfScaleRange\n\n\n## 13.8 Configuring Styles\n\n@docs cfStyle\n\n\n## 13.9 Configuration Signals\n\n@docs cfSignals\n\n---\n\n\n# 14. Supplementary Properties\n\nSee the\n[Vega specification documentation](https://vega.github.io/vega/docs/specification/)\n\n@docs autosize\n@docs asContent\n@docs asFit\n@docs asFitX\n@docs asFitY\n@docs asNone\n@docs asPad\n@docs asPadding\n@docs asResize\n@docs asSignal\n@docs height\n@docs heightSignal\n@docs padding\n@docs paddings\n@docs paddingSignal\n@docs width\n@docs widthSignal\n@docs background\n@docs encode\n@docs description\n@docs userMeta\n\n\n## 14.1 ARIA Accessiblity Properties\n\n@docs arEnable\n@docs arDisable\n@docs arDescription\n\n---\n\n\n# 15. Type Reference\n\nTypes that are not specified directly, provided here for reference with links\nto the functions that generate them.\n\n@docs AggregateProperty\n@docs Anchor\n@docs Autosize\n@docs AxisElement\n@docs AxisProperty\n@docs AxisType\n@docs Bind\n@docs BinProperty\n@docs BinsProperty\n@docs BlendMode\n@docs Boo\n@docs BoundsCalculation\n@docs Case\n@docs CInterpolate\n@docs Clip\n@docs ColorSchemeProperty\n@docs ColorGradient\n@docs ColorValue\n@docs ConfigEventHandler\n@docs ConfigProperty\n@docs CountPatternProperty\n@docs CrossProperty\n@docs Cursor\n@docs Data\n@docs DataColumn\n@docs DataProperty\n@docs DataReference\n@docs DataRow\n@docs DataTable\n@docs DateTime\n@docs DataType\n@docs DensityFunction\n@docs DensityProperty\n@docs Distribution\n@docs DotBinProperty\n@docs EncodingProperty\n@docs EventFilter\n@docs EventHandler\n@docs EventSource\n@docs EventStream\n@docs EventStreamProperty\n@docs EventType\n@docs Expr\n@docs Facet\n@docs Feature\n@docs Field\n@docs Force\n@docs ForceProperty\n@docs ForceSimulationProperty\n@docs FormatProperty\n@docs GeoJsonProperty\n@docs GeoPathProperty\n@docs GradientProperty\n@docs GradientScaleProperty\n@docs GraticuleProperty\n@docs GridAlign\n@docs HAlign\n@docs HeatmapProperty\n@docs ImputeMethod\n@docs ImputeProperty\n@docs InputProperty\n@docs IsocontourProperty\n@docs JoinAggregateProperty\n@docs KdeProperty\n@docs Kde2Property\n@docs LayoutProperty\n@docs LegendEncoding\n@docs LegendOrientation\n@docs LegendProperty\n@docs LegendType\n@docs LinkPathProperty\n@docs LinkShape\n@docs LoessProperty\n@docs LookupProperty\n@docs Mark\n@docs MarkInterpolation\n@docs MarkProperty\n@docs Num\n@docs Operation\n@docs Order\n@docs Orientation\n@docs OverlapStrategy\n@docs PackProperty\n@docs PartitionProperty\n@docs PieProperty\n@docs PivotProperty\n@docs Projection\n@docs ProjectionProperty\n@docs QuantileProperty\n@docs RegressionMethod\n@docs RegressionProperty\n@docs Resolution\n@docs Scale\n@docs ScaleBins\n@docs ScaleDomain\n@docs ScaleNice\n@docs ScaleProperty\n@docs ScaleRange\n@docs Side\n@docs SignalBind\n@docs SignalProperty\n@docs SortProperty\n@docs Source\n@docs Spec\n@docs Spiral\n@docs StackOffset\n@docs StackProperty\n@docs Str\n@docs StrokeCap\n@docs StrokeJoin\n@docs Symbol\n@docs TextDirection\n@docs TimeBinProperty\n@docs TimeUnit\n@docs Timezone\n@docs TitleElement\n@docs TitleFrame\n@docs TitleProperty\n@docs TopMarkProperty\n@docs Transform\n@docs TreemapMethod\n@docs TreemapProperty\n@docs TreeMethod\n@docs TreeProperty\n@docs Trigger\n@docs TriggerProperty\n@docs VAlign\n@docs Value\n@docs VoronoiProperty\n@docs WindowOperation\n@docs WindowProperty\n@docs WOperation\n@docs WordcloudProperty\n\n---\n\n\n# Deprecated Functions and types\n\n@docs cfEvents\n@docs cnBandwidth\n@docs cnCount\n@docs cnCellSize\n@docs cnNice\n@docs cnSmooth\n@docs cnThresholds\n@docs cnValues\n@docs cnWeight\n@docs cnX\n@docs cnY\n@docs ContourProperty\n@docs scSequential\n@docs tiEncode\n@docs tiInteractive\n@docs tiName\n@docs tiStyle\n@docs trContour\n\n","unions":[{"name":"AggregateProperty","comment":" Generated by [agAs](#agAs), [agCross](#agCross), [agDrop](#agDrop), [agFields](#agFields),\n[agGroupBy](#agGroupBy), [agOps](#agOps) and [agKey](#agKey).\n","args":[],"cases":[]},{"name":"Anchor","comment":" Generated by [anStart](#anStart), [anMiddle](#anMiddle), [anEnd](#anEnd) and\n[anchorSignal](#anchorSignal).\n","args":[],"cases":[]},{"name":"Autosize","comment":" Generated by [asContent](#asContent), [asFit](#asFit), [asFitX](#asFitX),\n[asFitY](#asFitY), [asNone](#asNone), [asPad](#asPad), [asPadding](#asPadding),\n[asResize](#asReeize) and [asSignal](#asSignal).\n","args":[],"cases":[]},{"name":"AxisElement","comment":" Generated by [aeAxis](#aeAxis), [aeTicks](#aeTicks), [aeGrid](#aeGrid),\n[aeLabels](#aeLabels), [aeTitle](#aeTitle) and [aeDomain](#aeDomain).\n","args":[],"cases":[]},{"name":"AxisProperty","comment":" Generated by [axAria](#axAria), [axBandPosition](#axBandPosition), [axDomain](#axDomain),\n[axDomainCap](#axDomainCap), [axDomainColor](#axDomainColor), [axDomainDash](#axDomainDash),\n[axDomainDashOffset](#axDomainDashOffset), [axDomainOpacity](#axDomainOpacity),\n[axDomainWidth](#axDomainWidth), [axEncode](#axEncode), [axFormat](#axFormat),\n[axFormatAsNum](#axFormatAsNum), [axFormatAsTemporal](#axFormatAsTemporal),\n[axFormatAsTemporalUtc](#axFormatAsTemporalUtc), [axGrid](#axGrid), [axGridCap](#axGridCap),\n[axGridColor](#axGridColor), [axGridDash](#axGridDash), [axGridDashOffset](#axGridDashOffset),\n[axGridOpacity](#axGridOpacity), [axGridScale](#axGridScale), [axGridWidth](#axGridWidth), [axLabels](#axLabels),\n[axLabelAlign](#axLabelAlign), [axLabelBaseline](#axLabelBaseline), [axLabelBound](#axLabelBound),\n[axLabelColor](#axLabelColor), [axLabelFlush](#axLabelFlush), [axLabelFlushOffset](#axLabelFlushOffset),\n[axLabelFont](#axLabelFont), [axLabelFontSize](#axLabelFontSize), [axLabelFontStyle](#axLabelFontStyle),\n[axLabelFontWeight](#axLabelFontWeight), [axLabelLimit](#axLabelLimit), [axLabelLineHeight](#axLabelLineHeight),\n[axLabelOffset](#axLabelOffset), [axLabelOpacity](#axLabelOpacity) [axLabelOverlap](#axLabelOverlap),\n[axLabelPadding](#axLabelPadding), [axLabelSeparation](#axLabelSeparation), [axMaxExtent](#axMaxExtent),\n[axMinExtent](#axMinExtent), [axOffset](#axOffset), [axPosition](#axPosition), [axTicks](#axTicks),\n[axTickBand](#axTickBand), [axTickColor](#axTickColor), [axTickCount](#axTickCount),\n[axTemporalTickCount](#axTemporalTickCount), [axTickDash](#axTickDash), [axTickDashOffset](#axTickDashOffset),\n[axTickExtra](#axTickExtra), [axTickMinStep](#axTickMinStep), [axTickOffset](#axTickOffset),\n[axTickOpacity](#axTickOpacity), [axTickRound](#axTickRound), [axTickSize](#axTickSize),\n[axTickWidth](#axTickWidth), [axTitle](#axTitle), [axTitleAlign](#axTitleAlign), [axTitleAnchor](#axTitleAnchor),\n[axTitleAngle](#axTitleAngle), [axTitleBaseline](#axTitleBaseline), [axTitleColor](#axTitleColor),\n[axTitleFont](#axTitleFont), [axTitleFontSize](#axTitleFontSize), [axTitleFontStyle](#axTitleFontStyle),\n[axTitleFontWeight](#axTitleFontWeight), [axTitleLimit](#axTitleLimit),\n[axTitleLineHeight](#axTitleLineHeight)[axTitleOpacity](#axTitleOpacity),\n[axTitlePadding](#axTitlePadding), [axTitleX](#axTitleX), [axTitleY](#axTitleY),\n[axTranslate](#axTranslate), [axValues](#axValues) and [axZIndex](#axZIndex).\n","args":[],"cases":[]},{"name":"AxisType","comment":" Generated by [axAll](#axAll), [axLeft](#axLeft), [axTop](#axTop), [axRight](#axRight),\n[axBottom](#axBottom), [axX](#axX), [axY](#axY) and [axBand](#axBand)\n","args":[],"cases":[]},{"name":"BinProperty","comment":" Generated by [bnInterval](#bnInterval), [bnAnchor](#bnAnchor), [bnMaxBins](#bnMaxBins),\n[bnBase](#bnBase), [bnSpan](#bnSpan), [bnStep](#bnStep), [bnSteps](#bnSteps),\n[bnNums](#bnNums), [bnMinStep](#bnMinStep), [bnDivide](#bnDivide), [bnNice](#bnNice),\n[bnSignal](#bnSignal) and [bnAs](#bnAs).\n","args":[],"cases":[]},{"name":"Bind","comment":" Generated by [iRange](#iRange), [iCheckbox](#iCheckbox), [iRadio](#iRadio),\n[iSelect](#iSelect), [iText](#iText), [iNumber](#iNumber), [iDate](#iDate),\n[iTime](#iTime), [iMonth](#iMonth), [iWeek](#iWeek), [iDateTimeLocal](#iDateTimeLocal),\n[iTel](#iTel) and [iColor](#iColor).\n","args":[],"cases":[]},{"name":"BinsProperty","comment":" Generated by [bsStart](#bsStart) and [bsStop](#bsStop).\n","args":[],"cases":[]},{"name":"BlendMode","comment":" Generated by [bmNormal](#bmNormal), [bmMultiply](#bmMultiply), [bmScreen](#bmScreen),\n[bmOverlay](#bmOverlay), [bmDarken](#bmDarken), [bmLighten](#bmLighten), [bmColorDodge](#bmColorDodge),\n[bmColorBurn](#bmColorBurn), [bmHardLight](#bmHardLight), [bmSoftLight](#bmSoftLight),\n[bmDifference](#bmDifference), [bmExclusion](#bmExclusion), [bmHue](#bmHue),\n[bmSaturation](#bmSaturation), [bmColor](#bmColor) and [bmLuminosity](#bmLuminosity).\n","args":[],"cases":[]},{"name":"Boo","comment":" Generated by [true](#true), [false](#false), [boos](#boos), [booSignal](#booSignal),\n[booSignals](#booSignals) and [booExpr](#booExpr)\n","args":[],"cases":[]},{"name":"BoundsCalculation","comment":" Generated by [bcFull](#bcFull), [bcFlush](#bcFlush) and [bc](#bcSignal).\n","args":[],"cases":[]},{"name":"CInterpolate","comment":" Generated by [hcl](#hcl), [hsl](#hsl), [lab](#lab), [cubeHelix](#cubeHelix),\n[cubeHelixLong](#cubeHelixLong), [hclLong](#hclLong), [hslLong](#hslLong) and [rgb](#rgb).\n","args":[],"cases":[]},{"name":"Case","comment":" Generated by [lowercase](#lowercase), [uppercase](#uppercase) and [mixedcase](#mixedcase).\n","args":[],"cases":[]},{"name":"Clip","comment":" Generated by [clEnabled](#clEnabled), [clPath](#clPath) and [clSphere](#clSphere).\n","args":[],"cases":[]},{"name":"ColorGradient","comment":" Generated by [grLinear](#grLinear) and [grRadial](#grRadial).\n","args":[],"cases":[]},{"name":"ColorSchemeProperty","comment":" Generated by [csScheme](#csScheme), [csCount](#csCount) and [csExtent](#csExtent).\n","args":[],"cases":[]},{"name":"ColorValue","comment":" Generated by [cRGB](#cRGB), [cHSL](#cHSL), [cLAB](#cLAB) and [cHCL](#cHCL)\n","args":[],"cases":[]},{"name":"ConfigEventHandler","comment":" Generated by [cfeBind](#cfeBind), [cfeDefaults](#cfeDefaults),\n[cfeSelector](#cfeSelector), [cfeTimer](#cfeTimer), [cfeView](#cfeView) and\n[cfeWindow](#cfeWindow).\n","args":[],"cases":[]},{"name":"ConfigProperty","comment":" Generated by [cfAutosize](#cfAutosize), [cfBackground](#cfBackground),\n[cfDescription](#cfDescription), [cfPadding](#cfPadding), [cfPaddings](#cfPaddings),\n[cfPaddingSignal](#cfPaddingSignal), [cfWidth](#cfWidth), [cfWidthSignal],\n[cfHeight](#cfHeight), [cfHeightSignal](#cfHeightSignal), [cfGroup](#cfGroup),\n[cfLineBreak](#cfLineBreak), [cfEventHandling](#cfEventHandling), [cfMark](#cfMark),\n[cfMarks](#cfMarks), [cfStyle](#cfStyle), [cfAxis](#cfAxis), [cfLegend](#cfLegend),\n[cfTitle](#cfTitle), [cfScaleRange](#cfScaleRange) and [cfSignals](#cfSignals).\n","args":[],"cases":[]},{"name":"ContourProperty","comment":" Deprecated in favour of [IsocontourProperty](#IsocontourProperty) for use with\n[trIsocontour](#trIsocontour).\n","args":[],"cases":[]},{"name":"CountPatternProperty","comment":" Generated by [cpPattern](#cpPattern), [cpCase](#cpCase), [cpStopwords](#cpStopwords)\nand [cpAs](#cprAs).\n","args":[],"cases":[]},{"name":"CrossProperty","comment":" Generated by [crFilter](#crFilter) and [crAs](#ccrAs).\n","args":[],"cases":[]},{"name":"Cursor","comment":" Generated by functions that start with `cu`.\n","args":[],"cases":[]},{"name":"DataProperty","comment":" Generated by [daFormat](#daFormat), [daSource](#daSource), [daSources](#daSources),\n[daValue](#daValue),[daOn](#daOn), [daUrl](#daUrl) and [daSphere](#daSphere).\n","args":[],"cases":[]},{"name":"DataReference","comment":" Generated by [daDataset](#daDataset), [daField](#daField), [daFields](#daFields),\n[daSignal](#daSignal), [daValues](#daValues) [daReferences](#daReferences) and\n[daSort](#daSort).\n","args":[],"cases":[]},{"name":"DataType","comment":" Generated by [foNum](#foNum), [foBoo](#foBoo), [foDate](#foDate) and [foUtc](#foUtc).\n","args":[],"cases":[]},{"name":"DateTime","comment":" Generated by [dtExpr](#dtExpr) and [dtMillis](#dtMillis).\n","args":[],"cases":[]},{"name":"DensityFunction","comment":" Generated by [dnPdf](#dnPdf), [dnCdf](#dnCdf) and [dnSignal](#dnSignal)\n","args":[],"cases":[]},{"name":"DensityProperty","comment":" Generated by [dnExtent](#dnExtent), [dnMethod](#dnMethod), [dnSteps](#dnSteps)\n[dnMinSteps](#dnMinSteps), [dnMaxSteps](#dnMaxSteps) and [dnAs](#dnAs).\n","args":[],"cases":[]},{"name":"Distribution","comment":" Generated by [diNormal](#diNormal), [diUniform](#diUniform), [diKde](#diKde)\nand [diMixture](#diMixture).\n","args":[],"cases":[]},{"name":"DotBinProperty","comment":" Generated by [dbGroupBy](#dbGroupBy), [dbStep](#dbStep), [dbSmooth](#dbSmooth),\n[dbSignal](#dbSignal) and [dbAs](#dbAs).\n","args":[],"cases":[]},{"name":"EncodingProperty","comment":" Generated by [enEnter](#enEnter), [enUpdate](#enUpdate), [enExit](#enExit),\n[enHover](#enHover), [enName](#enName), [enInteractive](#enInteractive) and\n[enCustom](#enCustom).\n","args":[],"cases":[]},{"name":"EventFilter","comment":" Generated by [efPrevent](#efPrevent) and [efAllow](#efAllow).\n","args":[],"cases":[]},{"name":"EventHandler","comment":" Generated by [evHandler](#evHandler), [evUpdate](#evUpdate), [evEncode](#evEncode)\nand [evForce](#evForce).\n","args":[],"cases":[]},{"name":"EventSource","comment":" Generated by [esAll](#esAll), [esView](#esView), [esScope](#esScope),\n[esWindow](#esWindow) and [esDom](#esDom).\n","args":[],"cases":[]},{"name":"EventStream","comment":" Generated by [esObject](#esObject), [esSelector](#esSelector), [esSignal](#esSignal)\nand [esMerge](#esMerge).\n","args":[],"cases":[]},{"name":"EventStreamProperty","comment":" Generated by [esSource](#esSource), [esType](#esType), [esBetween](#esBetween),\n[esConsume](#esConsume), [esFilter](#esFilter), [esDebounce](#esDebounce),\n[esMarkName](#esMarkName), [esMark](#esMark), [esThrottle](#esThrottle) and\n[esStream](#esStream).\n","args":[],"cases":[]},{"name":"EventType","comment":" Generated by [etClick](#etClick), [etDblClick](#etDblClick), [etDragEnter](#etDragEnter),\n[etDragLeave](#etDragLeave), [etDragOver](#etDragOver), [etKeyDown](#etKeyDown),\n[etKeyPress](#etKeyPress), [etKeyUp](#etKeyUp), [etMouseDown](#etMouseDown),\n[etMouseMove](#etMouseMove), [etMouseOut](#etMouseOut), [etMouseOver](#etMouseOver),\n[etMouseUp](#etMouseUp), [etMouseWheel](#etMouseWheel), [etTouchEnd](#etTouchEnd),\n[etTouchMove](#etTouchMove), [etTouchStart](#etTouchStart), [etWheel](#etWheel)\nand [etTimer](#etTimer).\n","args":[],"cases":[]},{"name":"Expr","comment":" Generated by [exField](#exField) and [expr](#expr).\n","args":[],"cases":[]},{"name":"Facet","comment":" Generated by [faAggregate](#faAggregate), [faField](#faField) and [faGroupBy](#faGroupBy).\n","args":[],"cases":[]},{"name":"Feature","comment":" Generated by [featureSignal](#featureSignal) and [feName](#feName).\n","args":[],"cases":[]},{"name":"Field","comment":" Generated by [fExpr](#fExpr), [fDatum](#fDatum), [fGroup](#fGroup),\n[field](#field), [fParent](#fParent) and [fSignal](#fSignal).\n","args":[],"cases":[]},{"name":"Force","comment":" Generated by [foCollide](#foCollide), [foLink](#foLink), [foNBody](#foNBody),\n[foX](#foX) and [foY](#foY).\n","args":[],"cases":[]},{"name":"ForceProperty","comment":" Generated by [fpDistance](#fpDistance), [fpDistanceMax](#fpDistanceMax),\n[fpDistanceMin](#fpDistanceMin), [fpId](#fpId), [fpIterations](#fpIterations),\n[fpStrength](#fpStrength) and [fpTheta](#fpTheta).\n","args":[],"cases":[]},{"name":"ForceSimulationProperty","comment":" Generated by [fsAlpha](#fsAlpha),\n[fsAlphaMin](#fsAlphaMin), [fsAlphaTarget](#fsAlphaTarget), [fsAs](#fsAs),\n[fsForces](#fsForces), [fsIterations](#fsIterations), [fsRestart](#fsRestart),\n[fsStatic](#fsStatic) and [fsVelocityDecay](#fsVelocityDecay).\n","args":[],"cases":[]},{"name":"FormatProperty","comment":" Generated by [csv](#csv), [tsv](#tsv), [dsv](#dsv), [arrow](#arrow), [json](#json),\n[jsonProperty](#jsonProperty), [topojsonFeature](#topojsonFeature),\n[topojsonMesh](#topojsonMesh), [topojsonMeshExterior](#topojsonMeshExterior),\n[topojsonMeshInterior](#topojsonMeshInterior), [parse](#parse), [parseAuto](#parseAuto)\nand [fpSignal](#fpSignal).\n","args":[],"cases":[]},{"name":"GeoJsonProperty","comment":" Generated by [gjFields](#gjFields), [gjFeature](#gjFeature) and [gjSignal](#gjSignal).\n","args":[],"cases":[]},{"name":"GeoPathProperty","comment":" Generated by [gpField](#gpField), [gpAs](#gpAs) and [gpPointRadius](#gpPointRadius).\n","args":[],"cases":[]},{"name":"GradientProperty","comment":" Generated by [grX1](#grX1), [grY1](#grY1), [grX2](#grX2), [grY2](#grY2),\n[grR1](#grR1), [grR2](#grR2) and [grStops](#grStops).\n","args":[],"cases":[]},{"name":"GradientScaleProperty","comment":" Generated by [grStart](#grStart), [grStop](#grStop) and [grCount](#grCount).\n","args":[],"cases":[]},{"name":"GraticuleProperty","comment":" Generated by\n[grField](#grField), [grExtent](#grExtent), [grExtentMajor](#grExtentMajor),\n[grExtentMinor](#grExtentMinor), [grStep](#grStep), [grStepMajor](#grStepMajor),\n[grStepMinor](#grStepMinor) and [grPrecision](#grPrecision).\n","args":[],"cases":[]},{"name":"GridAlign","comment":" Generated by [grAlignAll](#grAlignAll), [grAlignEach](#grAlignEach),\n[grAlignNone](#grAlignNone), [grAlignRow](#grAlignRow), [grAlignColumn](#grAlignColumn)\nand [grAlignSignal](#grAlignSignal).\n","args":[],"cases":[]},{"name":"HAlign","comment":" Generated by [haLeft](#haLeft), [haCenter](#haCenter), [haRight](#haRight)\nand [haSignal](#haSignal).\n","args":[],"cases":[]},{"name":"HeatmapProperty","comment":" Generated by [hmField](#hmField), [hmColor](#hmColor), [hmOpacity](#hmOpacity),\n[hmResolve](#hmResolve) and [hmAs](#hmAs).\n","args":[],"cases":[]},{"name":"ImputeMethod","comment":" Generated by [imByMin](#imByMin), [imByMax](#imByMax), [imByMean](#imByMean),\n[imByMedian](#imByMedian) and [imByValue](#imByValue).\n","args":[],"cases":[]},{"name":"ImputeProperty","comment":" Generated by\n<imKeyVals>, [imMethod](#imMethod), [imGroupBy](#imGroupBy) and\n[imValue](#imValue).\n","args":[],"cases":[]},{"name":"InputProperty","comment":" Generated by [inDebounce](#inDebounce), [inElement](#inElement),\n[inOptions](#inOptions), [inLabels](#inLabels), [inMin](#inMin), [inMax](#inMax),\n[inStep](#inStep), [inPlaceholder](#inPlaceholder) and [inAutocomplete](#inAutocomplete).\n","args":[],"cases":[]},{"name":"IsocontourProperty","comment":" Generated by [icField](#icField), [icThresholds](#icThresholds), [icLevels](#icLevels),\n[icNice](#icNice), [icResolve](#icResolve), [icZero](#icZero), [icSmooth](#icSmooth),\n[icScale](#icScale), [icTranslate](#icTranslate) and [icAs](#icAs).\n","args":[],"cases":[]},{"name":"JoinAggregateProperty","comment":" Generated\nby [jaGroupBy](#jaGroupBy), [jaFields](#jaFields), [jaOps](#jaOps) and [jaAs](#jaAs).\n","args":[],"cases":[]},{"name":"Kde2Property","comment":" Generated by [kd2dGroupBy](#kd2GroupBy), [kd2Weight](#kd2Weight),\n[kd2CellSize](#kd2CellSize), [kd2Bandwidth](#kd2Bandwidth), [kd2Counts](#kd2Counts)\nand [kd2As](#kd2As).\n","args":[],"cases":[]},{"name":"KdeProperty","comment":" Generated by [kdGroupBy](#kdGroupBy), [kdCumulative](#kdCumulative), [kdCounts](#kdCounts),\n[kdBandwidth](#kdBandwidth), [kdExtent](#kdExtent), [kdMinSteps](#kdMinSteps),\n[kdMaxSteps](#kdMaxSteps), [kdResolve](#kdResolve), [kdSteps](#kdSteps) and [kdAs](#kdAs).\n","args":[],"cases":[]},{"name":"LayoutProperty","comment":" Generated by\n[loAlign](#loAlign), [loBounds](#loBounds), [loColumns](#loColumns), [loPadding](#loPadding),\n[loPaddingRC](#loPaddingRC), [loOffset](#loOffset), [loOffsetRC](#loOffsetRC),\n[loHeaderBand](#loHeaderBand), [loHeaderBandRC](#loHeaderBandRC), [loFooterBand](#loFooterBand),\n[loFooterBandRC](#loFooterBandRC), [loTitleBand](#loTitleBand) and\n[loTitleBandRC](#loTitleBandRC).\n","args":[],"cases":[]},{"name":"LegendEncoding","comment":" Generated by [enLegend](#enLegend), [enTitle](#enTitle),\n[enLabels](#enLabels), [enSymbols](#enSymbols) and [enGradient](#enGradient).\n","args":[],"cases":[]},{"name":"LegendOrientation","comment":" Generated by [loLeft](#loLeft), [loTopLeft](#loTopLeft), [loTop](#loTop),\n[loTopRight](#loTopRight), [loRight](#loRight), [loBottomRight](#loBottomRight),\n[loBottom](#loBottom), [loBottomLeft](#loBottomLeft), [loNone](#loNone) and\n[loSignal](#loSignal).\n","args":[],"cases":[]},{"name":"LegendProperty","comment":" Generated by [leAria])(#leAria), [leType](#leType), [leDirection](#leDirection),\n[leOrient](#leOrient), [leFill](#leFill), [leOpacity](#leOpacity), [leShape](#leShape),\n[leSize](#leSize), [leStroke](#leStroke), [leStrokeDash](#leStrokeDash), [leStrokeWidth](#leStrokeWidth),\n[leBorderStrokeDash](#leBorderStrokeDash), [leBorderStrokeWidth](#leBorderStrokeWidth),\n[leEncode](#leEncode), [leFormat](#leFormat), [leFormatAsNum](#leFormatAsNum),\n[leFormatAsTemporal](#leFormatAsTemporal), [leFormatAsTemporalUtc](#leFormatAsTemporalUtc),\n[leGridAlign](#leGridAlign), [leClipHeight](#leClipHeight), [leColumns](#leColumns),\n[leColumnPadding](#leColumnPadding), [leRowPadding](#leRowPadding), [leCornerRadius](#leCornerRadius),\n[leFillColor](#leFillColor), [leOffset](#leOffset), [lePadding](#lePadding), [leStrokeColor](#leStrokeColor),\n[leGradientLength](#leGradientLength), [leGradientLabelLimit](#leGradientLabelLimit),\n[leGradientLabelOffset](#leGraidentLabelOffset), [leGradientOpacity](#leGradientOpacity),\n[leGradientThickness](#leGradientThickness), [leGradientStrokeColor](#leGradientStrokeColor),\n[leGradientStrokeWidth](#leGradientStrokeWidth), [leLabelAlign](#leLabelAlign),\n[leLabelBaseline](#leLabelBaseline), [leLabelColor](#leLabelColor), [leLabelFont](#leLabelFont),\n[leLabelFontSize](#leLabelFontSize), [leLabelFontStyle](#leLabelFontStyle),\n[leLabelSeparation](#leLabelSeparation), [leLabelFontWeight](#leLabelFontWeight),\n[leLabelLimit](#leLabelLimit), [leLabelOpacity](#leLabelOpacity), [leLabelOffset](#leLabelOffset),\n[leLabelOverlap](#leLabelOverlap), [leSymbolDash](#leSymbolDash), [leSymbolDashOffset](#leSymbolDashOffset),\n[leSymbolFillColor](#leSymbolFillColor), [leSymbolLimit](#leSymbolLimit), [leSymbolOpacity](#leSymbolOpacity),\n[leSymbolOffset](#leSymbolOffset), [leSymbolSize](#leSymbolSize), [leSymbolStrokeColor](#leSymbolStrokeColor),\n[leSymbolStrokeWidth](#leSymbolStrokeWidth), [leSymbolType](#leSymbolType), [leTickCount](#leTickCount),\n[leTickMinStep](#leTickMinStep), [leTemporalTickCount](#leTemporalTickCount),\n[leTitle](#leTitle), [leTitleAlign](#leTitleAlign), [leTitleAnchor](#leTitleAnchor),\n[leTitleBaseline](#leTitleBaseline), [leTitleColor](#leTitleColor), [leTitleFont](#leTitleFont),\n[leTitleFontStyle](#leTitleFontStyle), [leTitleFontSize](#leTitleFontSize),\n[leTitleFontWeight](#leTitleFontWeight), [leTitleLimit](#leTitleLimit),\n[leTitleLineHeight](#leTitleLineHeight), [leTitleOpacity](#leTitleOpacity),\n[leTitleOrient](#leTitleOrient), [leTitlePadding](#leTitlePadding), [leValues](#leValues),\n[leX](#leX), [leY](#leY) and [leZIndex](#leZIndex).\n","args":[],"cases":[]},{"name":"LegendType","comment":" Generated by [ltSymbol](#ltSymbol), [ltGradient](#ltGradient) and [ltSignal](#ltSignal).\n","args":[],"cases":[]},{"name":"LinkPathProperty","comment":" Generated by [lpSourceY](#lpSourceY), [lpTargetX](#lpTargetX), [lpTargetY](#lpTargetY),\n[lpOrient](#lpOrient), [lpShape](#lpShape), [lpRequire](#lpRequire) and [lpAs](#lpAs).\n","args":[],"cases":[]},{"name":"LinkShape","comment":" Generated by [lsLine](#lsLine), [lsArc](#lsArc), [lsCurve](#lsCurve),\n[lsDiagonal](#lsDiagonal), [lsOrthogonal](#lsOrthogonal) and [lsSignal](#lsSignal).\n","args":[],"cases":[]},{"name":"LoessProperty","comment":" Generated by [lsGroupBy](#lsGroupBy), [lsBandwidth](#lsBandwidth) and\n[lsAs](#lsAs).\n","args":[],"cases":[]},{"name":"LookupProperty","comment":" Generated by [luValues](#luValues),\n[luAs](#luAs) and [luDefault](#luDefault).\n","args":[],"cases":[]},{"name":"Mark","comment":" Generated by [arc](#arc), [area](#area), [image](#image), [group](#group),\n[line](#line), [path](#path), [rect](#rect), [rule](#rule), [shape](#shape),\n[symbol](#symbol), [text](#text) and [trail](#trail).\n","args":[],"cases":[]},{"name":"MarkInterpolation","comment":" Generated by [miBasis](#miBasis), [miBundle](#miBundle), [miCardinal](#miCardinal),\n[miCatmullRom](#miCatmullRom), [miLinear](#miLinear), [miMonotone](#miMonotone),\n[miNatural](#miNatural), [miStepwise](#miStepwise), [miStepAfter](#miStepAfter)\nand [miStepBefore](#miStepBefore).\n","args":[],"cases":[]},{"name":"MarkProperty","comment":" Generated by [maX](#maX), [maX2](#maX2), [maXC](#maXC), [maWidth](#maWidth),\n[maY](#maY), [maY2](#maY2), [maYC](#maYC), [maHeight](#maHeight), [maOpacity](#maOpacity),\n[maFill](#maFill), [maFillOpacity](#maFillOpacity), [maBlend](#maBlend), [maStroke](#maStroke),\n[maStrokeOpacity](#maStrokeOpacity), [maStrokeWidth](#maStrokeWidth), [maStrokeCap](#maStrokeCap),\n[maStrokeDash](#maStrokeDash), [maStrokeDashOffset](#maStrokeDashOffset),\n[maStrokeJoin](#maStrokeJoin), [maStrokeMiterLimit](#maStrokeMiterLimit), [maCursor](#maCursor),\n[maHRef](#maHRef), [maTooltip](#maTooltip), [maZIndex](#maZIndex), [maAlign](#maAlign),\n[maBaseline](#maBaseline), [maCornerRadius](#maCornerRadius), [maCornerRadiusTopLeft](#maCornerRadiusTopLeft),\n[maCornerRadiusTopRight](#maCornerRadiusTopRight), [maCornerRadiusBottomLeft](#maCornerRadiusBottomLeft),\n[maCornerRadiusBottomRight](#maCornerRadiusBottomRight), [maStrokeForeground](#maStrokeForeground),\n[maStrokeOffset](#maStrokeOffset), [maInterpolate](#maInterpolate), [maTension](#maTension),\n[maDefined](#maDefined), [maSize](#maSize), [maStartAngle](#maStartAngle), [maEndAngle](#maEndAngle),\n[maPadAngle](#maPadAngle), [maInnerRadius](#maInnerRadius), [maOuterRadius](#maOuterRadius),\n[maOrient](#maOrient), [maGroupClip](#maGroupClip), [maUrl](#maUrl), [maImage](#maImage),\n[maAspect](#maAspect), [maSmooth](#maSmooth), [maPath](#maPath), [maShape](#maShape),\n[maSymbol](#maSymbol), [maAngle](#maAngle), [maDir](#maDir), [maDx](#maDx), [maDy](#maDy),\n[maEllipsis](#maEllipsis), [maFont](#maFont), [maFontSize](#maFontSize), [maFontWeight](#maFontWeight),\n[maFontStyle](#maFontStyle), [maLineBreak](#maLineBreak), [maLineHeight](#maLineHeight),\n[maLimit](#maLimit), [maRadius](#maRadius), [maScaleX](#maScaleX), [maScaleY](#maScaleY), ]\n[maText](#maText) and [maTheta](#maTheta).\n","args":[],"cases":[]},{"name":"Num","comment":" Generated by [num](#num), [nums](#nums), [numSignal](#numSignal),\n[numSignals](#numSignals), [numList](#numList), [numExpr](#numExpr) and [numNull](#numNull)\n","args":[],"cases":[]},{"name":"Operation","comment":" Generated by [opArgMax](#opArgMax), [opArgMin](#opArgMin), [opCI0](#opCI0),\n[opCI1](#opCI1), [opCount](#opCount), [opDistinct](#opDistinct), [opMax](#opMax),\n[opMean](#opMean), [opMedian](#opMedian), [opMin](#opMin), [opMissing](#opMissing),\n[opProduct](#opProduct), [opQ1](#opQ1), [opQ3](#opQ3), [opStderr](#opStderr),\n[opStdev](#opStdev), [opStdevP](#opStdevP), [opSum](#opSum), [opValid](#opValid),\n[opVariance](#opVariance), [opVarianceP](#opVarianceP). and [opSignal](#opSignal).\n","args":[],"cases":[]},{"name":"Order","comment":" Generated by [ascend](#ascend), [descend](#descend) and [orderSignal](#orderSignal).\n","args":[],"cases":[]},{"name":"Orientation","comment":" Generated by [orHorizontal](#orHorizontal), [orVertical](#orVertical),\n[orRadial](#orRadial) and [orSignal](#orSignal).\n","args":[],"cases":[]},{"name":"OverlapStrategy","comment":" Generated by [osNone](#osNone), [osGreedy](#osGreedy), [osParity](#osParity)\nand [osSignal](#osSignal).\n","args":[],"cases":[]},{"name":"PackProperty","comment":" Generated by [paField](#paField),\n[paSort](#paSort), [paSize](#paSize), [paRadius](#paRadius), [paPadding](#paPadding)\nand [paAs](#paAs).\n","args":[],"cases":[]},{"name":"PartitionProperty","comment":" Generated by [ptField](#ptField), [ptSort](#ptSort), [ptPadding](#ptPadding),\n[ptRound](#ptRound), [ptSize](#ptSize) and [ptAs](#ptAs).\n","args":[],"cases":[]},{"name":"PieProperty","comment":" Generated by [piField](#piField),\n[piStartAngle](#piStartAngle), [piEndAngle](#piEndAngle), [piSort](#piSort) and\n[piAs](#piAs).\n","args":[],"cases":[]},{"name":"PivotProperty","comment":" Generated by [piGroupBy](#piGroupBy),\n[piLimit](#piLimit) and [piOp](#piOp).\n","args":[],"cases":[]},{"name":"Projection","comment":" Generated by [albers](#albers), [albersUsa](#albersUsa),\n[azimuthalEqualArea](#azimuthalEqualArea), [azimuthalEquidistant](#azimuthalEquidistant),\n[conicConformal](#conicConformal), [conicEqualArea](#conicEqualArea),\n[conicEquidistant](#conicEquidistant), [equalEarth](#equalEarth),\n[equirectangular](#equirectangular), [gnomonic](#gnomonic),\n[identityProjection](#identityProjection), [mercator](#mercator), [mollweide](#mollweide),\n[naturalEarth1](#naturalEarth1), [orthographic](#orthographic), [stereographic](#stereographic),\n[transverseMercator](#transverseMercator), [customProjection](#customProjection)\nand [prSignal](#prSignal).\n","args":[],"cases":[]},{"name":"ProjectionProperty","comment":" Generated by\n[prType](#prType), [prClipAngle](#prClipAngle), [prClipExtent](#prClipExtent),\n[prScale](#prScale), [prTranslate](#prTranslate), [prCenter](#prCenter), [prRotate](#prRotate),\n[prPointRadius](#prPointRadius), [prPrecision](#prPrecision), [prFit](#prFit),\n[prExtent](#prExtent), [prSize](#prSize), [prCoefficient](#prCoefficient),\n[prDistance](#prDistance), [prFraction](#prFraction), [prLobes](#prLobes),\n[prParallel](#prParallel), [prRadius](#prRadius), [prRatio](#prRatio), [prSpacing](#prSpacing),\nand [prTilt](#prTilt), [prReflectX](#prReflectX) and [prReflectY](#prReflectY).\n","args":[],"cases":[]},{"name":"QuantileProperty","comment":" Generated by [quGroupBy](#quGroupBy), [quProbs](#quProbs), [quStep](#quStep),\nand [quAs](#quAs).\n","args":[],"cases":[]},{"name":"RegressionMethod","comment":" Generated by [reLinear](#reLinear), [reLog](#reLog), [reExp](#reExp), [rePow](#rePow),\n[reQuad](#reQuad), [rePoly](#rePoly) and [reSignal](#reSignal).\n","args":[],"cases":[]},{"name":"RegressionProperty","comment":" Generated by [reGroupBy](#reGroupBy), [reMethod](#reMethod), [reOrder](#reOrder),\n[reExtent](#reExtent), [reParams](#reParams) and [reAs](#reAs).\n","args":[],"cases":[]},{"name":"Resolution","comment":" Generated by [reShared](#reShared), [reIndependent](#reIndependent) and\n[resolveSignal](#resolveSignal).\n","args":[],"cases":[]},{"name":"Scale","comment":" Generated by [scLinear](#scLinear), [scPow](#scPow), [scSqrt](#scSqrt), [scLog](#scLog),\n[scSymLog](#scSymLoc), [scTime](#scTime), [scUtc](#scUtc), [scOrdinal](#scOrdinal),\n[scBand](#scBand), [scPoint](#scPoint), [scBinOrdinal](#scBinOrdinal),\n[scQuantile](#scQuantile), [scQuantize](#scQuantize),[scThreshold](#scThreshold),\n[scCustom](#scCustom) and [scSignal](#scSignal).\n","args":[],"cases":[]},{"name":"ScaleBins","comment":" Generated by [bsNums](#bsNums), [bsBins](#bsBins) and [bsSignal](#bsSignal).\n","args":[],"cases":[]},{"name":"ScaleDomain","comment":" Generated by [doNums](#doNums), [doStrs](#doStrs) and [doData](#doData).\n","args":[],"cases":[]},{"name":"ScaleNice","comment":" Generated by [niTrue](#niTrue), [niFalse](#niFalse), [niMillisecond](#niMillisecond),\n[niSecond](#niSecond), [niMinute](#niMinute), [niHour](#niHour), [niDay](#niDay),\n[niWeek](#niWeek), [niMonth](#niMonth), [niYear](#niYear), [niTickCount](#niTickCount),\n[niInterval](#niInterval) and [niSignal](#niSignal).\n","args":[],"cases":[]},{"name":"ScaleProperty","comment":" Generated by [scType](#scType), [scDomain](#scDomain),\n[scDomainMax](#scDomainMax), [scDomainMin](#scDomainMin), [scDomainMid](#scDomainMid),\n[scDomainRaw](#scDomainRaw), [scRange](#scRange), [scBins](#scBins), [scReverse](#scReverse),\n[scRound](#scRound), [scClamp](#scClamp), [scInterpolate](#scInterpolate),\n[scPadding](#scPadding), [scNice](#scNice), [scZero](#scZero), [scExponent](#scExponent),\n[scConstant](#scConstant), [scBase](#scBase), [scAlign](#scAlign),\n[scDomainImplicit](#scDomainImplicit), [scPaddingInner](#scPaddingInner),\n[scPaddingOuter](#scPaddingOuter) and [scRangeStep](#scRangeStep).\n","args":[],"cases":[]},{"name":"ScaleRange","comment":" Generated by [raWidth](#raWidth), [raHeight](#raHeight), [raSymbol](#raSymbol),\n[raCategory](#raCategory), [raDiverging](#raDiverging), [raOrdinal](#raOrdinal),\n[raRamp](#raRamp), [raHeatmap](#raHeatmap), [raNums](#raNums), [raStrs](#raStrs),\n[raValues](#raValues), [raScheme](#raScheme), [raData](#raData), [raStep](#raStep),\n[raCustomDefault](#raCustomDefault) and [raSignal](#raSignal).\n","args":[],"cases":[]},{"name":"Side","comment":" Generated by [siLeft](#siLeft), [siRight](#siRight), [siTop](#siTop),\n[siBottom](#siBottom) and [siSignal](#siSignal).\n","args":[],"cases":[]},{"name":"SignalBind","comment":" Generated by [sbAny](#sbAny), [sbContainer](#sbContainer) and [sbNone](#sbNone).\n","args":[],"cases":[]},{"name":"SignalProperty","comment":" Generated by [siName](#siName), [siBind](#siBind),\n[siDescription](#siDescription), [siInit](#siInit), [siOn](#siOn), [siUpdate](#siUpdate),\n[siReact](#siReact), [siValue](#siValue) and [siPushOuter](#siPushOuter).\n","args":[],"cases":[]},{"name":"SortProperty","comment":" Generated by [soAscending](#soAscending), [soDescending](#soDescending),\n[soOp](#soOp), [soByField](#soByField) and [soSignal](#soSignal).\n","args":[],"cases":[]},{"name":"Source","comment":" Generated by [srData](#srData) and [srFacet](#srFacet).\n","args":[],"cases":[]},{"name":"Spiral","comment":" Generated by [spArchimedean](#spArchimedean), [spRectangular](#spRectangular)\nand [spSignal](#spSignal).\n","args":[],"cases":[]},{"name":"StackOffset","comment":" Generated by [stZero](#stZero), [stCenter](#stCenter), [stNormaize](#stNormalize)\nand [stOffset](#stOffset).\n","args":[],"cases":[]},{"name":"StackProperty","comment":" Generated by [stField](#stField),\n[stGroupBy](#stGroupBy), [stSort](#stSort), [stOffset](#stOffset) and\n[stAs](#stAs).\n","args":[],"cases":[]},{"name":"Str","comment":" Generated by [str](#str), [strs](#strs), [strList](#strList), [strSignal](#strSignal),\n[strSignals](#strSignals), [strExpr](#strExpr) and [strNull](#strNull).\n","args":[],"cases":[]},{"name":"StrokeCap","comment":" Generated by [caButt](#caButt), [caRound](#caRound), [caSquare](#caSquare)\nand [caSignal](#caSignal).\n","args":[],"cases":[]},{"name":"StrokeJoin","comment":" Generated by [joMiter](#joMiter), [joRound](#joRound), [joBevel](#joBevel)\nand [joSignal](#joSignal)\n","args":[],"cases":[]},{"name":"Symbol","comment":" Generated by [symCircle](#symCircle), [symSquare](#symSquare), [symCross](#symCross),\n[symWedge](#symWedge), [symArrow](#symArrow), [symStroke](#symStroke),\n[symDiamond](#symDiamond), [symTriangle](#symTriangle), [symTriangleUp](#symTriangleUp),\n[symTriangleDown](#symTriangleDown), [symTriangleLeft](#symTriangleLeft),\n[symTriangleRight](#symTriangleRight), [symPath](#symPath) and [symSignal](#symSignal).\n","args":[],"cases":[]},{"name":"TextDirection","comment":" Generated by [tdLeftToRight](#tdLeftToRight), [tdRightToLeft](#tdRightToLeft)\nand [tdSignal](#tdSignal).\n","args":[],"cases":[]},{"name":"TimeBinProperty","comment":" Generated by [tbUnits](#tbUnits),[tbStep](#tbStep), [tbTimezone](#tbTimezone),\n[tbInterval](#tbInterval), [tbExtent](#tbExtent), [tbMaxBins](#tbMaxBins),\n[tbSignal](#tbSignal) and [tbAs](#tbAs).\n","args":[],"cases":[]},{"name":"TimeUnit","comment":" Generated by [year](#year), [quarter](#quarter), [month](#month), [date](#date),\n[week](#week), [day](#day), [dayOfYear](#dayOfYear), [hour](#hour), [minute](#minute),\n[second](#second), [millisecond](#millisecond) and [tuSignal](#tuSignal).\n","args":[],"cases":[]},{"name":"Timezone","comment":" Generated by [tzLocal](#tzLocal), [tzUtc](#tzUtc) and [tzSignal](#tzSignal).\n","args":[],"cases":[]},{"name":"TitleElement","comment":" Generated by [teTitle](#teTitle), [teSubtitle](#teSubtitle) and [teGroup](#teGroup).\n","args":[],"cases":[]},{"name":"TitleFrame","comment":" Generated by [tfBounds](#tfBounds), [tfGroup](#tfGroup) and [tfSignal](#tfSignal).\n","args":[],"cases":[]},{"name":"TitleProperty","comment":" Generated by [tiAria](#tiAria), [tiOrient](#tiOrient), [tiAnchor](#tiAnchor),\n[tiAngle](#tiAngle), [tiAlign](#tiAlign), [tiBaseline](#tiBaseline), [tiColor](#tiColor),\n[tiDx](#tiDx), [tiDy](#tiDy), [tiEncodeElements](#tiEncodeElements), [tiFont](#tiFont),\n[tiFontSize](#tiFontSize), [tiFontStyle](#tiFontStyle), [tiFontWeight](#tiFontWeight),\n[tiFrame](#tiFrame), [tiLimit](#tiLimit), [tiLineHeight](#tiLineHeight), [tiOffset](#tiOffset),\n[tiSubtitle](#tiSubtitle), [tiSubtitleColor](#tiSubtitleColor), [tiSubtitleFont](#tiSubtitleFont),\n[tiSubtitleFontSize](#tiSubtitleFontSize), [tiSubtitleFontStyle](#tiSubtitleFontStyle),\n[tiSubtitleFontWeight](#tiSubtitleFontWeight), [tiSubtitlePadding](#tiSubtitlePadding)\nand [tiZIndex](#tiZIndex).\n","args":[],"cases":[]},{"name":"TopMarkProperty","comment":" Generated by [mAria](#mAria), [mType](#mType), [mClip](#mClip),\n[mDescription](#mDescription), [mEncode](#mEncode), [mFrom](#mFrom),\n[mInteractive](#mInteractive), [mKey](#mKey), [mName](#mName), [mOn](#mOn),\n[mSort](#mSort), [mTransform](#mTransform), [mRole](#mRole), [mStyle](#mStyle),\n[mGroup](#mGroup) and [mZIndex](#mZIndex).\n","args":[],"cases":[]},{"name":"Transform","comment":" Generated by [trAggregate](#trAggregate), [trBin](#trBin), [trCollect](#trCollect),\n[trCountPattern](#trCountPattern), [trCross](#trCross), [trCrossFilter](#trCrossFilter),\n[trCrossFilterAsSignal](#trCrossFilterAsSignal), [trDensity](#trDensity),\n[trDotBin](#trDotBin), [trExtent](#trExtent), [trExtentAsSignal](#trExtentAsSignal),\n[trFilter](#trFilter), [trFlatten](#trFlatten), [trFlattenWithIndex](#trFlattenWithIndex),\n[trFlattenAs](#trFlattenAs), [trFlattenWithIndexAs](#trFlattenWithIndexAs),\n[trFold](#trFold), [trFoldAs](#trFoldAs), [trForce](#trForce), [trFormula](#trFormula),\n[trFormulaInitOnly](#trFormulaInitOnly), [trGeoJson](#trGeoJson), [trGeoPath](#trGeoPath),\n[trGeoPoint](#trGeoPoint), [trGeoPointAs](#trGeoPointAs), [trGeoShape](#trGeoShape),\n[trGraticule](#trGraticule), [trHeatmap](#trHeatmap) [trIdentifier](#trIdentifier),\n[trImpute](#trImpute), [trIsocontour](#trIsocontour), [trJoinAggregate](#trJoinAggregate),\n[trKde](#trKde), [trKde2d](#trKde2d), [trLinkPath](#trLinkPath), [trLookup](#trLookup),\n[trNest](#trNest), [trPack](#trPack), [trPartition](#trPartition), [trPie](#trPie),\n[trPivot](#trPivot), [trProject](#trProject), [trResolveFilter](#trResolveFilter),\n[trSample](#trSample), [trSequence](#trSequence), [trStack](#trStack),\n[trStratify](#trStratify), [trTree](#trTree), [trTreeLinks](#trTreeLinks),\n[trTreemap](#trTreemap), [trVoronoi](#trVoronoi), [trWindow](#trWindow) and\n[trWordCloud](#trWordCloud).\n","args":[],"cases":[]},{"name":"TreeMethod","comment":" Generated by [meTidy](#meTidy), [meCluster](#meCluster) and [meSignal](#meSignal).\n","args":[],"cases":[]},{"name":"TreeProperty","comment":" Generated by [teField](#teField), [teSort](#teSort), [teMethod](#teMethod),\n[teSeparation](#teSeparation), [teSize](#teSize), [teNodeSize](#teNodeSize) and\n[teAs](#teAs).\n","args":[],"cases":[]},{"name":"TreemapMethod","comment":" Generated by [tmSquarify](#tmSquarify), [tmResquarify](#tmResquarify),\n[tmBinary](#tmBinary), [tmDice](#tmDice), [tmSlice](#tmSlice), [tmSliceDice](#tmSliceDice)\nand [tmSignal](#tmSignal).\n","args":[],"cases":[]},{"name":"TreemapProperty","comment":" Generated by [tmField](#tmField), [tmSort](#tmSort), [tmMethod](#tmMethod),\n[tmPadding](#tmPadding), [tmPaddingInner](#tmPaddingInner), [tmPaddingOuter](#tmPaddingOuter),\n[tmPaddingTop](#tmPaddingTop), [tmPaddingRight](#tmPaddingRight), [tmPaddingBottom](#tmPaddingBottom),\n[tmPaddingLeft](#tmPaddingLeft), [tmRatio](#tmRatio), [tmRound](#tmRound), [tmSize](#tmSize)\nand [tmAs](#tmAs).\n","args":[],"cases":[]},{"name":"TriggerProperty","comment":" Generated by [tgInsert](#tgInsert), [tgRemove](#tgRemove), [tgRemoveAll](#tgRemoveAll),\n[tgToggle](#tgToggle) and [tgModifyValues](#tgModifyValues).\n","args":[],"cases":[]},{"name":"VAlign","comment":" Generated by [vaTop](#vaTop), [vaMiddle](#vaMiddle), [vaBottom](#vaBottom),\n[vaLineTop](#vaLineTop), [vaLineBottom](#vaLineBottom), [vaAlphabetic](#vaAlphabetic)\nand [vaSignal](#vaSignal).\n","args":[],"cases":[]},{"name":"VProperty","comment":" Top-level Vega properties (see the\n[specification documentation](https://vega.github.io/vega/docs/specification/)).\n\n**Data properties** specify the input data to be visualized. Generated by\n[`dataSource`](#dataSource) that can collect together data tables such as those\nread from a URL or generated inline.\n\n**Signal properties** specify dynamic variables that respond reactively to other\nsignals or interactions. Generated by [`signals`](#signals).\n\n**Scale properties** map data values to visual channels such as position, or color.\nGenerated by [`scales`](#scales).\n\n**Projection properties** specify how geospatial data referenced with\nlongitude, latitude coordinates are projected onto a plane for visualization.\nGenerated by [`projections`](#projections).\n\n**Axis properties** specify how spatial scale mappings are visualized, such as with\ntick marks, grid lines and labels. Generated by [`axes`](#axes).\n\n**Legend properties** specify how visual scale mappings such as color, shape and\nsize are visualized. Generated by [`legends`](#legends).\n\n**Title properties** specify how a visualization title should appear. Generated\nby [`title`](#title).\n\n**Layout properties** specify how a group of visual marks are organised within\na grid. This allows visualizations to be composed of other visualizations, for\nexample in a dashboard or collection of small multiples. Generated by [`layout`](#layout).\n\n**Mark properties** specify how to visually encode data with graphical primitives\nsuch as points, lines and other symbols. Generated by [`marks`](#marks).\n\n**Top-level group encodings** specify the appearance of the chart's data rectangle.\nFor example setting the background color of the plotting area. Generated by\n[`encode`](#encode).\n\n**Config properties** specify default settings of a specification. Allows consistent\nand easily modifiable styles to be applied to a visualization. Generated by\n[`config`](#config).\n\n**Supplementary properties** add metadata and some styling to one or more visualizations.\nGenerated by [`width`](#width), [`height`](#height), [`padding`](#padding),\n[`paddings`](#paddings), [`autosize`](#autosize), [`background`](#background),\n[`description`](#description) and [`userMeta`](#userMeta).\n\n","args":[],"cases":[]},{"name":"Value","comment":" Generated by [vStr](#vStr), [vStrs](#vStrs), [vNum](#vNum),\n[vNums](#vNums), [vTrue](#vTrue), [vFalse](#vFalse), [vBoos](#vBoos),\n[vObject](#vObject), [keyValue](#keyValue), [vValues](#vValues), [vSignal](#vSignal),\n[vColor](#vColor), [vGradient](#vGradient), [vGradientScale](#vGradientScale),\n[vField](#vField), [vScale](#vScale), [vScaleField](#vScaleField), [vBand](#vBand),\n[vExponent](#vExponent), [vMultiply](#vMultiply), [vOffset](#vOffset),\n[vRound](#vRound), [vNull](#vNull) and [ifElse](#ifElse).\n","args":[],"cases":[]},{"name":"VoronoiProperty","comment":" Generated by [voExtent](#voExtent), [voSize](#voSize) and [voAs](#voAs).\n","args":[],"cases":[]},{"name":"WOperation","comment":" Generated by [woRowNumber](#woRowNumber), [woRank](#woRank), [woDenseRank](#woDenseRank),\n[woPercentRank](#woPercentRank), [woCumeDist](#woCumeDist), [woPercentile](#woPercentile),\n[woLag](#woLag), [woLead](#woLead), [woFirstValue](#woFirstValue), [woLastValue](#woLastValue),\n[woNthValue](#woNthValue) [woPrevValue](#woPrevValue), [woNextValue](#woNextValue)\nand [woSignal](#woSignal).\n","args":[],"cases":[]},{"name":"WindowOperation","comment":" Generated by [wnOperation](#wnOperation), [wnOperationOn](#wnOperationOn) and\n[wnAggOperation](#wnAggOperation).\n","args":[],"cases":[]},{"name":"WindowProperty","comment":" Generated by [wnSort](#wnSort), [wnGroupBy](#wnGroupBy), [wnFrame](#wnFrame)\nand [wnIgnorePeers](#wnIgnorePeers).\n","args":[],"cases":[]},{"name":"WordcloudProperty","comment":" Generated by\n[wcFont](#wcFont), [wcFontStyle](#wcFontStyle), [wcFontWeight](#wcFontWeight),\n[wcFontSize](#wcFontSize), [wcFontSizeRange](#wcFontSizeRange), [wcPadding](#wcPadding),\n[wcRotate](#wcRotate), [wcText](#wcText), [wcSize](#wcSize), [wcSprial](#wcSpiral)\nand [wcAs](#wcAs).\n","args":[],"cases":[]}],"aliases":[{"name":"Data","comment":" Convenience type annotation label for use with data generation functions.\nGenerated by [dataSource](#dataSource) but is also useful when creating your own\ndata generating functions. For example:\n\n    myData : Int -> Data\n    myData yr =\n        dataSource\n            [ data \"population\" [ daSource \"pop\" ]\n                |> transform [ trFilter (expr (\"datum.year == \" ++ toString yr)) ]\n            ]\n\n","args":[],"type":"( Vega.VProperty, Vega.Spec )"},{"name":"DataColumn","comment":" A single column of data. Generated when creating inline data with\n[dataColumn](#dataColumn).\n","args":[],"type":"List.List Vega.LabelledSpec"},{"name":"DataRow","comment":" A single row of data. Generated when creating inline data with [dataRow](#dataRow).\n","args":[],"type":"Vega.Spec"},{"name":"DataTable","comment":" A single table of data (collection of `dataColumn` specifications).\nGenerated by [data](#data), [dataFromColumns](#dataFromColumns),\n[dataFromRows](#dataFromRows), [on](#on) and [transform](#transform).\n","args":[],"type":"List.List Vega.LabelledSpec"},{"name":"Spec","comment":" A Vega specification. Specs can be (and usually are) nested.\nThey can range from a single Boolean value up to the entire Vega specification.\n","args":[],"type":"Json.Encode.Value"},{"name":"Trigger","comment":" Generated by [trigger](#trigger).\n","args":[],"type":"Vega.Spec"}],"values":[{"name":"abCenter","comment":" Indicates axis ticks for band scales should be centered on each band.\n","type":"Vega.AxisTickBand"},{"name":"abExtent","comment":" Indicates axis ticks for band scales should be aligned with the extent of\neach band.\n","type":"Vega.AxisTickBand"},{"name":"aeAxis","comment":" Reference the axis element when customising an axis.\n","type":"Vega.AxisElement"},{"name":"aeDomain","comment":" Reference the domain (line) element when customising an axis.\n","type":"Vega.AxisElement"},{"name":"aeGrid","comment":" Reference the grid element when customising an axis.\n","type":"Vega.AxisElement"},{"name":"aeLabels","comment":" Reference the label element when customising an axis.\n","type":"Vega.AxisElement"},{"name":"aeTicks","comment":" Reference the tick element when customising an axis.\n","type":"Vega.AxisElement"},{"name":"aeTitle","comment":" Reference the title element when customising an axis.\n","type":"Vega.AxisElement"},{"name":"agAs","comment":" The output field names generated when performing an aggregation transformation.\nThe list of field names should align with the fields operations provided by `agFields`\nand `agOps`. If not provided, automatic names are generated by appending `_field`\nto the operation name.\n","type":"List.List String.String -> Vega.AggregateProperty"},{"name":"agCross","comment":" Whether or not the full cross-product of all `groupby` values should\nbe included in the output of an aggregation transformation.\n","type":"Vega.Boo -> Vega.AggregateProperty"},{"name":"agDrop","comment":" Whether or not empty (zero count) groups should be dropped when in an\naggregation transformation.\n","type":"Vega.Boo -> Vega.AggregateProperty"},{"name":"agFields","comment":" Data fields to compute aggregate functions when performing an\naggregation transformation. The list of fields should align with the operations\nand field names provided by `agOps` and `agAs`. If no fields and operations are\nspecified, a count aggregation will be used by default.\n","type":"List.List Vega.Field -> Vega.AggregateProperty"},{"name":"agGroupBy","comment":" Data fields to group by when performing an aggregation transformation.\nIf not specified, a single group containing all data objects will be used.\n","type":"List.List Vega.Field -> Vega.AggregateProperty"},{"name":"agKey","comment":" Field to act as a unique key when performing an [agGroupBy](#agGroupBy)\naggregation. This can speed up the aggregation but should only be used when there\nis redundancy in the list of groupBy fields (as there is when binning for example).\n\n    transform\n        [ trBin (field \"examScore\") (nums [ 0, 100 ]) []\n        , trAggregate\n            [ agKey (field \"bin0\")\n            , agGroupBy [ field \"bin0\", field \"bin1\" ]\n            , agOps [ opCount ]\n            , agAs [ \"count\" ]\n            ]\n        ]\n\n","type":"Vega.Field -> Vega.AggregateProperty"},{"name":"agOps","comment":" Aggregation operations to apply to the fields when performing an\naggregation transformation. The list of operations should align with the fields\noutput field names provided by `agFields` and `agAs`.\n","type":"List.List Vega.Operation -> Vega.AggregateProperty"},{"name":"albers","comment":" An Albers map projection.\n","type":"Vega.Projection"},{"name":"albersUsa","comment":" An Albers USA map projection that combines continental USA with Alaska and Hawaii.\n","type":"Vega.Projection"},{"name":"anEnd","comment":" Anchor some text at its end.\n","type":"Vega.Anchor"},{"name":"anMiddle","comment":" Anchor some text in its start.\n","type":"Vega.Anchor"},{"name":"anStart","comment":" Anchor some text at its start.\n","type":"Vega.Anchor"},{"name":"anchorSignal","comment":" Indicate that an anchor position is to be determined by a named signal.\nThe signal should generate one of `start`, `middle` or `end`.\n","type":"String.String -> Vega.Anchor"},{"name":"arDescription","comment":" Description to be provided in [ARIA tag](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nwhen generating SVG output. If not specified, the an auto-generated description\nwill be provided.\n","type":"Vega.Str -> Vega.Aria"},{"name":"arDisable","comment":" Disable [ARIA attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nwhen generating SVG output. Default is that Aria is enabled.\n","type":"Vega.Aria"},{"name":"arEnable","comment":" Enable [ARIA attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nwhen generating SVG output. Default is that Aria is enabled, so this is only useful\nwhen overriding more global disabling of Aria attributes.\n","type":"Vega.Aria"},{"name":"arc","comment":" An arc mark.\n","type":"Vega.Mark"},{"name":"area","comment":" An area mark.\n","type":"Vega.Mark"},{"name":"arrow","comment":" [Apache arrow](https://observablehq.com/@theneuralbit/introduction-to-apache-arrow) data file format.\n","type":"Vega.FormatProperty"},{"name":"asContent","comment":" Interpret visualization dimensions to be for the data rectangle (external\npadding added to this size).\n","type":"Vega.Autosize"},{"name":"asFit","comment":" Interpret visualization dimensions to be for the entire visualization (data\nrectangle is shrunk to accommodate external decorations padding).\n","type":"Vega.Autosize"},{"name":"asFitX","comment":" Interpret visualization width to be for the entire visualization (data\nrectangle is shrunk to accommodate external decorations and padding).\n","type":"Vega.Autosize"},{"name":"asFitY","comment":" Interpret visualization height to be for the entire visualization (data\nrectangle is shrunk to accommodate external padding).\n","type":"Vega.Autosize"},{"name":"asNone","comment":" No autosizing to be applied.\n","type":"Vega.Autosize"},{"name":"asPad","comment":" Automatically expand size of visualization from the given dimensions in order\nto fit in all supplementary decorations (legends etc.).\n","type":"Vega.Autosize"},{"name":"asPadding","comment":" Interpret visualization width to be for the entire visualization (data\nrectangle is shrunk to accommodate external padding).\n","type":"Vega.Autosize"},{"name":"asResize","comment":" Recalculate autosizing on every view update.\n","type":"Vega.Autosize"},{"name":"asSignal","comment":" Indicate that an auto-sizing rule is to be determined by a named signal.\n","type":"String.String -> Vega.Autosize"},{"name":"ascend","comment":" Indicate ascending order when sorting.\n","type":"Vega.Order"},{"name":"autosize","comment":" Indicate how the view is sized.\n","type":"List.List Vega.Autosize -> ( Vega.VProperty, Vega.Spec )"},{"name":"axAll","comment":" All axis types to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axAria","comment":" [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) properties\nfor providing accessible SVG output associated with an axis. If an empty list is\nprovided, ARIA tagging will be switched off.\n","type":"List.List Vega.Aria -> Vega.AxisProperty"},{"name":"axBand","comment":" Band axes to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axBandPosition","comment":" Interpolation fraction indicating where, for band scales, axis ticks\nshould be positioned. A value of 0 places ticks at the left edge of their bands.\nA value of 0.5 places ticks in the middle of their bands.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axBottom","comment":" Bottom axes to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axDomain","comment":" Whether or not the domain (the axis baseline) should be included as part of\nan axis.\n","type":"Vega.Boo -> Vega.AxisProperty"},{"name":"axDomainCap","comment":" Stroke cap ending style for an axis baseline (domain). To guarantee valid\ncap names, use [strokeCapStr](#strokeCapStr) to generate the parameter.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axDomainColor","comment":" Color of an axis domain line.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axDomainDash","comment":" Stroke dash of an axis's domain line as a list of dash-gap lengths or empty\nlist for solid line.\n","type":"List.List Vega.Value -> Vega.AxisProperty"},{"name":"axDomainDashOffset","comment":" Pixel offset from which to start the domain dash list.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axDomainOpacity","comment":" Opacity of an axis domain line.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axDomainWidth","comment":" Width in pixels of an axis domain line.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axEncode","comment":" Mark encodings for custom axis styling.\n","type":"List.List ( Vega.AxisElement, List.List Vega.EncodingProperty ) -> Vega.AxisProperty"},{"name":"axFormat","comment":" The format specifier pattern for axis labels. For numerical values, must be\na legal [d3-format specifier](https://github.com/d3/d3-format#locale_format).\nFor date-time values, must be a legal\n[d3-time-format](https://github.com/d3/d3-time-format#locale_format) specifier.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axFormatAsNum","comment":" Indicate that axis labels should be formatted as numbers. To control the precise\nnumeric format, additionally use [axFormat](#axFormat) providing a\n[d3 numeric format string](https://github.com/d3/d3-format#locale_format).\n","type":"Vega.AxisProperty"},{"name":"axFormatAsTemporal","comment":" Indicate that axis labels should be formatted as dates/times. To control the\nprecise temporal format, additionally use [axFormat](#axFormat) providing a\n[d3 date/time format string](https://github.com/d3/d3-time-format#locale_format).\n","type":"Vega.AxisProperty"},{"name":"axFormatAsTemporalUtc","comment":" Indicate that axis labels should be formatted as UTC dates/times.\n","type":"Vega.AxisProperty"},{"name":"axGrid","comment":" Whether or not grid lines should be included as part of an axis.\n","type":"Vega.Boo -> Vega.AxisProperty"},{"name":"axGridCap","comment":" Stroke cap ending style for gridlines. To guarantee valid cap names, use\n[strokeCapStr](#strokeCapStr) to generate the parameter.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axGridColor","comment":" Color of an axis's grid lines.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axGridDash","comment":" Stroke dash of an axis's grid lines as a list of dash-gap lengths or empty\nlist for solid lines.\n","type":"List.List Vega.Value -> Vega.AxisProperty"},{"name":"axGridDashOffset","comment":" Pixel offset from which to start the grid line dash list.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axGridOpacity","comment":" Opacity of an axis's grid lines.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axGridScale","comment":" Name of the scale to use for including grid lines. By default grid lines are\ndriven by the same scale as the ticks and labels.\n","type":"String.String -> Vega.AxisProperty"},{"name":"axGridWidth","comment":" Width of an axis's grid lines in pixel units.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelAlign","comment":" Horizontal alignment of axis tick labels.\n","type":"Vega.HAlign -> Vega.AxisProperty"},{"name":"axLabelAngle","comment":" Angle of text for an axis.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelBaseline","comment":" Vertical alignment of axis tick labels.\n","type":"Vega.VAlign -> Vega.AxisProperty"},{"name":"axLabelBound","comment":" Indicate how or if labels should be hidden if they exceed the axis range. If the\nparameter is [numNull](#numNull), no check for label size is made. A number specifies\nthe permitted overflow in pixels that can be tolerated.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelColor","comment":" Color of an axis label.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axLabelFlush","comment":" Indicate how labels at the beginning or end of an axis should be aligned\nwith the scale range. The parameter represents a pixel distance threshold. Labels\nwith anchor coordinates within this threshold distance for an axis end-point will be\nflush-adjusted. If [numNull](#numNull), no flush alignment will be applied.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelFlushOffset","comment":" Number of pixels by which to offset flush-adjusted labels.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelFont","comment":" Font name of an axis label.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axLabelFontSize","comment":" Font size of an axis label.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelFontStyle","comment":" Font style of an axis label such as `str \"normal\"` or `str \"italic\"`.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axLabelFontWeight","comment":" Font weight of an axis label. This can be a number (e.g. `vNum 300`)\nor text (e.g. `vStr \"bold\"`).\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axLabelLimit","comment":" Maximum length in pixels of axis tick labels.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelLineHeight","comment":" Line height in pixels for multi-line label text or label text with\n[valineTop](#vaLineTop) or [vaLineBottom](#vaLineBottom) baselines.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelOffset","comment":" Offset in pixels to apply to labels, in addition to [axTickOffset](#axTickOffset).\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelOpacity","comment":" Opacity of an axis label.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelOverlap","comment":" Strategy to use for resolving overlap of axis labels.\n","type":"Vega.OverlapStrategy -> Vega.AxisProperty"},{"name":"axLabelPadding","comment":" Padding in pixels between labels and ticks.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabelSeparation","comment":" Minimum separation that must be between labels for them to be considered\nnon-overlapping. Ignored if [axLabelOverlap](#axLabelOverlap) resolution not enabled.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axLabels","comment":" Whether or not if labels should be included as part of an axis.\n","type":"Vega.Boo -> Vega.AxisProperty"},{"name":"axLeft","comment":" Left axes to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axMaxExtent","comment":" Maximum extent in pixels that axis ticks and labels should use.\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axMinExtent","comment":" The minimum extent in pixels that axis ticks and labels should use. This\ndetermines a minimum offset value for axis titles.\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axOffset","comment":" Orthogonal offset in pixels by which to displace the axis from its position\nalong the edge of the chart.\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axPosition","comment":" The anchor position of the axis in pixels. For x-axes with top or bottom\norientation, this sets the axis group x coordinate. For y-axes with left or right\norientation, this sets the axis group y coordinate.\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axRight","comment":" Right axes to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axTemporalTickCount","comment":" Tick interval for a temporal axis. The first parameter is the type of temporal\ninterval to use and the second the number of steps of that interval between ticks.\ne.g. to specify a tick is requested at 3 month intervals (January, April, July, October):\n\n    ax =\n        axes\n            << axis \"xScale\" siBottom [ axTemporalTickCount month (num 3) ]\n\nIf the second parameter is not a positive value, the number of ticks will be\nauto-generated for the given interval type.\n\n","type":"Vega.TimeUnit -> Vega.Num -> Vega.AxisProperty"},{"name":"axTickBand","comment":" Specify how axis ticks should be aligned when using a band scale.\n","type":"Vega.AxisTickBand -> Vega.AxisProperty"},{"name":"axTickCap","comment":" Line capping style for axis ticks. To guarantee valid cap names, use\n[strokeCapStr](#strokeCapStr) to generate the parameter.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axTickColor","comment":" Color of an axis's ticks.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axTickCount","comment":" Desired number of ticks, for axes visualizing quantitative scales. The\nresulting number may be different so that values are âniceâ (multiples of 2, 5, 10)\nand lie within the underlying scaleâs range.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTickDash","comment":" Stroke dash of an axis's tick marks as a list of dash-gap lengths or empty\nlist for solid lines.\n","type":"List.List Vega.Value -> Vega.AxisProperty"},{"name":"axTickDashOffset","comment":" Pixel offset from which to start the tick dash list.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTickExtra","comment":" Whether or not an extra axis tick should be added for the initial\nposition of an axis. This is useful for styling axes for band scales such that\nticks are placed on band boundaries rather in the middle of a band.\n","type":"Vega.Boo -> Vega.AxisProperty"},{"name":"axTickMinStep","comment":" Minimum desired step between axis ticks in scale domain units.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTickOffset","comment":" Offset in pixels of an axis's ticks, labels and gridlines.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTickOpacity","comment":" Opacity of an axis's ticks.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTickRound","comment":" Whether or not pixel position values for an axis's ticks should be\nrounded to the nearest integer.\n","type":"Vega.Boo -> Vega.AxisProperty"},{"name":"axTickSize","comment":" Size in pixels of axis ticks.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTickWidth","comment":" Width in pixels of an axis's ticks.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTicks","comment":" Whether or not ticks should be included as part of an axis.\n","type":"Vega.Boo -> Vega.AxisProperty"},{"name":"axTitle","comment":" A title for an axis. To specify a multi-line axis title, provide an array of\ntitle lines, one element per line. For example,\n\n    axTitle (strs [ \"Speed\", \"(kph)\" ])\n\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axTitleAlign","comment":" Horizontal alignment of an axis's title.\n","type":"Vega.HAlign -> Vega.AxisProperty"},{"name":"axTitleAnchor","comment":" The anchor position for placing an axis title.\n","type":"Vega.Anchor -> Vega.AxisProperty"},{"name":"axTitleAngle","comment":" Angle of an axis's title text.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTitleBaseline","comment":" Vertical alignment of an axis's title.\n","type":"Vega.VAlign -> Vega.AxisProperty"},{"name":"axTitleColor","comment":" Color of an axis's title.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axTitleFont","comment":" Font to be used for an axis's title.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axTitleFontSize","comment":" Size of font in pixels for an axis's title.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTitleFontStyle","comment":" Font style of an axis title such as `str \"normal\"` or `str \"italic\"`.\n","type":"Vega.Str -> Vega.AxisProperty"},{"name":"axTitleFontWeight","comment":" Font weight of an axis's title. This can be a number (e.g. `vNum 300`)\nor text (e.g. `vStr \"bold\"`).\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axTitleLimit","comment":" Maximum allowed length of an axis's title.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTitleLineHeight","comment":" Line height in pixels of each line of text in a multi-line axis title.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTitleOpacity","comment":" Opacity of an axis's title.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTitlePadding","comment":" Offset in pixels between an axis's labels and title.\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axTitleX","comment":" X position of an axis title relative to the axis group, overriding\nthe standard layout.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTitleY","comment":" Y position of an axis title relative to the axis group, overriding\nthe standard layout.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axTop","comment":" Top axes to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axTranslate","comment":" Translate the axis coordinate system by a give number of pixels. Can be used\nfor detailed alignment of axes when generating precise SVG output.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axValues","comment":" Explicitly set an axis tick and label values.\n","type":"Vega.Value -> Vega.AxisProperty"},{"name":"axX","comment":" x-axes to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axY","comment":" y-axes to be configured with [cfAxis](#cfAxis).\n","type":"Vega.AxisType"},{"name":"axZIndex","comment":" The z-index indicating the layering of an axis group relative to other axis,\nmark and legend groups. The default value is 0 and axes and grid lines are drawn\nbehind any marks defined in the same specification level. Higher values (1) will\ncause axes and grid lines to be drawn on top of marks.\n","type":"Vega.Num -> Vega.AxisProperty"},{"name":"axes","comment":" Create the axes used to visualize spatial scale mappings.\n\n    ax =\n        axes\n            << axis \"myXScale\" siBottom [ axTitle (str \"Population\") ]\n            << axis \"myYScale\" siLeft [ axTickCount (num 5) ]\n\n","type":"List.List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"},{"name":"axis","comment":" Create an axis used to visualize a spatial scale mapping. The first\nparameter is the name of the scale backing this axis, the second the position of\nthe axis relative to the data rectangle and the third a list of optional axis\nproperties. For example,\n\n    axes\n        << axis \"xScale\" siBottom [ axTitle \"Population\", axZIndex (num 1) ]\n\n","type":"String.String -> Vega.Side -> List.List Vega.AxisProperty -> List.List Vega.Spec -> List.List Vega.Spec"},{"name":"azimuthalEqualArea","comment":" An azimuthal equal area map projection.\n","type":"Vega.Projection"},{"name":"azimuthalEquidistant","comment":" An azimuthal equidistant map projection.\n","type":"Vega.Projection"},{"name":"background","comment":" The fill background color of a visualization. This should be specified as a\n[color string](https://vega.github.io/vega/docs/types/#Color) or signal (via\n[strSignal](#strSignal)) representing a color.\n","type":"Vega.Str -> ( Vega.VProperty, Vega.Spec )"},{"name":"bcFlush","comment":" Only the width and height values of a group mark or legend are to determine\nthe extent of a sub-plot or in a grid layout or arrangement of legends. Useful\nwhen attempting to lay out items in a uniform grid structure.\n","type":"Vega.BoundsCalculation"},{"name":"bcFull","comment":" Entire calculated bounds (including an items such as axes or title or legend\nborder) to determine the extent of a sub-plot in a grid layout.\n","type":"Vega.BoundsCalculation"},{"name":"bcSignal","comment":" Indicate that the bounds calculation type is to be determined by a named signal.\n","type":"String.String -> Vega.BoundsCalculation"},{"name":"black","comment":" Convenience function for specifying a black color setting for marks that can\nbe colored (e.g. with [maStroke](#maStroke))\n","type":"Vega.Value"},{"name":"bmColor","comment":" Color blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmColorBurn","comment":" Color burn blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmColorDodge","comment":" Color dodge blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmDarken","comment":" Darken blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmDifference","comment":" Difference blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmExclusion","comment":" Exclusion blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmHardLight","comment":" Hard light blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmHue","comment":" Hue blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmLighten","comment":" Lighten blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmLuminosity","comment":" Luminosity blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmMultiply","comment":" Multiplicative blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmNormal","comment":" Indicate the default blend mode should be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmOverlay","comment":" Overlay blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmSaturation","comment":" Saturation blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmScreen","comment":" Screen blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bmSoftLight","comment":" Soft light blend mode to be applied when drawing over some background.\n","type":"Vega.BlendMode"},{"name":"bnAnchor","comment":" Value in the binned domain at which to anchor the bins of a bin\ntransform, shifting the bin boundaries if necessary to ensure that a boundary aligns\nwith the anchor value. If not specified, the minimum bin extent value serves as\nthe anchor.\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"bnAs","comment":" Output field names to contain the extent of a binning transform (start and end\nbin values). If not specified these can be retrieved as `bin0` and `bin1`.\n","type":"String.String -> String.String -> Vega.BinProperty"},{"name":"bnBase","comment":" Number base to use for automatic bin determination in a bin transform (default\nis base 100).\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"bnDivide","comment":" Allowable bin step sub-divisions when performing a binning transformation.\nThe parameter should evaluate to a list of numeric values. If not specified, the\ndefault of [5, 2] is used, which indicates that for base 10 numbers automatic bin\ndetermination can consider dividing bin step sizes by 5 and/or 2.\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"bnInterval","comment":" Whether or not a bin transformation should output both the start and end bin values.\nIf false, only the starting bin value is output.\n","type":"Vega.Boo -> Vega.BinProperty"},{"name":"bnMaxBins","comment":" Maximum number of bins to create with a bin transform.\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"bnMinStep","comment":" Minimum allowable bin step size between bins when performing a bin transform.\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"bnNice","comment":" Whether or not the bin boundaries in a binning transform will use human-friendly\nvalues such as multiples of ten.\n","type":"Vega.Boo -> Vega.BinProperty"},{"name":"bnSignal","comment":" Bind the specification of a binning transform (its start, step and stop properties)\nto a signal with the given name.\n","type":"String.String -> Vega.BinProperty"},{"name":"bnSpan","comment":" The span over which to generate bin boundaries (default is `extent[1] - extent[0]`).\nThe parameter allows automatic step size determination over custom spans (for\nexample, a zoomed-in region) while retaining the overall extent.\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"bnStep","comment":" Step size to use between bins in a bin transform.\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"bnSteps","comment":" Allowable step sizes between bins to choose from when performing a bin transform.\n","type":"Vega.Num -> Vega.BinProperty"},{"name":"booExpr","comment":" Eexpression that when evaluated, will be a Boolean value.\n","type":"Vega.Expr -> Vega.Boo"},{"name":"booSignal","comment":" Name of a signal that will generate a Boolean value.\n","type":"String.String -> Vega.Boo"},{"name":"booSignals","comment":" List of signals that will generate Boolean values.\n","type":"List.List String.String -> Vega.Boo"},{"name":"boos","comment":" List of Boolean literals.\n","type":"List.List Basics.Bool -> Vega.Boo"},{"name":"bsBins","comment":" Specify the bin scaling to categorise numeric values. The first parameter is\nthe step size between bins. The second parameter is a list of optional start and\nend values for the list of bins. If not specified, the start and end are assumed\nto span the full range of data to scale.\n","type":"Vega.Num -> List.List Vega.BinsProperty -> Vega.ScaleBins"},{"name":"bsNums","comment":" List of numeric values (`nums`) specifying bin boundaries. For example the list\n`[0, 5, 10, 15, 20]` would generate bins of [0-5), [5-10), [10-15), [15-20].\n","type":"Vega.Num -> Vega.ScaleBins"},{"name":"bsSignal","comment":" Name of a signal that resolves to a list of bin boundaries or a bins object\nthat defines the start, stop and step size of a a set of bins.\n","type":"String.String -> Vega.ScaleBins"},{"name":"bsStart","comment":" First bin in a series of bins.\n","type":"Vega.Num -> Vega.BinsProperty"},{"name":"bsStop","comment":" Last bin in a series of bins.\n","type":"Vega.Num -> Vega.BinsProperty"},{"name":"cHCL","comment":" Define a color in HCL space (parameters in H - C - L order).\n","type":"List.List Vega.Value -> List.List Vega.Value -> List.List Vega.Value -> Vega.ColorValue"},{"name":"cHSL","comment":" Define a color in HSL space (parameters in H - S - L order).\n","type":"List.List Vega.Value -> List.List Vega.Value -> List.List Vega.Value -> Vega.ColorValue"},{"name":"cLAB","comment":" Define a color in CIELab space (parameters in L - A - B order).\n","type":"List.List Vega.Value -> List.List Vega.Value -> List.List Vega.Value -> Vega.ColorValue"},{"name":"cRGB","comment":" Color in RGB space.\n","type":"List.List Vega.Value -> List.List Vega.Value -> List.List Vega.Value -> Vega.ColorValue"},{"name":"caButt","comment":" Butt stroke cap.\n","type":"Vega.StrokeCap"},{"name":"caRound","comment":" Rounded stroke cap.\n","type":"Vega.StrokeCap"},{"name":"caSignal","comment":" Stroke cap (`butt`, `round` and `square`) referenced by the value in the\nnamed signal.\n","type":"String.String -> Vega.StrokeCap"},{"name":"caSquare","comment":" Square stroke cap.\n","type":"Vega.StrokeCap"},{"name":"cfAutosize","comment":" Default autosizing properties of view.\n","type":"List.List Vega.Autosize -> Vega.ConfigProperty"},{"name":"cfAxis","comment":" Default properties of axes.\n","type":"Vega.AxisType -> List.List Vega.AxisProperty -> Vega.ConfigProperty"},{"name":"cfBackground","comment":" Default background of the view.\n","type":"Vega.Str -> Vega.ConfigProperty"},{"name":"cfDescription","comment":" Default text description for visualizations. This also determines the\n[aria-label attribute](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute)\nfor accessiblity purposes.\n","type":"String.String -> Vega.ConfigProperty"},{"name":"cfEventHandling","comment":" Configure default event handling. This can be used to, for example, filter only\ncertain types of events.\n","type":"List.List Vega.ConfigEventHandler -> Vega.ConfigProperty"},{"name":"cfEvents","comment":" Deprecated in favour of [cfEventHandling](#cfEventHandling). For example,\ninstead of\n\n    cfEvents cfDeny [ etMouseMove, etMouseOver ]\n\nuse\n\n    cfEventHandling [ cfeDefaults cfDeny [ etMouseMove, etMouseOver ] ]\n\n","type":"Vega.EventFilter -> List.List Vega.EventType -> Vega.ConfigProperty"},{"name":"cfGroup","comment":" Default properties of the top-level group mark representing the\ndata rectangle of a chart.\n","type":"List.List Vega.MarkProperty -> Vega.ConfigProperty"},{"name":"cfHeight","comment":" Default height of visualizations.\n","type":"Basics.Float -> Vega.ConfigProperty"},{"name":"cfHeightSignal","comment":" Default height of visualizations specified via a named signal.\n","type":"String.String -> Vega.ConfigProperty"},{"name":"cfLegend","comment":" Default properties of legends.\n","type":"List.List Vega.LegendProperty -> Vega.ConfigProperty"},{"name":"cfLineBreak","comment":" Set the default text to represent a line break in multi-line text values.\n","type":"Vega.Str -> Vega.ConfigProperty"},{"name":"cfMark","comment":" Default properties of a given mark type.\n","type":"Vega.Mark -> List.List Vega.MarkProperty -> Vega.ConfigProperty"},{"name":"cfMarks","comment":" Default properties of all marks.\n","type":"List.List Vega.MarkProperty -> Vega.ConfigProperty"},{"name":"cfPadding","comment":" Default padding around the visualization in pixel units. The way padding is\ninterpreted will depend on the `autosize` properties.\n","type":"Basics.Float -> Vega.ConfigProperty"},{"name":"cfPaddingSignal","comment":" Default padding around the visualization in pixel units specified as a signal.\nThe parameter is the name of a signal that can evluate either to a single number\nor an object with properties `left`, `top`, `right` and `bottom`.\n","type":"String.String -> Vega.ConfigProperty"},{"name":"cfPaddings","comment":" Default padding around the visualization in pixel units in _left_, _top_,\n_right_, _bottom_ order.\n","type":"Basics.Float -> Basics.Float -> Basics.Float -> Basics.Float -> Vega.ConfigProperty"},{"name":"cfScaleRange","comment":" Create a named range to be used as part of a scale specification.\nThe first parameter is the named range label (e.g. `raOrdinal`, `raCategory`, etc.).\nThe second is the new range of values to be associated with this range.\n\n    cf =\n        config [ cfScaleRange raHeatmap (raScheme (str \"greenblue\") []) ]\n\n","type":"Vega.ScaleRange -> Vega.ScaleRange -> Vega.ConfigProperty"},{"name":"cfSignals","comment":" Create a signal to be used in a configuration. Useful for standardising font\nsizes, colors etc. across chart elements. The first parameter is a list of signal\ndefinitions, specified in the same way as any other signal. Once defined, the\nnamed signals can be used in other configuration options.\n\n    cf =\n        config\n            [ (cfSignals << signal \"baseFontSize\" [ siValue (vNum 10) ]) []\n            , cfTitle [ tiFontSize (numSignal \"baseFontSize*4\") ]\n            , cfAxis axAll [ axTitleFontSize (numSignal \"baseFontSize*1.5\") ]\n            , cfLegend [ leTitleFontSize (numSignal \"baseFontSize*2\") ]\n            ]\n\n","type":"List.List Vega.Spec -> Vega.ConfigProperty"},{"name":"cfStyle","comment":" Create a named style. The first parameter is the name to give the style, the\nsecond its mark properties.\n","type":"String.String -> List.List Vega.MarkProperty -> Vega.ConfigProperty"},{"name":"cfTitle","comment":" Default properties of a title.\n","type":"List.List Vega.TitleProperty -> Vega.ConfigProperty"},{"name":"cfWidth","comment":" Default width of visualizations.\n","type":"Basics.Float -> Vega.ConfigProperty"},{"name":"cfWidthSignal","comment":" Default width of visualizations specified via a named signal.\n","type":"String.String -> Vega.ConfigProperty"},{"name":"cfeBind","comment":" Configure the way DOM elements are bound to signals. The parameter determines\nif all bindings are allowed ([sbAny](#sbAny); default), just those in the view\ncontainer ([sbContainer](#sbContainer)) or no bindings ([sbNone](#sbNone)).\n","type":"Vega.SignalBind -> Vega.ConfigEventHandler"},{"name":"cfeDefaults","comment":" Configure default filtering of events. This can specified in the first parameter\nas either a 'whitelist' (`efAllow`) or 'blacklist' (`efPrevent`) comprising the\nevent types to be considered in the second parameter. If that list is empty, all\nevent types will be placed in the black/white list.\n","type":"Vega.EventFilter -> List.List Vega.EventType -> Vega.ConfigEventHandler"},{"name":"cfeSelector","comment":" Configure event listeners from CSS-specified external sources. The parameter\nis a list of event types that will be listened for. If empty, no event types will\nbe listened for. If this function is not specified, all event types will be\nlistened for.\n","type":"List.List Vega.EventType -> Vega.ConfigEventHandler"},{"name":"cfeTimer","comment":" Configure whether or not to permit timer event listeners. Can be useful for\nturning dynamic visualizations on or off.\n","type":"Vega.Boo -> Vega.ConfigEventHandler"},{"name":"cfeView","comment":" Configure event listeners from a Vega-view source. The parameter is a list of\nevent types that will be listened for. If empty, no event types will be listened\nfor. If this function is not specified, all event types will be listened for.\n","type":"List.List Vega.EventType -> Vega.ConfigEventHandler"},{"name":"cfeWindow","comment":" Configure event listeners from the browser window source. The parameter is a\nlist of event types that will be listened for. If empty, no event types will be\nlistened for. If this function is not specified, all event types will be listened\nfor.\n","type":"List.List Vega.EventType -> Vega.ConfigEventHandler"},{"name":"clEnabled","comment":" Whether or not clipping should be applied to a set of marks within a group mark.\n","type":"Vega.Boo -> Vega.Clip"},{"name":"clPath","comment":" Clipping path to be applied to a set of marks within a region. Should be a valid\n[SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n","type":"Vega.Str -> Vega.Clip"},{"name":"clSphere","comment":" Clip a spherical outline subject to a given map projection name. This is useful\nin conjunction with map projections that include content such as graticule lines\noutside the bounds of the globe.\n","type":"Vega.Str -> Vega.Clip"},{"name":"cnBandwidth","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nKernel density estimation bandwidth used in a contour transformation.\n\n","type":"Vega.Num -> Vega.ContourProperty"},{"name":"cnCellSize","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nSize of cells used for density estimation in a contour transformation.\n\n","type":"Vega.Num -> Vega.ContourProperty"},{"name":"cnCount","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nDesired number of contours used in a contour transformation. Ignored if `cnThresholds`\nsetting explicit contour values are provided.\n\n","type":"Vega.Num -> Vega.ContourProperty"},{"name":"cnNice","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nWhether or not contour threshold values should be automatically aligned to\n'nice', human-friendly values when performing a contour transformation.\n\n","type":"Vega.Boo -> Vega.ContourProperty"},{"name":"cnSmooth","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nWhether or not contour polygons should be smoothed in a contour transformation.\nIgnored if kernel density estimation is used.\n\n","type":"Vega.Boo -> Vega.ContourProperty"},{"name":"cnThresholds","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nExplicit contour values to be generated by a contour transformation.\n\n","type":"Vega.Num -> Vega.ContourProperty"},{"name":"cnValues","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nGrid of values over which to compute contours. If not provided, [trContour](#trContour)\nwill compute contours of the kernel density estimate of input data instead.\n\n","type":"Vega.Num -> Vega.ContourProperty"},{"name":"cnWeight","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nWeight field used for density estimation in a contour transformation. This allows\ndifferent weights to be attached to each value when estimating kernel density.\n\n","type":"Vega.Field -> Vega.ContourProperty"},{"name":"cnX","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nX-coordinate field used for density estimation in a contour transformation.\n\n","type":"Vega.Field -> Vega.ContourProperty"},{"name":"cnY","comment":" **Deprecated in favour of [IsocontourProperty](#iscontourProperty) generating\nfunctions for use with [trIsocontour](#trIsocontour).**\n\nY-coordinate field used for density estimation in a contour transformation.\n\n","type":"Vega.Field -> Vega.ContourProperty"},{"name":"combineSpecs","comment":" Combine a list of labelled specifications into a single specification that\nmay be passed to JavaScript for rendering. Useful for creating a single page with\nmultiple visualizations.\n\n    combineSpecs\n        [ ( \"vis1\", myFirstVis )\n        , ( \"vis2\", mySecondVis )\n        , ( \"vis3\", myOtherVis )\n        ]\n\n","type":"List.List Vega.LabelledSpec -> Vega.Spec"},{"name":"config","comment":" Create a collection of configuration settings. This allows default stylings\nto be defined for a collection of visualizations or visualization components.\n\n    cf =\n        config\n            [ cfMark text [ maFont [ vStr \"Roboto Condensed, sans-serif\" ] ]\n            , cfTitle\n                [ tiFont (str \"Roboto Condensed, sans-serif\")\n                , tiFontWeight (vNum 500)\n                , tiFontSize (num 17)\n                ]\n            , cfAxis axAll\n                [ axLabelFont (str \"Roboto Condensed, sans-serif\")\n                , axLabelFontSize (num 12)\n                ]\n            ]\n\n","type":"List.List Vega.ConfigProperty -> ( Vega.VProperty, Vega.Spec )"},{"name":"conicConformal","comment":" A conformal conic map projection.\n","type":"Vega.Projection"},{"name":"conicEqualArea","comment":" An equal area conic map projection.\n","type":"Vega.Projection"},{"name":"conicEquidistant","comment":" An equidistant conic map projection.\n","type":"Vega.Projection"},{"name":"cpAs","comment":" Names the two output fields generated by a count pattern transformation.\nBy default they are named `text` and `count`.\n","type":"String.String -> String.String -> Vega.CountPatternProperty"},{"name":"cpCase","comment":" Text case transformation to apply before performing a count pattern transformation.\nThe default, as generated by `mixedcase`, will leave text untransformed.\n","type":"Vega.Case -> Vega.CountPatternProperty"},{"name":"cpPattern","comment":" Define a match in a count pattern transformation with a regular expression\n(escaping backslashes):\n\n    transform [ trCountPattern (field \"data\") [ cpPattern (str \"[\\\\w']{3,}\") ] ]\n\n","type":"Vega.Str -> Vega.CountPatternProperty"},{"name":"cpStopwords","comment":" Define text to ignore in a count pattern transformation with a regular\nexpression (escaping backslashes).\n","type":"Vega.Str -> Vega.CountPatternProperty"},{"name":"crAs","comment":" Name the two output fields of a cross-product transform.\n","type":"String.String -> String.String -> Vega.CrossProperty"},{"name":"crFilter","comment":" Filter for limiting the results of a cross-product transform.\n","type":"Vega.Expr -> Vega.CrossProperty"},{"name":"csCount","comment":" Number of colors to use in a color scheme.\n","type":"Vega.Num -> Vega.ColorSchemeProperty"},{"name":"csExtent","comment":" Extent of the color range to use in linear and diverging color\nschemes. The parameter should evaluate to a two-element list representing the min\nand max values of the extent. For example [0.2, 1] will rescale the color scheme\nsuch that color values in the range [0, 0.2] are excluded from the scheme.\n","type":"Vega.Num -> Vega.ColorSchemeProperty"},{"name":"csScheme","comment":" Name a color scheme to use.\n","type":"Vega.Str -> Vega.ColorSchemeProperty"},{"name":"csv","comment":" Indicate a CSV (comma-separated) format when parsing a data source.\n","type":"Vega.FormatProperty"},{"name":"cuAlias","comment":" Alias cursor.\n","type":"Vega.Cursor"},{"name":"cuAllScroll","comment":" Scrolling cursor.\n","type":"Vega.Cursor"},{"name":"cuAuto","comment":" Automatically determine a cursor type depending on interaction context.\n","type":"Vega.Cursor"},{"name":"cuCell","comment":" Cell cursor.\n","type":"Vega.Cursor"},{"name":"cuColResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuContextMenu","comment":" Context menu cursor.\n","type":"Vega.Cursor"},{"name":"cuCopy","comment":" Copy cursor.\n","type":"Vega.Cursor"},{"name":"cuCrosshair","comment":" Crosshair cursor.\n","type":"Vega.Cursor"},{"name":"cuDefault","comment":" Default cursor.\n","type":"Vega.Cursor"},{"name":"cuEResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuEWResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuGrab","comment":" Grab cursor.\n","type":"Vega.Cursor"},{"name":"cuGrabbing","comment":" Grabbing cursor.\n","type":"Vega.Cursor"},{"name":"cuHelp","comment":" Help cursor.\n","type":"Vega.Cursor"},{"name":"cuMove","comment":" Move cursor.\n","type":"Vega.Cursor"},{"name":"cuNEResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuNESWResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuNResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuNSResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuNWResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuNWSEResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuNoDrop","comment":" 'No drop' cursor.\n","type":"Vega.Cursor"},{"name":"cuNone","comment":" No cursor.\n","type":"Vega.Cursor"},{"name":"cuNotAllowed","comment":" 'Not allowed' cursor.\n","type":"Vega.Cursor"},{"name":"cuPointer","comment":" Pointer cursor.\n","type":"Vega.Cursor"},{"name":"cuProgress","comment":" Progress cursor.\n","type":"Vega.Cursor"},{"name":"cuRowResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuSEResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuSResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuSWResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuText","comment":" Text cursor.\n","type":"Vega.Cursor"},{"name":"cuVerticalText","comment":" Vertical text cursor.\n","type":"Vega.Cursor"},{"name":"cuWResize","comment":" Resizing cursor.\n","type":"Vega.Cursor"},{"name":"cuWait","comment":" Waiting cursor.\n","type":"Vega.Cursor"},{"name":"cuZoomIn","comment":" Zooming cursor.\n","type":"Vega.Cursor"},{"name":"cuZoomOut","comment":" Zooming cursor.\n","type":"Vega.Cursor"},{"name":"cubeHelix","comment":" Cube helix color interpolation using the given gamma value (anchored at 1).\n","type":"Basics.Float -> Vega.CInterpolate"},{"name":"cubeHelixLong","comment":" A long path cube-helix color interpolation using the given gamma value (anchored at 1).\n","type":"Basics.Float -> Vega.CInterpolate"},{"name":"cursorValue","comment":" A convenience function for generating a text value representing a given cursor\ntype.\n","type":"Vega.Cursor -> Vega.Value"},{"name":"customProjection","comment":" Custom projection type. Additional custom projections from d3 can be defined\nvia the [Vega API](https://vega.github.io/vega/docs/projections/#register) and\ncalled from with this function where the parameter is the name of the D3\nprojection to use (e.g. `customProjection (str \"winkel3\")`).\n","type":"Vega.Str -> Vega.Projection"},{"name":"daDataset","comment":" Reference a dataset with the given name.\n","type":"String.String -> Vega.DataReference"},{"name":"daField","comment":" Reference a data field with the given value.\n","type":"Vega.Field -> Vega.DataReference"},{"name":"daFields","comment":" Reference a collection of data fields with the given values.\n","type":"List.List Vega.Field -> Vega.DataReference"},{"name":"daFormat","comment":" Data format to use when loading or generating a dataset.\n","type":"List.List Vega.FormatProperty -> Vega.DataProperty"},{"name":"daOn","comment":" Updates to insert, remove, and toggle data values, or clear the data in a\ndataset when trigger conditions are met.\n","type":"List.List Vega.Trigger -> Vega.DataProperty"},{"name":"daReferences","comment":" Reference a collection of nested data references.\n","type":"List.List (List.List Vega.DataReference) -> Vega.DataReference"},{"name":"daSignal","comment":" Make a data reference with a signal.\n","type":"String.String -> Vega.DataReference"},{"name":"daSort","comment":" Sort a data reference.\n","type":"List.List Vega.SortProperty -> Vega.DataReference"},{"name":"daSource","comment":" Name a data source when generating a dataset.\n","type":"String.String -> Vega.DataProperty"},{"name":"daSources","comment":" Name a collection of data sources when generating a dataset.\n","type":"List.List String.String -> Vega.DataProperty"},{"name":"daSphere","comment":" Generate a global sphere dataset.\n","type":"Vega.DataProperty"},{"name":"daUrl","comment":" Data file to be loaded when generating a dataset.\n","type":"Vega.Str -> Vega.DataProperty"},{"name":"daValue","comment":" Data value(s) for generating a dataset inline.\n","type":"Vega.Value -> Vega.DataProperty"},{"name":"daValues","comment":" Create a data reference from a list of literals. Useful when combining with\ndata references from existing data streams. For example\n\n    scale \"myScale\"\n        [ scDomain\n            (doData\n                [ daReferences\n                    [ [ daValues (vNums [ 2, 4 ]) ]\n                    , [ daDataset \"myData\", daField (field \"myField\") ]\n                    ]\n                ]\n            )\n        ]\n\n","type":"Vega.Value -> Vega.DataReference"},{"name":"data","comment":" Declare a named dataset. Depending on the properties provided this may be\nfrom an external file, from a named data source or inline literal values.\n","type":"String.String -> List.List Vega.DataProperty -> Vega.DataTable"},{"name":"dataColumn","comment":" Create a column of data. A column has a name and a list of values. The final\nparameter is the list of any other columns to which this is added.\n","type":"String.String -> Vega.Value -> List.List Vega.DataColumn -> List.List Vega.DataColumn"},{"name":"dataFromColumns","comment":" Declare a data table from a list of column values. Each column contains values\nof the same type, but types may vary between columns. Columns should all contain\nthe same number of items; if not the dataset will be truncated to the length of\nthe shortest.\n\nThe first parameter should be the name given to the data table for later reference.\nField formatting specifications can be provided in the second parameter or as an\nempty list to use the default formatting. The columns are most easily generated\nwith `dataColumn`.\n\n","type":"String.String -> List.List Vega.FormatProperty -> List.List Vega.DataColumn -> Vega.DataTable"},{"name":"dataFromRows","comment":" Declare a data table from a list of row values. Each row is specified with a\nlist of tuples where the first value is the column name, and the second the column\nvalue for that row. Each column can have a value of a different type but you must\nensure that when multiple rows are added, they match the types of other values in\nthe same column. Field formatting specifications can be provided in the first\nparameter or as an empty list to use the default formatting.\n\nRows are most easily generated with `dataRow`. If you are creating data inline\n(as opposed to reading from a file), generally, adding data by column is more\nefficient and less error-prone.\n\n","type":"String.String -> List.List Vega.FormatProperty -> List.List Vega.DataRow -> Vega.DataTable"},{"name":"dataRow","comment":" Create a row of data. A row comprises a list of (_columnName_, _value_) pairs.\nThe final parameter is the list of any other rows to which this is added.\n","type":"List.List ( String.String, Vega.Value ) -> List.List Vega.DataRow -> List.List Vega.DataRow"},{"name":"dataSource","comment":" Data source to be used by a visualization. A data source is a collection of\ndata tables which themselves may be generated inline, loaded from a URL or the\nresult of a transformation.\n","type":"List.List Vega.DataTable -> Vega.Data"},{"name":"date","comment":" Indicate time unit is to specified as a day of a month (1st, 2nd, ... 30th, 31st).\n","type":"Vega.TimeUnit"},{"name":"day","comment":" Indicate time unit is to specified as a day of week (Monday, Tuesday etc.)\n","type":"Vega.TimeUnit"},{"name":"dayOfYear","comment":" Indicate time unit is to specified as a day of year (1 to 366).\n","type":"Vega.TimeUnit"},{"name":"dbAs","comment":" The name to give the output bins field from a dotbin transformation. If not\nspecified, output is named `bin`.\n","type":"String.String -> Vega.DotBinProperty"},{"name":"dbSignal","comment":" Bind the computed dot binning parameters (an object with start, stop and step\nproperties) to a signal with the given name.\n","type":"String.String -> Vega.DotBinProperty"},{"name":"dbSmooth","comment":" Whether or not dot density stacks should be smoothed to reduce variance in a\ndot bin transformation. False if not specified.\n","type":"Vega.Boo -> Vega.DotBinProperty"},{"name":"dbStep","comment":" The bin width to use when stacking dots in a dot bin transformation.\n","type":"Vega.Num -> Vega.DotBinProperty"},{"name":"dbroupBy","comment":" The data fields to group by when performing a dot bin transformation. If not\nspecified, all data objects used to generate a single group.\n","type":"List.List Vega.Field -> Vega.DotBinProperty"},{"name":"descend","comment":" Indicate descending order when sorting.\n","type":"Vega.Order"},{"name":"description","comment":" Provide a text description of the visualization. This also determines the\n[aria-label attribute](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute)\nfor accessiblity purposes.\n","type":"String.String -> ( Vega.VProperty, Vega.Spec )"},{"name":"diKde","comment":" Kernel density estimate (smoothed probability distribution) for a set of\nnumerical values. The first parameter is the dataset containing\nthe source data, the second the name of the field containing the numerical values\nand the third the kernel bandwidth. If the bandwidth is 0, it will be estimated\nfrom the input data.\n","type":"String.String -> Vega.Field -> Vega.Num -> Vega.Distribution"},{"name":"diMixture","comment":" Weighted mixture of probability distributions. The parameter should be a list\nof tuples representing the component distributions and their corresponding weights.\n","type":"List.List ( Vega.Distribution, Vega.Num ) -> Vega.Distribution"},{"name":"diNormal","comment":" Normal (Gaussian) probability distribution with a given mean (first parameter)\nand standard deviation (second parameter).\n","type":"Vega.Num -> Vega.Num -> Vega.Distribution"},{"name":"diUniform","comment":" Uniform probability distribution with given minimum (first parameter) and\nmaximum (second parameter) bounds.\n","type":"Vega.Num -> Vega.Num -> Vega.Distribution"},{"name":"dnAs","comment":" Fields to contain a density transform's values (assigned to a new field named\nin the first parameter) and probabilities (field named in the second parameter).\nIf not specified, the output will allocated to fields named `value` and `probability`.\n","type":"String.String -> String.String -> Vega.DensityProperty"},{"name":"dnCdf","comment":" Cumulative density function (CDF).\n","type":"Vega.DensityFunction"},{"name":"dnExtent","comment":" A two-element list [min, max] from which to sample a distribution in a density transform.\n","type":"Vega.Num -> Vega.DensityProperty"},{"name":"dnMaxSteps","comment":" Maximum number of uniformly spaced steps (default 200) to take along an extent\ndomain in a density transform.\n","type":"Vega.Num -> Vega.DensityProperty"},{"name":"dnMethod","comment":" Type of distribution to generate in a density transform.\n","type":"Vega.DensityFunction -> Vega.DensityProperty"},{"name":"dnMinSteps","comment":" Minimum number of uniformly spaced steps (default 25) to take along an extent\ndomain in a density transform.\n","type":"Vega.Num -> Vega.DensityProperty"},{"name":"dnPdf","comment":" Probability density function (PDF).\n","type":"Vega.DensityFunction"},{"name":"dnSignal","comment":" Density function referenced by the value in the named signal.\n","type":"String.String -> Vega.DensityFunction"},{"name":"dnSteps","comment":" Exact number of uniformly spaced steps to take along an extent domain in a density transform.\n","type":"Vega.Num -> Vega.DensityProperty"},{"name":"doData","comment":" Data reference object specifying field values in one or more datasets to\ndefine a scale domain.\n","type":"List.List Vega.DataReference -> Vega.ScaleDomain"},{"name":"doNums","comment":" List of numeric values (e.g. `nums [1981, 2019]`) representing a scale domain.\n","type":"Vega.Num -> Vega.ScaleDomain"},{"name":"doSignal","comment":" Scale domain referenced by the value in the named signal.\n","type":"String.String -> Vega.ScaleDomain"},{"name":"doSignals","comment":" Scale domains referenced by the values in the named signals.\n","type":"List.List String.String -> Vega.ScaleDomain"},{"name":"doStrs","comment":" List of strings (e.g. `strs [\"cat\",\"dog\",\"fish\"]`) representing a scale domain.\n","type":"Vega.Str -> Vega.ScaleDomain"},{"name":"dsv","comment":" DSV (delimited separated value) format with a custom delimiter.\n","type":"Vega.Str -> Vega.FormatProperty"},{"name":"dtExpr","comment":" Express a timestamp with a vega `Date` expression such as `datetime()`. For\nexample, to represent 12:34pm on 28th February 2001 (noting that months count from\n0, not 1):\n\n    dtExpr \"datetime(2001,1,28,12,34)\"\n\n","type":"String.String -> Vega.DateTime"},{"name":"dtMillis","comment":" Express a timestamp by the number of milliseconds since the Unix epoch.\n","type":"Basics.Int -> Vega.DateTime"},{"name":"efAllow","comment":" Allow events of a certain type to be handled.\n","type":"Vega.EventFilter"},{"name":"efPrevent","comment":" Prevent events of a certain type from being handled.\n","type":"Vega.EventFilter"},{"name":"enCustom","comment":" Named custom encoding set. Also requires a signal event handler with an\n`encode` directive.\n","type":"String.String -> List.List Vega.MarkProperty -> Vega.EncodingProperty"},{"name":"enEnter","comment":" Properties to be encoded when a mark item is first instantiated or resized.\n","type":"List.List Vega.MarkProperty -> Vega.EncodingProperty"},{"name":"enExit","comment":" Properties to be encoded when the data backing a mark item is removed.\n","type":"List.List Vega.MarkProperty -> Vega.EncodingProperty"},{"name":"enGradient","comment":" Custom encoding for gradient (continuous) legends.\n","type":"List.List Vega.EncodingProperty -> Vega.LegendEncoding"},{"name":"enHover","comment":" Properties to be encoded when a pointer hovers over a mark item.\n","type":"List.List Vega.MarkProperty -> Vega.EncodingProperty"},{"name":"enInteractive","comment":" Whether or not a custom legend encoding set is to be interactive.\n","type":"Vega.Boo -> Vega.EncodingProperty"},{"name":"enLabels","comment":" Custom encoding for legend labels.\n","type":"List.List Vega.EncodingProperty -> Vega.LegendEncoding"},{"name":"enLegend","comment":" Custom encoding for a legend group mark.\n","type":"List.List Vega.EncodingProperty -> Vega.LegendEncoding"},{"name":"enName","comment":" Name for a custom legend encoding set.\n","type":"String.String -> Vega.EncodingProperty"},{"name":"enSymbols","comment":" Custom encoding for symbol (discrete) legends.\n","type":"List.List Vega.EncodingProperty -> Vega.LegendEncoding"},{"name":"enTitle","comment":" Custom ecoding for a legend title.\n","type":"List.List Vega.EncodingProperty -> Vega.LegendEncoding"},{"name":"enUpdate","comment":" Properties to be encoded when a mark item is updated such as in response to\na signal change.\n","type":"List.List Vega.MarkProperty -> Vega.EncodingProperty"},{"name":"encode","comment":" Encoding directives for the visual properties of the top-level group mark\nrepresenting a chartâs data rectangle. For example, this can be used to set a\nbackground fill color for the plotting area, rather than the entire view.\n","type":"List.List Vega.EncodingProperty -> ( Vega.VProperty, Vega.Spec )"},{"name":"equalEarth","comment":" An [equal-earth](https://en.wikipedia.org/wiki/Equal_Earth_projection) map projection\nthat provides a reasonable shape approximation while retaining relative areas.\n","type":"Vega.Projection"},{"name":"equirectangular","comment":" An equirectangular (default) map projection that maps longitude to x and\nlatitude to y.\n","type":"Vega.Projection"},{"name":"esAll","comment":" Event source from any mark. Equivalent to the `*` selector.\n","type":"Vega.EventSource"},{"name":"esBetween","comment":" Event stream filter that lets only events that occur between the two given event\nstreams from being handled. Useful for capturing pointer dragging as it is a pointer\nmovement event stream that occurs between `etMouseDown` and `etMouseUp` events.\n\n    << signal \"myDrag\"\n        [ siValue (vNums [ 200, 200 ])\n        , siOn\n            [ evHandler\n                [esObject\n                    [ esBetween [ esMark rect, esType etMouseDown ] [ esSource esView, esType etMouseUp ]\n                    , esSource esView\n                    , esType etMouseMove\n                    ]\n                ]\n                [ evUpdate \"xy()\" ]\n            ]\n        ]\n\nThis is equivalent to the more compact, but more error-prone event stream selector:\n\n    esSelector (str \"[rect:mousedown, view:mouseup] > view:mousemove\")\n\n","type":"List.List Vega.EventStreamProperty -> List.List Vega.EventStreamProperty -> Vega.EventStreamProperty"},{"name":"esConsume","comment":" Whether or not an event stream is consumed once it has been captured. If false,\nthe event is made available for subsequent event handling.\n","type":"Vega.Boo -> Vega.EventStreamProperty"},{"name":"esDebounce","comment":" Minimum time to wait between event occurrence and processing. If a new event\narrives during a debouncing window, the timer will restart and only the new event\nwill be captured.\n","type":"Vega.Num -> Vega.EventStreamProperty"},{"name":"esDom","comment":" DOM node to be the source for an event selector. Referenced with a standard\n[CSS selector](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors).\n","type":"String.String -> Vega.EventSource"},{"name":"esFilter","comment":" Predicate expressions that must all evaluate to `true` for an event to be\ncaptured.\n","type":"List.List String.String -> Vega.EventStreamProperty"},{"name":"esMark","comment":" Mark type to be the source for an event stream.\n","type":"Vega.Mark -> Vega.EventStreamProperty"},{"name":"esMarkName","comment":" Named mark to be the source for an event stream. The name given here\nmust correspond to that provided via `mName`.\n","type":"String.String -> Vega.EventStreamProperty"},{"name":"esMerge","comment":" Merge a list of event streams into a single stream.\n","type":"List.List Vega.EventStream -> Vega.EventStream"},{"name":"esObject","comment":" Event stream for modelling user input. The parameter represents a stream object\nwhich provides a more self-explanatory and robust form of specification than using\na selector string.\n","type":"List.List Vega.EventStreamProperty -> Vega.EventStream"},{"name":"esScope","comment":" Limit event source to events from the main group in which a nested group sits.\n","type":"Vega.EventSource"},{"name":"esSelector","comment":" Compact representation of an event stream for modelling user input (alternative\nto [esObject](#esObject)).\n","type":"Vega.Str -> Vega.EventStream"},{"name":"esSignal","comment":" Signal that triggers an event stream. Allows an update to be triggered whenever\nthe given signal changes.\n","type":"String.String -> Vega.EventStream"},{"name":"esSource","comment":" Source for an event selector.\n","type":"Vega.EventSource -> Vega.EventStreamProperty"},{"name":"esStream","comment":" Event stream to be used as input into a derived event stream. Useful if several\nevent streams have a common element:\n\n    si =\n        let\n            esStart =\n                esMerge\n                    [ esObject [ esType etMouseDown ]\n                    , esObject [ esType etTouchStart ]\n                    ]\n\n            esEnd =\n                esObject [ esType etTouchEnd ]\n        in\n        signals\n            << signal \"down\"\n                [ siValue vNull\n                , siOn\n                    [ evHandler [ esEnd ] [ evUpdate \"null\" ]\n                    , evHandler [ esStart ] [ evUpdate \"xy()\" ]\n                    ]\n                ]\n            << signal \"xCur\"\n                [ siValue vNull\n                , siOn\n                    [ evHandler [ esObject [ esStream esStart, esType etTouchEnd ] ]\n                        [ evUpdate \"slice(xDom)\" ]\n                    ]\n                ]\n\n","type":"Vega.EventStream -> Vega.EventStreamProperty"},{"name":"esThrottle","comment":" Minimum time in milliseconds between captured events. New events that arrive\nwithin the throttling window will be ignored. For timer events, this determines\nthe interval between timer ticks.\n","type":"Vega.Num -> Vega.EventStreamProperty"},{"name":"esType","comment":" Type of event stream for handling user interaction events.\n","type":"Vega.EventType -> Vega.EventStreamProperty"},{"name":"esView","comment":" Event source from the current Vega view component.\n","type":"Vega.EventSource"},{"name":"esWindow","comment":" Event source from the browser window object.\n","type":"Vega.EventSource"},{"name":"etClick","comment":" Click interaction event type.\n","type":"Vega.EventType"},{"name":"etDblClick","comment":" Double click interaction event type.\n","type":"Vega.EventType"},{"name":"etDragEnter","comment":" Drag entry interaction event type.\n","type":"Vega.EventType"},{"name":"etDragLeave","comment":" Drag exit interaction event type.\n","type":"Vega.EventType"},{"name":"etDragOver","comment":" Drag over interaction event type.\n","type":"Vega.EventType"},{"name":"etKeyDown","comment":" Key down interaction event type.\n","type":"Vega.EventType"},{"name":"etKeyPress","comment":" Key press interaction event type.\n","type":"Vega.EventType"},{"name":"etKeyUp","comment":" Key up interaction event type.\n","type":"Vega.EventType"},{"name":"etMouseDown","comment":" Mouse down interaction event type.\n","type":"Vega.EventType"},{"name":"etMouseMove","comment":" Mouse movement interaction event type.\n","type":"Vega.EventType"},{"name":"etMouseOut","comment":" Mouse exit interaction event type.\n","type":"Vega.EventType"},{"name":"etMouseOver","comment":" Mouse over interaction event type.\n","type":"Vega.EventType"},{"name":"etMouseUp","comment":" Mouse up interaction event type.\n","type":"Vega.EventType"},{"name":"etMouseWheel","comment":" Mouse wheel interaction event type.\n","type":"Vega.EventType"},{"name":"etTimer","comment":" Fire an event at a regular interval determined by the number of milliseconds\nprovided with `esThrottle`.\n","type":"Vega.EventType"},{"name":"etTouchEnd","comment":" Touch end interaction event type.\n","type":"Vega.EventType"},{"name":"etTouchMove","comment":" Touch move interaction event type.\n","type":"Vega.EventType"},{"name":"etTouchStart","comment":" Touch start interaction event type.\n","type":"Vega.EventType"},{"name":"etWheel","comment":" Wheel interaction event type.\n","type":"Vega.EventType"},{"name":"evEncode","comment":" Name of a mark property encoding set to re-evaluate for the mark that is the\nsource of an input event. This is required if `evUpdate` is not specified.\n","type":"String.String -> Vega.EventHandler"},{"name":"evForce","comment":" Whether or not updates that do not change a signal value should propagate.\ne.g., if true and an input stream update sets the signal to its current value,\ndownstream signals will be notified of an update.\n","type":"Vega.Boo -> Vega.EventHandler"},{"name":"evHandler","comment":" Event handler. The first parameter is the stream(s) of events to\nrespond to. The second, a list of handlers that respond to the event stream.\n\n    signal \"tooltip\"\n        [ siValue (vObject [])\n        , siOn\n            [ evHandler [ esObject [ esMark rect, esType etMouseOver ] ] [ evUpdate \"datum\" ]\n            , evHandler [ esObject [ esMark rect, esType etMouseOut ] ] [ evUpdate \"\" ]\n            ]\n        ]\n\n","type":"List.List Vega.EventStream -> List.List Vega.EventHandler -> List.List Vega.EventHandler"},{"name":"evStreamSelector","comment":" Event selector used to generate an event stream.\n","type":"Vega.Str -> Vega.EventStream"},{"name":"evUpdate","comment":" Expression to be evaluated when an event occurs, the result of which becomes\nthe new signal value.\n","type":"String.String -> Vega.EventHandler"},{"name":"exField","comment":" Field lookup that forms a Vega [Expr](https://vega.github.io/vega/docs/types/#Expr).\nIn contrast to an expression generated by `expr`, a field lookup is applied once\nto an entire field rather than evaluated once per datum.\n","type":"String.String -> Vega.Expr"},{"name":"expr","comment":" Expression to enable custom calculations specified in the [Vega expression\nlanguage](https://vega.github.io/vega/docs/expressions). In contrast to a field\nreference or signal, the expression is evaluated once per datum behaving like an\nanonymous (lambda) function.\n","type":"String.String -> Vega.Expr"},{"name":"fDatum","comment":" Perform a lookup on the current data object using the given field.\nOnce evaluated this is similar to simply providing a string value.\n","type":"Vega.Field -> Vega.Field"},{"name":"fExpr","comment":" Expression that references a field but can perform calculations on each datum\nin the field.\n\n    fExpr \"scale('xScale', datum.Horsepower)\"\n\n","type":"String.String -> Vega.Field"},{"name":"fGroup","comment":" Property of the enclosing group mark instance as a field value.\n","type":"Vega.Field -> Vega.Field"},{"name":"fParent","comment":" Field of the enclosing group markâs data object as a field.\n","type":"Vega.Field -> Vega.Field"},{"name":"fSignal","comment":" Field referenced by the value in the named signal.\n","type":"String.String -> Vega.Field"},{"name":"faAggregate","comment":" For data-driven facets, a list aggregate transform properties for the\naggregate data values generated for each facet group item.\n","type":"List.List Vega.AggregateProperty -> Vega.Facet"},{"name":"faField","comment":" For pre-faceted data, the name of the data field containing a list of data\nvalues to use as the local partition. This is required if using pre-faceted data.\n","type":"Vega.Field -> Vega.Facet"},{"name":"faGroupBy","comment":" For data-driven facets, specify a list of field names by which to partition\nthe data. This is required if using pre-faceted data.\n","type":"List.List Vega.Field -> Vega.Facet"},{"name":"false","comment":" A Boolean false value.\n","type":"Vega.Boo"},{"name":"feName","comment":" Name of a geoJSON feature. Can be used with [prFit](#prFit) to fit a map\nprojection scaling and centre to a given geoJSON feature or feature collection.\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (feName \"mapData\")\n                ]\n\n","type":"String.String -> Vega.Feature"},{"name":"featureSignal","comment":" geoJSON feature referenced by the value in the named signal. Can be used with\n[prFit](#prFit) to fit a map projection scaling and centre to a given geoJSON\nfeature or feature collection.\n\n    ds =\n        dataSource\n            [ data \"myLongLatData\" []\n                |> transform\n                    [ trGeoJson\n                        [ gjFields (field \"longitude\") (field \"latitude\")\n                        , gjSignal \"feature\"\n                        ]\n                    ]\n            ]\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (featureSignal \"feature\")\n                ]\n\n","type":"String.String -> Vega.Feature"},{"name":"field","comment":" Name of a field to reference.\n","type":"String.String -> Vega.Field"},{"name":"foBoo","comment":" Specify Boolean values are to be parsed when reading input data.\n","type":"Vega.DataType"},{"name":"foCenter","comment":" Force that pulls all nodes towards a shared centre point in a force\nsimulation. The two parameters specify the x and y coordinates of the centre point.\n","type":"Vega.Num -> Vega.Num -> Vega.Force"},{"name":"foCollide","comment":" Collision detection force that pushes apart nodes whose circular radii overlap\nin a force simulation. The first parameter specifies the radius of\nthe node to which it applies. The second enables the strength and number of\niterations to be specified.\n","type":"Vega.Num -> List.List Vega.ForceProperty -> Vega.Force"},{"name":"foDate","comment":" Date format for parsing data using\n[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format).\n","type":"String.String -> Vega.DataType"},{"name":"foLink","comment":" Link constraints that cause nodes to be pushed apart towards a target separation\ndistance in a force simulation. The first parameter is the name of the dataset\ncontaining the link objects, each of which should contain `source` and `target`\nfields. The second enables the id, distance, strength and number\nof iterations to be specified. If an id field parameter is provided, it is used\nto relate link objects and node objects. Otherwise, the source and target fields\nshould provide indices into the array of node objects.\n","type":"Vega.Str -> List.List Vega.ForceProperty -> Vega.Force"},{"name":"foNBody","comment":" n-body force that causes nodes to either attract or repel each other\nin a force simulation. The parameter enables the strength, theta value, and min/max\ndistances over which the force acts to be specified.\n","type":"List.List Vega.ForceProperty -> Vega.Force"},{"name":"foNum","comment":" Specify numeric values are to be parsed when reading input data.\n","type":"Vega.DataType"},{"name":"foUtc","comment":" UTC date format for parsing data using\n[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format).\n","type":"String.String -> Vega.DataType"},{"name":"foX","comment":" Force attraction towards a particular x-coordinate (first parameter), with a\ngiven strength (second parameter) on a per-node basis.\n","type":"Vega.Field -> List.List Vega.ForceProperty -> Vega.Force"},{"name":"foY","comment":" Force attraction towards a particular y-coordinate (first parameter), with a\ngiven strength (second parameter) on a per-node basis.\n","type":"Vega.Field -> List.List Vega.ForceProperty -> Vega.Force"},{"name":"fpDistance","comment":" Distance in pixels by which the link constraint should separate\nnodes (default 30).\n","type":"Vega.Num -> Vega.ForceProperty"},{"name":"fpDistanceMax","comment":" Maximum distance over which an n-body force acts. If two nodes\nexceed this value, they will not exert forces on each other.\n","type":"Vega.Num -> Vega.ForceProperty"},{"name":"fpDistanceMin","comment":" Minimum distance over which an n-body force acts. If two nodes\nare closer than this value, the exerted forces will be as if they are distanceMin\napart (default 1).\n","type":"Vega.Num -> Vega.ForceProperty"},{"name":"fpId","comment":" Data field for a nodeâs unique identifier. If provided, the source and target\nfields of each link should use these values to indicate nodes.\n","type":"Vega.Field -> Vega.ForceProperty"},{"name":"fpIterations","comment":" Number of iterations to run collision detection or link constraints (default 1)\nin a force directed simulation.\n","type":"Vega.Num -> Vega.ForceProperty"},{"name":"fpSignal","comment":" Format referenced by the value in the named signal (e.g. `csv`, `tsv`, `json`).\nUseful when dynamic loading of data with different formats is required.\n","type":"String.String -> Vega.FormatProperty"},{"name":"fpStrength","comment":" Relative strength of a force or link constraint in a force simulation.\n","type":"Vega.Num -> Vega.ForceProperty"},{"name":"fpTheta","comment":" Approximation parameter for aggregating more distance forces in a force-directed\nsimulation (default 0.9).\n","type":"Vega.Num -> Vega.ForceProperty"},{"name":"fsAlpha","comment":" Energy level or âtemperatureâ of a simulation under a force transform. Alpha\nvalues lie in the range [0, 1]. Internally, the simulation will decrease the alpha\nvalue over time, causing the magnitude of updates to diminish.\n","type":"Vega.Num -> Vega.ForceSimulationProperty"},{"name":"fsAlphaMin","comment":" Minimum amount by which to lower the alpha value on each simulation iteration\nunder a force transform.\n","type":"Vega.Num -> Vega.ForceSimulationProperty"},{"name":"fsAlphaTarget","comment":" Target alpha value to which a simulation converges under a force transformation.\n","type":"Vega.Num -> Vega.ForceSimulationProperty"},{"name":"fsAs","comment":" Names of the output fields to which node positions and velocities are written\nafter a force transformation. The default is [\"x\", \"y\", \"vx\", \"vy\"] corresponding\nto the order of parameter names.\n","type":"String.String -> String.String -> String.String -> String.String -> Vega.ForceSimulationProperty"},{"name":"fsForces","comment":" Forces to include in a force-directed simulation resulting from a force transform.\n","type":"List.List Vega.Force -> Vega.ForceSimulationProperty"},{"name":"fsIterations","comment":" Number of iterations in a force transformation when in static mode (default 300).\n","type":"Vega.Num -> Vega.ForceSimulationProperty"},{"name":"fsRestart","comment":" Whether a simulation in a force transformation should restart when node object\nfields are modified.\n","type":"Vega.Boo -> Vega.ForceSimulationProperty"},{"name":"fsStatic","comment":" Whether a simulation in a force transformation should be computed in batch to\nproduce a static layout (true) or should be animated (false).\n","type":"Vega.Boo -> Vega.ForceSimulationProperty"},{"name":"fsVelocityDecay","comment":" Friction to be applied to a simulation in a force transformation. This is applied\nafter the application of any forces during an iteration.\n","type":"Vega.Num -> Vega.ForceSimulationProperty"},{"name":"gjFeature","comment":" Field containing the GeoJSON objects to be consolidated into a feature collection\nby a geoJSON transform.\n","type":"Vega.Field -> Vega.GeoJsonProperty"},{"name":"gjFields","comment":" Fields containing longitude (first parameter) and latitude (second parameter)\nto be consolidated into a feature collection by a geoJSON transform.\n","type":"Vega.Field -> Vega.Field -> Vega.GeoJsonProperty"},{"name":"gjSignal","comment":" Name of the a new signal to capture the output of generated by a geoJSON transform.\n","type":"String.String -> Vega.GeoJsonProperty"},{"name":"gnomonic","comment":" A gnomonic map projection.\n","type":"Vega.Projection"},{"name":"gpAs","comment":" Output field in which to write a generated shape instance following a geoShape\nor geoPath transformation.\n","type":"String.String -> Vega.GeoPathProperty"},{"name":"gpField","comment":" Data field containing GeoJSON data when applying a geoShape or geoPath transformation.\nIf unspecified, the full input data object will be used.\n","type":"Vega.Field -> Vega.GeoPathProperty"},{"name":"gpPointRadius","comment":" Default radius (in pixels) to use when drawing GeoJSON Point and MultiPoint\ngeometries. An expression value may be used to set the point radius as a function\nof properties of the input GeoJSON.\n","type":"Vega.Num -> Vega.GeoPathProperty"},{"name":"grAlignAll","comment":" Indicate grid elements will be aligned and each row or column will be sized\nidentically based on the maximum observed size.\n","type":"Vega.GridAlign"},{"name":"grAlignColumn","comment":" Layout alignment to apply to grid columns. Used in cases when alignment rules\nare different for rows and columns.\n","type":"Vega.GridAlign -> Vega.GridAlign"},{"name":"grAlignEach","comment":" Indicate grid elements will be aligned into a clean grid structure, but each\nrow or column may be of variable size.\n","type":"Vega.GridAlign"},{"name":"grAlignNone","comment":" Indicate a flow grid layout will be used in which adjacent plots are placed\none after the other.\n","type":"Vega.GridAlign"},{"name":"grAlignRow","comment":" Layout alignment to apply to grid rows. Used in cases when alignment rules\nare different for rows and columns.\n","type":"Vega.GridAlign -> Vega.GridAlign"},{"name":"grAlignSignal","comment":" Layout alignment referenced by the value in the named signal.\n","type":"String.String -> Vega.GridAlign"},{"name":"grCount","comment":" Target number of sample points to take from the color scale.\n","type":"Vega.Num -> Vega.GradientScaleProperty"},{"name":"grExtent","comment":" Major and minor extents of a graticule to be the same values. Parameter should\nevaluate to a two-element list representing longitude and latitude extents.\n","type":"Vega.Num -> Vega.GraticuleProperty"},{"name":"grExtentMajor","comment":" Major extent of a graticule. Parameter should evaluate to a two-element list\nrepresenting longitude and latitude extents.\n","type":"Vega.Num -> Vega.GraticuleProperty"},{"name":"grExtentMinor","comment":" Minor extent of a graticule. Parameter should evaluate to a two-element list\nrepresenting longitude and latitude extents.\n","type":"Vega.Num -> Vega.GraticuleProperty"},{"name":"grField","comment":" Field used to bin when generating a graticule.\n","type":"Vega.Field -> Vega.GraticuleProperty"},{"name":"grLinear","comment":" Indicates a linear color gradient.\n","type":"Vega.ColorGradient"},{"name":"grPrecision","comment":" Precision in degrees with which graticule arcs are generated. The default value\nis 2.5 degrees.\n","type":"Vega.Num -> Vega.GraticuleProperty"},{"name":"grR1","comment":" The radius, normalized to [0, 1], of the inner circle for a radial color gradient.\nDefault is 0.\n","type":"Vega.Num -> Vega.GradientProperty"},{"name":"grR2","comment":" The radius, normalized to [0, 1], of the outer circle for a radial color gradient.\nDefault is 0.5.\n","type":"Vega.Num -> Vega.GradientProperty"},{"name":"grRadial","comment":" Indicates a radial color gradient. See the\n[Vega color gradient documentation](https://vega.github.io/vega/docs/types/#Gradient).\n","type":"Vega.ColorGradient"},{"name":"grStart","comment":" Starting coordinate for the gradient as an [x, y] list normalized to [0, 1].\nThis coordinate is relative to the bounds of the item being colored (default is [0, 0]).\n","type":"Vega.Num -> Vega.GradientScaleProperty"},{"name":"grStep","comment":" Major and minor step angles of a graticule to be the same values. Parameter\nshould be a two-element list representing longitude and latitude spacing.\n","type":"Vega.Num -> Vega.GraticuleProperty"},{"name":"grStepMajor","comment":" Major step angles of a graticule. Parameter should be a two-element list\nrepresenting longitude and latitude spacing.\n","type":"Vega.Num -> Vega.GraticuleProperty"},{"name":"grStepMinor","comment":" Minor step angles of a graticule. Parameter should be a two-element list\nrepresenting longitude and latitude spacing.\n","type":"Vega.Num -> Vega.GraticuleProperty"},{"name":"grStop","comment":" Stopping coordinate for the gradient as an [x, y] list normalized to [0, 1].\nThis coordinate is relative to the bounds of the item being colored (default is [1, 0]\nindicating a horizontal gradient).\n","type":"Vega.Num -> Vega.GradientScaleProperty"},{"name":"grStops","comment":" Color interpolation points. Each tuple in the list is a position normalised\n[0, 1] and its associated color.\n","type":"List.List ( Vega.Num, String.String ) -> Vega.GradientProperty"},{"name":"grX1","comment":" The x-coordinate, normalized to [0, 1], for the start of a color gradient. If\nthe gradient is linear the default is 0; if radial, it is the x-position of the\ncentre of the inner circle with a default of 0.5.\n","type":"Vega.Num -> Vega.GradientProperty"},{"name":"grX2","comment":" The x-coordinate, normalized to [0, 1], for the end of a color gradient. If\nthe gradient is linear the default is 1; if radial, it is the x-position of the\ncentre of the outer circle with a default of 0.5.\n","type":"Vega.Num -> Vega.GradientProperty"},{"name":"grY1","comment":" The y-coordinate, normalized to [0, 1], for the start of a color gradient. If\nthe gradient is linear the default is 0; if radial, it is the y-position of the\ncentre of the inner circle with a default of 0.5.\n","type":"Vega.Num -> Vega.GradientProperty"},{"name":"grY2","comment":" The y-coordinate, normalized to [0, 1], for the end of a color gradient. If\nthe gradient is linear the default is 1; if radial, it is the y-position of the\ncentre of the outer circle with a default of 0.5.\n","type":"Vega.Num -> Vega.GradientProperty"},{"name":"group","comment":" An group mark for assembling nested marks.\n","type":"Vega.Mark"},{"name":"hCenter","comment":" Convenience function for indicating a central horizontal alignment.\n","type":"Vega.Value"},{"name":"hLeft","comment":" Convenience function for indicating a left horizontal alignment.\n","type":"Vega.Value"},{"name":"hRight","comment":" Convenience function for indicating a right horizontal alignment.\n","type":"Vega.Value"},{"name":"haCenter","comment":" Center horizontal text alignment.\n","type":"Vega.HAlign"},{"name":"haLeft","comment":" Left horizontal text alignment.\n","type":"Vega.HAlign"},{"name":"haRight","comment":" Right horizontal text alignment.\n","type":"Vega.HAlign"},{"name":"haSignal","comment":" Horizontal text alignment referenced by the value in the named signal.\n","type":"String.String -> Vega.HAlign"},{"name":"hcl","comment":" A hue-chroma-luminance color interpolation.\n","type":"Vega.CInterpolate"},{"name":"hclLong","comment":" A long-path hue-chroma-luminance color interpolation.\n","type":"Vega.CInterpolate"},{"name":"height","comment":" Override the default height of the visualization. If not specified, the height\nwill be calculated based on the content of the visualization.\n","type":"Basics.Float -> ( Vega.VProperty, Vega.Spec )"},{"name":"heightSignal","comment":" Override the default height of the visualization. This requires a signal\nexpression to be used representing the height.\n","type":"String.String -> ( Vega.VProperty, Vega.Spec )"},{"name":"hmAs","comment":" Name to give the output of a heatmap transform. If not specified, defaults to\n`image`.\n","type":"String.String -> Vega.HeatmapProperty"},{"name":"hmColor","comment":" Encode raster cells in a heatmap transform with a colour. If using an expression,\nit has access `datum.$x`, `datum.$y`, `datum.$value` and `datum.$max` representing\nthe x and y positions of each raster cell, its raster value and the global maximum\nof raster values respectively. Expressions also have access to any parent data\nfields. For exxample, to colour by a grandparent's `temperature` field:\n\n    hmColor (strExpr (expr \"scale('cScale', datum.datum.temperature)\"))\n\n","type":"Vega.Str -> Vega.HeatmapProperty"},{"name":"hmField","comment":" The field containing the raster grid data to transform into a heatmap image.\nIf not provided, the data object to which transform is being applied is assumed\nto be the raster grid.\n","type":"Vega.Field -> Vega.HeatmapProperty"},{"name":"hmOpacity","comment":" Encode raster cells in a heatmap transform with an opacity value. If using an\nexpression, it has access to `datum.$x`, `datum.$y`, `datum.$value` and `datum.$max`\nrepresenting the x and y positions of each raster cell, its raster value and the\nglobal maximum of raster values respectively.\n\nFor example, to make opacity proportional to the cube of each raster value:\n\n    hmOpacity (numExpr (expr \"pow(datum.$value,3) / pow(datum.$max,3)\"))\n\nAlternativey, to set a fixed opacity:\n\n    hmOpacity (num 0.3)\n\n","type":"Vega.Num -> Vega.HeatmapProperty"},{"name":"hmResolve","comment":" Determines how the maximum value in a heatmap transform is determined, and\ntherefore used for scaling colours and opacity (`datum.$max`). Useful when standardising\ncolour or opacity ranges across multiple rasters.\n","type":"Vega.Resolution -> Vega.HeatmapProperty"},{"name":"hour","comment":" Indicate time unit is to specified as an hour of the day.\n","type":"Vega.TimeUnit"},{"name":"hsl","comment":" A hue-saturation-lightness color interpolation.\n","type":"Vega.CInterpolate"},{"name":"hslLong","comment":" A long-path hue-saturation-lightness color interpolation.\n","type":"Vega.CInterpolate"},{"name":"iCheckbox","comment":" A checkbox input element for representing a boolean state.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iColor","comment":" A color selector input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iDate","comment":" A date selector input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iDateTimeLocal","comment":" A local data time selector input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iMonth","comment":" A month selector input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iNumber","comment":" A numeric input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iRadio","comment":" A radio button input element for representing a single selection from a list\nof alternatives.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iRange","comment":" A slider input element for representing a value within a numeric range.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iSelect","comment":" A drop-down list input element for representing a single selection from a\nlist of options.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iTel","comment":" A telephone number input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iText","comment":" A free text input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iTime","comment":" A time selector input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"iWeek","comment":" A week selector input element.\n","type":"List.List Vega.InputProperty -> Vega.Bind"},{"name":"icAs","comment":" Provide name for an isocontour transform output. Default is for output field\nto be named `contour`.\n","type":"String.String -> Vega.IsocontourProperty"},{"name":"icField","comment":" The name of the field containing raster data to contour in an isocontour transform.\n","type":"Vega.Field -> Vega.IsocontourProperty"},{"name":"icLevels","comment":" The desired number of contour levels in an isocontour transform (ignored if\n[icThresholds](#icThresholds) is specified).\n","type":"Vega.Num -> Vega.IsocontourProperty"},{"name":"icNice","comment":" Whether or not contour levels should be aligned with 'nice' human-friendly values.\nIf set to true, this may alter the precise number of contour levels generated.\n","type":"Vega.Boo -> Vega.IsocontourProperty"},{"name":"icResolve","comment":" The method of resolving contour thresholds across multiple input grids. Setting\nto [reShared](#reShared) is useful when combining multiple contour plots that need\nto use a common scale.\n","type":"Vega.Resolution -> Vega.IsocontourProperty"},{"name":"icScale","comment":" Scale the output isocontour coordinates by the given factor. To scale x and y\naxes independently supply a two-element `nums` list. Useful for scaling\ncontours to match a desired output resolution.\n","type":"Vega.Num -> Vega.IsocontourProperty"},{"name":"icSmooth","comment":" Whether or not contour lines should be smoothed (ignored if using 2d KDE for\ninput generation).\n","type":"Vega.Boo -> Vega.IsocontourProperty"},{"name":"icThresholds","comment":" Provide an array of explicit contour levels for an isocontour transformation.\nIf specified, [icLevels](#icLeves), [icNice](#icNice), [icResolvee](#icResolve)\nand [icZero](#icZero) will be ignored.\n","type":"Vega.Num -> Vega.IsocontourProperty"},{"name":"icTranslate","comment":" Translate the output isocontour coordinates by the given factors in the x and y\ndirections respectively. Useful for scaling contours to match a desired coordinate space.\n","type":"Vega.Num -> Vega.Num -> Vega.IsocontourProperty"},{"name":"icZero","comment":" Whether or not an isocontour transformation should use zero as a baseline value.\n","type":"Vega.Boo -> Vega.IsocontourProperty"},{"name":"identityProjection","comment":" An 'identity' projection where longitude is projected directly to the x position\nand latitude to the y position.\n","type":"Vega.Projection"},{"name":"ifElse","comment":" Values conditional on whether an expression (first parameter) evaluates as true.\nThe second and third parameters represent the 'then' and 'else' branches of the test.\n\nTo include nested conditions, subsequent `ifElse` calls should be placed in the\n'else' branch.\n\n    maFontWeight\n        [ ifElse \"indata('selected', 'source', datum.id)\"\n            [ vStr \"bold\" ]\n            [ ifElse \"indata('selected', 'target', datum.id)\"\n                [ vStr \"bold\" ]\n                [ vNull ]\n            ]\n        ]\n\n","type":"String.String -> List.List Vega.Value -> List.List Vega.Value -> Vega.Value"},{"name":"imByMax","comment":" Use maximum of a group when imputing a missing value.\n","type":"Vega.ImputeMethod"},{"name":"imByMean","comment":" Use the mean value of a group when imputing a missing value.\n","type":"Vega.ImputeMethod"},{"name":"imByMedian","comment":" Use the median value of a group when imputing a missing value.\n","type":"Vega.ImputeMethod"},{"name":"imByMin","comment":" Use minimum of a group when imputing a missing value.\n","type":"Vega.ImputeMethod"},{"name":"imByValue","comment":" Use a specific value when imputating a missing value.\n","type":"Vega.ImputeMethod"},{"name":"imGroupBy","comment":" List of fields by which to group values in an impute transform. Imputation is\nthen performed on a per-group basis, such as a within group mean rather than global\nmean.\n","type":"List.List Vega.Field -> Vega.ImputeProperty"},{"name":"imKeyVals","comment":" Additional collection of key values that should be considered for imputation\nas part of an impute transform.\n","type":"Vega.Value -> Vega.ImputeProperty"},{"name":"imMethod","comment":" Imputation method to be used as part of an impute transform. If not specified\nthe default `imByMean` method will be used.\n","type":"Vega.ImputeMethod -> Vega.ImputeProperty"},{"name":"imValue","comment":" Value to use when an imputation method is set with `imByValue` in an impute transform.\n","type":"Vega.Value -> Vega.ImputeProperty"},{"name":"image","comment":" An image mark.\n","type":"Vega.Mark"},{"name":"inAutocomplete","comment":" Whether autocomplete should be turned on or off for input elements that\nsupport it.\n","type":"Basics.Bool -> Vega.InputProperty"},{"name":"inDebounce","comment":" Delay event handling until the given milliseconds have elapsed since the last\nevent was fired. Helps to limit event broadcasting.\n","type":"Basics.Float -> Vega.InputProperty"},{"name":"inElement","comment":" A CSS selector string indicating the parent element to which the input element\nshould be added. This allows the option of the input element to be outside the\nvisualization container, which could be used for linking separate visualizations.\n","type":"String.String -> Vega.InputProperty"},{"name":"inLabels","comment":" Labels to represent options values. If unspecified, the options value will\nbe coerced to a string and used as the label.\n","type":"Vega.Value -> Vega.InputProperty"},{"name":"inMax","comment":" Maximum value for a range slider input element.\n","type":"Basics.Float -> Vega.InputProperty"},{"name":"inMin","comment":" Minimum value for a range slider input element.\n","type":"Basics.Float -> Vega.InputProperty"},{"name":"inOptions","comment":" Options to be selected from a Radio or Select input element.\n","type":"Vega.Value -> Vega.InputProperty"},{"name":"inPlaceholder","comment":" Place-holding text for input elements before any value has been entered.\n","type":"String.String -> Vega.InputProperty"},{"name":"inStep","comment":" Step value (increment between adjacent selectable values) for a range slider\ninput element.\n","type":"Basics.Float -> Vega.InputProperty"},{"name":"jaAs","comment":" Output fields to be generated by a join aggregate transform.\n","type":"List.List String.String -> Vega.JoinAggregateProperty"},{"name":"jaFields","comment":" Fields to aggregate in join aggregate transform.\n","type":"List.List Vega.Field -> Vega.JoinAggregateProperty"},{"name":"jaGroupBy","comment":" Fields to group by in a join aggregate transform.\n","type":"List.List Vega.Field -> Vega.JoinAggregateProperty"},{"name":"jaOps","comment":" Operations in a join aggregate transform.\n","type":"List.List Vega.Operation -> Vega.JoinAggregateProperty"},{"name":"joBevel","comment":" Bevelled stroke join.\n","type":"Vega.StrokeJoin"},{"name":"joMiter","comment":" Mitered stroke join.\n","type":"Vega.StrokeJoin"},{"name":"joRound","comment":" Rounded stroke join.\n","type":"Vega.StrokeJoin"},{"name":"joSignal","comment":" Stroke join (`miter`, `round` or `bevel`) referenced by the value in the\nnamed signal.\n","type":"String.String -> Vega.StrokeJoin"},{"name":"json","comment":" Indicate a JSON format when parsing a data source.\n","type":"Vega.FormatProperty"},{"name":"jsonProperty","comment":" Property to be extracted from some JSON when it has some surrounding structure\nor meta-data. e.g., specifying the property `values.features` is equivalent to\nretrieving `json.values.features` from the loaded JSON object with a custom delimiter.\n","type":"Vega.Str -> Vega.FormatProperty"},{"name":"kd2As","comment":" Field to contain a 2d KDE transform's raster values If not specified, the\noutput will allocated to a field named `grid`.\n","type":"String.String -> Vega.Kde2Property"},{"name":"kd2Bandwidth","comment":" Widths of the 2d Gaussian kernel for a 2d KDE transform in x, y order. If 0\n(default), the bandwidth is automatically determined.\n","type":"Vega.Num -> Vega.Num -> Vega.Kde2Property"},{"name":"kd2CellSize","comment":" Density calculation cell size determining the level of spatial approximation\nin a 2d KDE transform. The default value of 4 results in 2x reduction to the width\nand height of the estimation; a value of 1 would result in an output raster matching\nthe dimensions of the estimator's size.\n","type":"Vega.Num -> Vega.Kde2Property"},{"name":"kd2Counts","comment":" Whether or not a 2d KDE transform should genreate smoothed counts (true) or\nprobability estimates (false, default).\n","type":"Vega.Boo -> Vega.Kde2Property"},{"name":"kd2GroupBy","comment":" The data fields to group by for a 2d KDE transform. If not specified a single group\nof all data objects is used.\n","type":"List.List Vega.Field -> Vega.Kde2Property"},{"name":"kd2Weight","comment":" The data point weight field used in a 2d KDE density estimation. If unspecified,\nall points are assumed to have an equal unit weighting.\n","type":"Vega.Field -> Vega.Kde2Property"},{"name":"kdAs","comment":" Fields to contain a KDE transform's values (assigned to a new field named\nin the first parameter) and probabilities (field named in the second parameter).\nIf not specified, the output will allocated to fields named `value` and `density`.\n","type":"String.String -> String.String -> Vega.KdeProperty"},{"name":"kdBandwidth","comment":" Width of the Gaussian kernel for a KDE transform. If 0 (default), the bandwidth\nis determined from the input via [Scott's method](https://stats.stackexchange.com/questions/90656/kernel-bandwidth-scotts-vs-silvermans-rules).\n","type":"Vega.Num -> Vega.KdeProperty"},{"name":"kdCounts","comment":" Whether or not a KDE transform should genreate smoothed counts (true) or\nprobability estimates (false, default).\n","type":"Vega.Boo -> Vega.KdeProperty"},{"name":"kdCumulative","comment":" Whether or not a KDE transform generates cumulative density estimates. Default\nis false.\n","type":"Vega.Boo -> Vega.KdeProperty"},{"name":"kdExtent","comment":" The minimum and maximum from which to sample the distribution for a KDE transform,\nexpressed as a two-element list. If not specified, the full domain extent is used.\n","type":"Vega.Num -> Vega.KdeProperty"},{"name":"kdGroupBy","comment":" The data fields to group by for a KDE transform. If not specified a single group\nof all data objects is used.\n","type":"List.List Vega.Field -> Vega.KdeProperty"},{"name":"kdMaxSteps","comment":" The maximum number of samples (default 200) to take along the [extent](#kdExtent)\ndomain when performing a KDE transform.\n","type":"Vega.Num -> Vega.KdeProperty"},{"name":"kdMinSteps","comment":" The minimum number of samples (default 25) to take along the [extent](#kdExtent)\ndomain when performing a KDE transform.\n","type":"Vega.Num -> Vega.KdeProperty"},{"name":"kdResolve","comment":" Indicate how multiple densities should be resolved when performing a KDE transform.\nIf `reIndependent` (default), each density may have its own extent and number of\ncurve sample steps. If `reShared` all densities share the same extent and samples,\nwhich is useful for stacked densities.\n","type":"Vega.Resolution -> Vega.KdeProperty"},{"name":"kdSteps","comment":" The exact number of samples to take along the [extent](#kdExtent) domain when\nperforming a KDE transform. Overrides [kdMinSteps](#kdMinSteps) and [kdMaxSteps](#kdMaxSteps).\n","type":"Vega.Num -> Vega.KdeProperty"},{"name":"keyValue","comment":" Custom key-value pair to be stored in an object generated by [vObject](#vObject).\n","type":"String.String -> Vega.Value -> Vega.Value"},{"name":"lab","comment":" An CIELab color interpolation.\n","type":"Vega.CInterpolate"},{"name":"layout","comment":" Create a layout used in the visualization. For example the following creates\na three-column layout with 20 pixel padding between columns:\n\n    lo =\n        layout [ loColumns (num 3), loPadding (num 20) ]\n\n","type":"List.List Vega.LayoutProperty -> ( Vega.VProperty, Vega.Spec )"},{"name":"leAria","comment":" [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) properties\nfor providing accessible SVG output associated with a legend. If an empty list is\nprovided, ARIA tagging will be switched off.\n","type":"List.List Vega.Aria -> Vega.LegendProperty"},{"name":"leBorderStrokeDash","comment":" Stroke dash style of the border of a legend block. The list should consist\nof alternating dash-gap lengths in pixels or an empty list for a solid line.\nUsed only when configuring legends via [cfLegend](#cfLegend).\n","type":"List.List Vega.Value -> Vega.LegendProperty"},{"name":"leBorderStrokeWidth","comment":" Default stroke width of the border around legends in pixel units. Used only\nwhen configuring legends via [cfLegend](#cfLegend).\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leClipHeight","comment":" Height in pixels to clip a symbol legend entries and limit its size.\nBy default no clipping is performed.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leColumnPadding","comment":" Horizontal padding between entries in a symbol legend.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leColumns","comment":" Number of columns in which to arrange symbol legend entries. A\nvalue of 0 or lower indicates a single row with one column per entry. The default\nis 0 for horizontal symbol legends and 1 for vertical symbol legends.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leCornerRadius","comment":" Corner radius for an enclosing legend rectangle.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leDirection","comment":" Direction of a legend.\n","type":"Vega.Orientation -> Vega.LegendProperty"},{"name":"leEncode","comment":" Mark encodings for custom legend styling. For example, to create a horizontal\ndash symbol (using a simple SVG path) for each legend item:\n\n    legend\n        [ leEncode [ enSymbols [ enEnter [ maShape [ vStr \"M-0.5,0H1\" ] ] ] ]\n        , leStroke \"myColourScale\"\n        ]\n\n","type":"List.List Vega.LegendEncoding -> Vega.LegendProperty"},{"name":"leFill","comment":" Name of the scale that maps to the legend symbols' fill colors.\n","type":"String.String -> Vega.LegendProperty"},{"name":"leFillColor","comment":" Bbackground color of an enclosing legend rectangle.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leFormat","comment":" Format pattern for legend labels. Text should be either a\n[d3-format specifier](https://github.com/d3/d3-format#locale_format) or a\n[d3-time-format specifier](https://github.com/d3/d3-time-format#locale_format).\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leFormatAsNum","comment":" Indicate that legend labels should be formatted as numbers. To control the precise\nnumeric format, additionally use [leFormat](#leFormat) providing a\n[d3 numeric format string](https://github.com/d3/d3-format#locale_format).\n","type":"Vega.LegendProperty"},{"name":"leFormatAsTemporal","comment":" Indicate that legend labels should be formatted as dates/times. To control the\nprecise temporal format, additionally use [leFormat](#leFormat) providing a\n[d3 date/time format string](https://github.com/d3/d3-time-format#locale_format).\n","type":"Vega.LegendProperty"},{"name":"leFormatAsTemporalUtc","comment":" Indicate that legend labels should be formatted as UTC dates/times. To control the\nprecise temporal format.\n","type":"Vega.LegendProperty"},{"name":"leGradientLabelLimit","comment":" Maximum allowed length of gradient labels in a legend. Used only when\nconfiguring legends via [cfLegend](#cfLegend).\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leGradientLabelOffset","comment":" Vertical offset in pixels for gradient labels in a legend. Used only when\nconfiguring legends via [cfLegend](#cfLegend).\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leGradientLength","comment":" Length in pixels of the primary axis of a color gradient in a\nlegend. This value corresponds to the height of a vertical gradient or the width\nof a horizontal gradient.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leGradientOpacity","comment":" Opacity of a color gradient in a legend.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leGradientStrokeColor","comment":" Color of a legend's color gradient border.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leGradientStrokeWidth","comment":" Width of a legend's color gradient border.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leGradientThickness","comment":" Thickness in pixels of the color gradient in a legend. This value\ncorresponds to the width of a vertical gradient or the height of a horizontal\ngradient.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leGridAlign","comment":" Alignment to apply to symbol legends rows and columns.\n","type":"Vega.GridAlign -> Vega.LegendProperty"},{"name":"leLabelAlign","comment":" Horizontal text alignment for a legend label.\n","type":"Vega.HAlign -> Vega.LegendProperty"},{"name":"leLabelBaseline","comment":" Vertical text alignment for a legend label.\n","type":"Vega.VAlign -> Vega.LegendProperty"},{"name":"leLabelColor","comment":" Text color for legend labels.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leLabelFont","comment":" Font for legend labels.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leLabelFontSize","comment":" Font size in pixels for legend labels.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leLabelFontStyle","comment":" Font style of an legend label such as `str \"normal\"` or `str \"italic\"`.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leLabelFontWeight","comment":" Font weight for legend labels.\n","type":"Vega.Value -> Vega.LegendProperty"},{"name":"leLabelLimit","comment":" Maximum allowed length in pixels of a legend label.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leLabelOffset","comment":" Horizontal pixel offset for a legend's symbols.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leLabelOpacity","comment":" Opacity for a legend's labels.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leLabelOverlap","comment":" Strategy to use for resolving overlap of labels in gradient legends.\n","type":"Vega.OverlapStrategy -> Vega.LegendProperty"},{"name":"leLabelSeparation","comment":" Minimum separation that must be between labels for them to be considered\nnon-overlapping. Ignored if [leLabelOverlap](#leLabelOverlap) resolution not enabled.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leLayout","comment":" Specify legend layout properties when arranging multiple legends. Used only\nwhen configuring legends via [cfLegend](#cfLegend).\n","type":"List.List Vega.LeLayoutProperty -> Vega.LegendProperty"},{"name":"leOffset","comment":" Offset in pixels by which to displace the legend from the data rectangle and axes.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leOpacity","comment":" Name of the scale that maps to the legend symbols' opacities.\n","type":"String.String -> Vega.LegendProperty"},{"name":"leOrient","comment":" Orientation of the legend, determining where the legend is placed\nrelative to a chartâs data rectangle.\n","type":"Vega.LegendOrientation -> Vega.LegendProperty"},{"name":"leOrientLayout","comment":" Specify legend layout properties for specific orientations when arranging\nmultiple legends. Each tuple in the list should match an orientation with a list\nof layout properties. For example,\n\n    leOrientLayout\n        [ ( loBottom, [ llAnchor anEnd ] )\n        , ( loTop, [ llMargin (num 50), llCenter true ] )\n        ]\n\nUsed only when configuring legends via [cfLegend](#cfLegend).\n\n","type":"List.List ( Vega.LegendOrientation, List.List Vega.LeLayoutProperty ) -> Vega.LegendProperty"},{"name":"lePadding","comment":" Padding between the border and content of the legend group.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leRowPadding","comment":" Vertical padding between entries in a symbol legend.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leShape","comment":" Name of the scale that maps to the legend symbols' shapes.\n","type":"String.String -> Vega.LegendProperty"},{"name":"leSize","comment":" Name of the scale that maps to the legend symbols' sizes.\n","type":"String.String -> Vega.LegendProperty"},{"name":"leStroke","comment":" Name of the scale that maps to the legend symbols' strokes.\n","type":"String.String -> Vega.LegendProperty"},{"name":"leStrokeColor","comment":" Border color of an enclosing legend rectangle.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leStrokeDash","comment":" Name of the scale that maps to the legend symbols' stroke dashing.\n","type":"String.String -> Vega.LegendProperty"},{"name":"leStrokeWidth","comment":" Name of the scale that maps to a stroke width used in a legend.\n","type":"String.String -> Vega.LegendProperty"},{"name":"leSymbolBaseFillColor","comment":" Default fill color for legend symbols. This is only applied if there\nis no fill scale color encoding for the legend and when configuring legends\nvia [cfLegend](#cfLegend).\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leSymbolBaseStrokeColor","comment":" Default stroke color for legend symbols. This is only applied if there is no\nstroke scale color encoding for the legend and when configuring legends via\n[cfLegend](#cfLegend).\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leSymbolDash","comment":" Stroke dash of an legend's symbols as a list of dash-gap lengths or empty\nlist for solid lines.\n","type":"List.List Vega.Value -> Vega.LegendProperty"},{"name":"leSymbolDashOffset","comment":" Pixel offset from which to start a legend's symbol dash list.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leSymbolDirection","comment":" Default direction for legend symbols. This is only applied when configuring\nlegends via [cfLegend](#cfLegend).\n","type":"Vega.Orientation -> Vega.LegendProperty"},{"name":"leSymbolFillColor","comment":" Fill color for legend symbols.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leSymbolLimit","comment":" Maximum number of allowed entries for a symbol legend. Entries exceeding this\nlimit are replaced with a single ellipsis and an indication of how many entries\nhave been dropped.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leSymbolOffset","comment":" Offset in pixels between legend labels their corresponding symbol or gradient.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leSymbolOpacity","comment":" Opacity for a legend's symbols.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leSymbolSize","comment":" Default symbol area size in square pixel units.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leSymbolStrokeColor","comment":" Border color for legend symbols.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leSymbolStrokeWidth","comment":" Default symbol border width used in a legend.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leSymbolType","comment":" Default symbol shape used in a legend.\n","type":"Vega.Symbol -> Vega.LegendProperty"},{"name":"leTemporalTickCount","comment":" Ddesired number of ticks for a temporal legend. The first parameter\nis the type of temporal interval to use and the second the number of steps of that\ninterval between ticks. For example, to specify a tick is requested at six-month\nintervals (e.g. January, July):\n\n    lg =\n        legends\n            << legend\n                [ leFill \"cScale\"\n                , leType ltGradient\n                , leFormat (str \"%b %Y\")\n                , leTemporalTickCount month (num 6)\n                ]\n\nIf the second parameter is not a positive value, the number of ticks will be\nauto-generated for the given interval type.\n\n","type":"Vega.TimeUnit -> Vega.Num -> Vega.LegendProperty"},{"name":"leTickCount","comment":" Desired number of tick values for quantitative legends.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leTickMinStep","comment":" Minimum desired step between quantitative legend's ticks in scale domain units.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leTitle","comment":" Title for the legend (none by default). To specify a multi-line legend title,\nprovide an array of title lines, one element per line. For example,\n\n      leTitle (strs [ \"Origin\", \"(country of Manufacture)\" ])\n\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leTitleAlign","comment":" Horizontal alignment for a legend title.\n","type":"Vega.HAlign -> Vega.LegendProperty"},{"name":"leTitleAnchor","comment":" The anchor position for placing a legend title.\n","type":"Vega.Anchor -> Vega.LegendProperty"},{"name":"leTitleBaseline","comment":" Vertical alignment for a legend title.\n","type":"Vega.VAlign -> Vega.LegendProperty"},{"name":"leTitleColor","comment":" Text color for a legend title.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leTitleFont","comment":" Font for a legend title.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leTitleFontSize","comment":" Font size in pixel units for a legend title.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leTitleFontStyle","comment":" Font style of an legend title such as `str \"normal\"` or `str \"italic\"`.\n","type":"Vega.Str -> Vega.LegendProperty"},{"name":"leTitleFontWeight","comment":" Font weight for a legend title.\n","type":"Vega.Value -> Vega.LegendProperty"},{"name":"leTitleLimit","comment":" Maximum allowed length in pixels of a legend title.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leTitleLineHeight","comment":" Line height in pixels of each line of text in a multi-line legend title.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leTitleOpacity","comment":" Opacity for a legend's title.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leTitleOrient","comment":" Positioning of a legend's title relative to its content.\n","type":"Vega.Side -> Vega.LegendProperty"},{"name":"leTitlePadding","comment":" Padding between the legend title and entries.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leType","comment":" Type of legend.\n","type":"Vega.LegendType -> Vega.LegendProperty"},{"name":"leValues","comment":" Explicitly set visible legend values.\n","type":"List.List Vega.Value -> Vega.LegendProperty"},{"name":"leX","comment":" x-position of legend group in pixel units for absolute positioning when\n[leOrient](#leOrient) is set to `loNone`.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leY","comment":" y-position of legend group in pixel units for absolute positioning when\n[leOrient](#leOrient) is set to `loNone`.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"leZIndex","comment":" z-index indicating the layering of the legend group relative to other axis,\nmark and legend groups. The default value is 0.\n","type":"Vega.Num -> Vega.LegendProperty"},{"name":"legend","comment":" Create a legend used to visualize a color, size or shape mapping.\n","type":"List.List Vega.LegendProperty -> List.List Vega.Spec -> List.List Vega.Spec"},{"name":"legends","comment":" Create legends used to visualize color, size and shape mappings. Commonly the\nfunctional composition operator (`<<`) is used to combine multiple legend\nspecifications. For example,\n\n    lg =\n        legends\n            << legend\n                [ leTitle (str \"Income\")\n                , leOrient loBottomRight\n                , leType ltSymbol\n                , leSize \"mySizeScale\"\n                ]\n            << legend\n                [ leTitle (str \"Nationality\")\n                , leOrient loTopRight\n                , leType ltSymbol\n                , leFill \"myColorScale\"\n                ]\n\n","type":"List.List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"},{"name":"line","comment":" A line mark.\n","type":"Vega.Mark"},{"name":"llAnchor","comment":" The anchor position for placing a legend relative to its nearest axis.\n","type":"Vega.Anchor -> Vega.LeLayoutProperty"},{"name":"llBounds","comment":" The type of bounding box calculation to use for determining legend extents.\n","type":"Vega.BoundsCalculation -> Vega.LeLayoutProperty"},{"name":"llCenter","comment":" Whether or not a legend should be centred within its layout area. Default is `false`.\n","type":"Vega.Boo -> Vega.LeLayoutProperty"},{"name":"llDirection","comment":" The direction in which subsequent legends should be positioned in a\nmulti-legend layout. Should be one of `orHorizontal` or `orVertical`.\n","type":"Vega.Orientation -> Vega.LeLayoutProperty"},{"name":"llMargin","comment":" Margin in pixel units to place between adjacent legends in a multi-legend layout.\n","type":"Vega.Num -> Vega.LeLayoutProperty"},{"name":"llOffset","comment":" Offset of a legend from the chart body in pixel units.\n","type":"Vega.Num -> Vega.LeLayoutProperty"},{"name":"loAlign","comment":" Alignment to apply to grid rows and columns in a grid layout.\n","type":"Vega.GridAlign -> Vega.LayoutProperty"},{"name":"loBottom","comment":" Position legend below the bottom of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"loBottomLeft","comment":" Position legend to be witin the bottom-left of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"loBottomRight","comment":" Position legend to be witihin the bottom-right of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"loBounds","comment":" Bounds calculation method to use for determining the extent of a\nsub-plot in a grid layout.\n","type":"Vega.BoundsCalculation -> Vega.LayoutProperty"},{"name":"loColumns","comment":" Number of columns to include in a grid layout. If unspecified, a\nsingle row with unlimited columns will be assumed.\n","type":"Vega.Num -> Vega.LayoutProperty"},{"name":"loFooterBand","comment":" Band positioning in the interval [0,1] indicating where in a cell\na footer should be placed in a grid layout.\n","type":"Vega.Num -> Vega.LayoutProperty"},{"name":"loFooterBandRC","comment":" Similar to [loFooterBand](#loFooterBand) but allowing row and column settings\nto be specified separately.\n","type":"Vega.Num -> Vega.Num -> Vega.LayoutProperty"},{"name":"loHeaderBand","comment":" Band positioning in the interval [0,1] indicating where in a cell a header\nshould be placed in a grid layout. For a column header, 0 maps to the left edge\nof the header cell and 1 to right edge. For a row footer, the range maps from\ntop to bottom.\n","type":"Vega.Num -> Vega.LayoutProperty"},{"name":"loHeaderBandRC","comment":" Similar to [loFHeaderBand](#loHeaderBand) but allowing row and column settings\nto be specified separately.\n","type":"Vega.Num -> Vega.Num -> Vega.LayoutProperty"},{"name":"loLeft","comment":" Position legend to the left of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"loNone","comment":" Do not perform automatic legend positioning (allows legend to be located explicitly\nvia `x` `y` coordinates). For example,\n\n    legend\n        [ leTitle (str \"Weight\")\n        , leOpacity \"oScale\"\n        , leSymbolType symCircle\n        , leOrient loNone\n        , leEncode [ enLegend [ enEnter [ maX [ vNum 320 ], maY [ vNum 30 ] ] ] ]\n        ]\n\n","type":"Vega.LegendOrientation"},{"name":"loOffset","comment":" Orthogonal offset in pixels by which to displace grid header, footer\nand title cells from their position along the edge of a grid layout.\n","type":"Vega.Num -> Vega.LayoutProperty"},{"name":"loOffsetRC","comment":" Similar to [loOffset](#loOffset) but allowing row and column settings to be\nspecified separately.\n","type":"Vega.Num -> Vega.Num -> Vega.LayoutProperty"},{"name":"loPadding","comment":" Padding in pixels to add between elements within rows and columns\nof a grid layout.\n","type":"Vega.Num -> Vega.LayoutProperty"},{"name":"loPaddingRC","comment":" Similar to [loPadding](#loPadding) but allowing row and column settings to be\nspecified separately.\n","type":"Vega.Num -> Vega.Num -> Vega.LayoutProperty"},{"name":"loRight","comment":" Position legend to the right of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"loSignal","comment":" Legend position referenced by the value in the named signal.\n","type":"String.String -> Vega.LegendOrientation"},{"name":"loTitleBand","comment":" Title placement in a grid layout. For a column title, 0 maps to the left edge\nof the title cell and 1 to right edge. The default value is 0.5, indicating a\ncentred position.\n","type":"Vega.Num -> Vega.LayoutProperty"},{"name":"loTitleBandRC","comment":" Similar to [loTitleBand](#loTitleBand) but allowing row and column settings\nto be specified separately.\n","type":"Vega.Num -> Vega.Num -> Vega.LayoutProperty"},{"name":"loTop","comment":" Position legend above the top of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"loTopLeft","comment":" Position legend to be within the top-left of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"loTopRight","comment":" Position legend to be within the top-right of the visualization it describes.\n","type":"Vega.LegendOrientation"},{"name":"lowercase","comment":" Make text lowercase when pre-processing as part of a count pattern transformation.\n","type":"Vega.Case"},{"name":"lpAs","comment":" Name for the output field of a link path in a linkPath transformation.\nIf not specified, the default is \"path\".\n","type":"String.String -> Vega.LinkPathProperty"},{"name":"lpOrient","comment":" Orientation of a link path in a linkPath transformation. If a radial\norientation is specified, x and y coordinate parameters will be interpreted as an\nangle (in radians) and radius, respectively.\n","type":"Vega.Orientation -> Vega.LinkPathProperty"},{"name":"lpRequire","comment":" A required signal that a linkpath transform depends upon. This is needed if\nsource or target coordinates are set as a non-propagating side-effect of a transform\nin a different stream such as a force transform. In such cases the upstream transform\nshould be bound to a signal and required with this function.\n","type":"String.String -> Vega.LinkPathProperty"},{"name":"lpShape","comment":" Shape of a link path in a linkPath transformation.\n","type":"Vega.LinkShape -> Vega.LinkPathProperty"},{"name":"lpSourceX","comment":" Field for the source x-coordinate in a linkPath transformation.\nThe default is `source.x`.\n","type":"Vega.Field -> Vega.LinkPathProperty"},{"name":"lpSourceY","comment":" Field for the source y-coordinate in a linkPath transformation.\nThe default is `source.y`.\n","type":"Vega.Field -> Vega.LinkPathProperty"},{"name":"lpTargetX","comment":" Field for the target x-coordinate in a linkPath transformation.\nThe default is `target.x`.\n","type":"Vega.Field -> Vega.LinkPathProperty"},{"name":"lpTargetY","comment":" Field for the target y-coordinate in a linkPath transformation.\nThe default is `target.y`.\n","type":"Vega.Field -> Vega.LinkPathProperty"},{"name":"lsArc","comment":" Arcs of circles linking nodes in a link diagram.\n","type":"Vega.LinkShape"},{"name":"lsAs","comment":" Names of loess (locally estimated regression) output fields representing the\nindependent (predictor) and dependent (predicted) smoothed values. If not supplied,\nthe names of the input independent and dependent fields will be used.\n","type":"String.String -> String.String -> Vega.LoessProperty"},{"name":"lsBandwidth","comment":" Bandwidth to be used when performing a loess (locally estimated regression)\ntransform. The parameter is is the proportion of the entire dataset to include in\nthe sliding window. Default is 0.3 (i.e. 30% of values).\n","type":"Vega.Num -> Vega.LoessProperty"},{"name":"lsCurve","comment":" Curved lines linking nodes in a link diagram.\n","type":"Vega.LinkShape"},{"name":"lsDiagonal","comment":" Curved diagonal lines linking nodes in a link diagram.\n","type":"Vega.LinkShape"},{"name":"lsGroupBy","comment":" Group by a given set of fields when performing a loess (locally estimated regression)\ntransform.\n","type":"List.List Vega.Field -> Vega.LoessProperty"},{"name":"lsLine","comment":" Straight lines linking nodes in a link diagram.\n","type":"Vega.LinkShape"},{"name":"lsOrthogonal","comment":" Orthogonal lines linking nodes in a link diagram.\n","type":"Vega.LinkShape"},{"name":"lsSignal","comment":" Line shape between nodes referenced by the value in the named signal.\n","type":"String.String -> Vega.LinkShape"},{"name":"ltGradient","comment":" Legend to represent continuous data.\n","type":"Vega.LegendType"},{"name":"ltSignal","comment":" Legend type (`symbol` or `gradient`) referenced by the value in the named signal.\n","type":"String.String -> Vega.LegendType"},{"name":"ltSymbol","comment":" legend with discrete items.\n","type":"Vega.LegendType"},{"name":"luAs","comment":" Output fields in which to write data found in the secondary stream of a lookup.\n","type":"List.List String.String -> Vega.LookupProperty"},{"name":"luDefault","comment":" Default value to assign if lookup fails in a lookup transformation.\n","type":"Vega.Value -> Vega.LookupProperty"},{"name":"luValues","comment":" Fields to copy from the secondary stream to the primary\nstream in a lookup transformation. If not specified, a reference to the full data\nrecord is copied.\n","type":"List.List Vega.Field -> Vega.LookupProperty"},{"name":"mAria","comment":" [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) properties\nfor providing accessible SVG output associated with a mark. If an empty list is\nprovided, ARIA tagging will be switched off.\n","type":"List.List Vega.Aria -> Vega.TopMarkProperty"},{"name":"mClip","comment":" Indicate whether or how marks should be clipped to a specified shape. For a\nsimple case of clipping to the retangular 'data rectangle':\n\n    mClip (clEnabled true)\n\nTo clip by some abritrary simple polygon use [clPath](#clPath) either to specify\nan SVG path string explicitly in pixel coordinates, or more usefully for geographic\ncoordinates use the output of [trGeoPath](#trGeoPath):\n\n    ds =\n        dataSource\n            [ data \"myClippingPoly\"\n                [ daUrl (str \"myPolyFile.json\")\n                , daFormat [ topojsonFeature \"idOfClippingPoly\" ]\n                ]\n                |> transform [ trGeoPath \"myProjection\" [] ]\n            ...\n\n    mk =\n        marks\n              << mark path\n                  [ mFrom [ srData (str \"myMapSource\") ]\n                  , mClip (clPath (strSignal \"data('myClippingPoly')[0]['path']\"))\n                  ...\n\n","type":"Vega.Clip -> Vega.TopMarkProperty"},{"name":"mDescription","comment":" Description of a mark, useful for inline comments.\n","type":"String.String -> Vega.TopMarkProperty"},{"name":"mEncode","comment":" The visual encoding rules for a mark.\n","type":"List.List Vega.EncodingProperty -> Vega.TopMarkProperty"},{"name":"mFrom","comment":" Data source to be visualized by a mark. If not specified, a single\nelement dataset containing an empty object is assumed. The source can either be\na dataset to use or a faceting directive to subdivide a dataset across a set\nof group marks.\n","type":"List.List Vega.Source -> Vega.TopMarkProperty"},{"name":"mGroup","comment":" Assemble a group of top-level marks. Used to create nested groups\nof marks within a [group](#group) mark (including further nested group specifications)\nby suppyling the specification as a series of properties. For example,\n\n    marks\n        << mark group\n            [ mFrom [ srData (str \"myData\") ]\n            , mGroup [ mkGroup1 [], mkGroup2 [] ]\n            ]\n\n","type":"List.List ( Vega.VProperty, Vega.Spec ) -> Vega.TopMarkProperty"},{"name":"mInteractive","comment":" Whether a mark can serve as an input event source. If false, no\nmouse or touch events corresponding to the mark will be generated.\n","type":"Vega.Boo -> Vega.TopMarkProperty"},{"name":"mKey","comment":" Field to use as a unique key for data binding. When a\nvisualizationâs data is updated, the key value will be used to match data elements\nto existing mark instances. Use a key field to enable object constancy for\ntransitions over dynamic data.\n","type":"Vega.Field -> Vega.TopMarkProperty"},{"name":"mName","comment":" Unique name to be given to a mark. This name can be used to refer to the mark\nin another mark or within an event stream definition. SVG renderers will add this\nname value as a CSS class name on the enclosing SVG group (g) element containing\nthe mark instances.\n","type":"String.String -> Vega.TopMarkProperty"},{"name":"mOn","comment":" Triggers for modifying a mark's properties in response to signal changes.\n","type":"List.List Vega.Trigger -> Vega.TopMarkProperty"},{"name":"mSort","comment":" Fields and sort order for sorting mark items. The sort order will\ndetermine the default rendering order. This is defined over generated scenegraph\nitems and sorting is performed after encodings are computed, allowing items to be\nsorted by size or position. To sort by underlying data properties in addition to\nmark item properties, append the prefix `datum` to a field name.\n\n    mSort [ ( field \"datum.y\", ascend ) ]\n\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.TopMarkProperty"},{"name":"mStyle","comment":" Names of custom styles to apply to a mark. A style is a named\ncollection of mark property defaults defined within the configuration. These\nproperties will be applied to the markâs enter encoding set, with later styles\noverriding earlier styles. Any properties explicitly defined within the markâs\n`encode` block will override a style default.\n","type":"List.List String.String -> Vega.TopMarkProperty"},{"name":"mTransform","comment":" Post-encoding transforms to be applied after any encode\nblocks, that operate directly on mark scenegraph items (not backing data objects).\nThese can be useful for performing layout with transforms that can set x, y,\nwidth, height, etc. properties. Only data transforms that do not generate or\nfilter data objects should be used.\n","type":"List.List Vega.Transform -> Vega.TopMarkProperty"},{"name":"mZIndex","comment":" z-index (draw order) of a mark. Marks with higher values are drawn\n'on top' of marks with lower numbers. Useful when drawing node-link diagrams and\nthe node symbol should sit on top of connected edge lines.\n","type":"Vega.Num -> Vega.TopMarkProperty"},{"name":"maAlign","comment":" Horizontal alignment of a text or image mark. To guarantee valid\nalignment type names, use `hCenter`, `hLeft` etc. For example:\n\n    << mark text\n        [ mEncode\n            [ enEnter [ maAlign [ hCenter ] ] ]\n        ]\n\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maAngle","comment":" Rotation angle in degrees of a text, path or symbol mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maAspect","comment":" Whether or not image aspect ratio should be preserved in an image mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maBaseline","comment":" Vertical baseline of a text or image mark. To guarantee valid\nalignment type names, use `vTop`, `vMiddle` etc. For example:\n\n    << mark text\n        [ mEncode\n            [ enEnter [ maBaseline [ vTop ] ] ]\n        ]\n\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maBlend","comment":" Color blend mode for drawing an item over its current background. Standard\n[CSS blend modes](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)\ncan be specified with [blendModeValue](#blendModeValiue) providing an appropriate\nblend mode such as [bmHue](#bmHue), [bmDarken](#bmDarken) etc.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maCornerRadius","comment":" Corner radius in pixels of an arc or rect mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maCornerRadiusBottomLeft","comment":" The radius in pixels of the bottom-left corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maCornerRadiusBottomRight","comment":" The radius in pixels of the bottom-right corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maCornerRadiusTopLeft","comment":" The radius in pixels of the top-left corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maCornerRadiusTopRight","comment":" The radius in pixels of the top-right corner of a rectangle mark. Will override\nany value specified in [maCornerRadius](#maCornerRadius).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maCursor","comment":" Cursor to be displayed over a mark. To guarantee valid cursor type\nnames, use [cursorValue](#cursorValue).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maCustom","comment":" Create a custom mark property. For example:\n\n    mEncode\n        [ enEnter\n            [ maFill [ vScale \"cScale\", vField (field \"group\") ]\n            , maCustom \"myName\" [ vScale \"xScale\", vField (field \"group\") ]\n            ]\n        ]\n\nSee the\n[Vega Beeswarm plot example](https://vega.github.io/vega/examples/beeswarm-plot/).\n\n","type":"String.String -> List.List Vega.Value -> Vega.MarkProperty"},{"name":"maDefined","comment":" Indicate if the current data point in a linear mark is defined. If false, the\ncorresponding line/trail segment will be omitted, creating a âbreakâ.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maDir","comment":" Direction text is rendered in a text mark. This determines which side is\ntruncated in response to the text size exceeding the value of the limit parameter.\nTo guarantee valid direction type names, use [textDirectionValue](#textDirectionValue).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maDx","comment":" Horizontal offset in pixels (before rotation), between the text and anchor\npoint of a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maDy","comment":" Vertical offset in pixels (before rotation), between the text and anchor\npoint of a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maEllipsis","comment":" Ellipsis string for text truncated in response to the limit parameter of\na text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maEndAngle","comment":" End angle in radians clockwise from north for an arc mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maFill","comment":" Fill color of a mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maFillOpacity","comment":" The fill opacity of a mark in the range 0 to 1.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maFont","comment":" Typeface used by a text mark. This can be a generic font description such\nas `sans-serif`, `monospace` or any specific font name made accessible via a css\nfont definition.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maFontSize","comment":" The font size in pixels used by a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maFontStyle","comment":" The font style, such as `normal` or `italic` used by a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maFontWeight","comment":" The font weight, such as `normal` or `bold` used by a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maGroupClip","comment":" Indicate if the visible group content should be clipped to the groupâs\nspecified width and height.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maHRef","comment":" URL to load upon mouse click. If defined, the mark acts as a hyperlink.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maHeight","comment":" Height of a mark in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maImage","comment":" A dynmically created image that may be displayed as an image mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maInnerRadius","comment":" The inner radius in pixel units of an arc mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maInterpolate","comment":" Interpolation style of a linear mark. To guarantee valid\ninterpolation type names, use [markInterpolationValue](#markInterpolationValue).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maLimit","comment":" The maximum length of a text mark in pixels (default 0, indicating no limit).\nThe text value will be automatically truncated if the rendered size exceeds this\nlimit.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maLineBreak","comment":" A delimeter, such as a newline character, used to break text strings into\nmultiple lines. Ignored if input text is specified via multi-line `strs`.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maLineHeight","comment":" The height in pixels of each line of text in a multi-line text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maOpacity","comment":" The opacity of a mark in the range 0 to 1.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maOrient","comment":" The orientation of an area mark. With a vertical orientation, an area mark is\ndefined by the x, y, and (y2 or height) properties; with a horizontal orientation,\nthe y, x and (x2 or width) properties must be specified instead.\nTo guarantee valid orientation type names, use [orientationValue](#orientationValue).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maOuterRadius","comment":" The outer radius in pixel units of an arc mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maPadAngle","comment":" The padding angle in radians clockwise from north for an arc mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maPath","comment":" The [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths)\ndescribing the geometry of a path mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maRadius","comment":" Polar coordinate radial offset in pixels, relative to the origin determined\nby the x and y properties of a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maScaleX","comment":" Amount by which to scale a path mark horizontally before applying any rotation.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maScaleY","comment":" Amount by which to scale a path mark vertically before applying any rotation.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maShape","comment":" A shape instance that provides a drawing method to invoke within the renderer.\nShape instances cannot be specified directly, instead they must be generated by\na data transform such as symbol generation or a geoshape:\n\n    shapeEncoding =\n        [ maShape [ symbolValue symSquare ]\n        , maStroke [ black ]\n        ]\n\n    lg =\n        legends\n            << legend\n                [ leFill \"cScale\"\n                , leOrient loBottomRight\n                , leEncode [ enSymbols [ enUpdate shapeEncoding ] ]\n                ]\n\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maSize","comment":" Area in pixels of the bounding box of point-based mark such as a symbol.\nNote that this value sets the area of the mark; the side lengths will increase with\nthe square root of this value.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maSmooth","comment":" Whether or not an image is smoothed when interpolating to its non-native size.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStartAngle","comment":" Start angle in radians clockwise from north for an arc mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStroke","comment":" Stroke color of a mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeCap","comment":" Stroke cap ending style for a mark. To guarantee valid stroke cap\nnames, use [strokeCapValue](#strokeCapValue).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeDash","comment":" Stroke dash style of a mark. The list should consist of alternating dash-gap\nlengths in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeDashOffset","comment":" A mark's offset of the first stroke dash in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeForeground","comment":" Whether or not a group stroke should be drawn on top of group content rather\nthan in the background.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeJoin","comment":" Stroke join method for a mark. To guarantee valid stroke join\nnames, use [strokeJoinValue](#strokeJoinValue).\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeMiterLimit","comment":" Miter limit at which to bevel a line join for a mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeOffset","comment":" Offset in pixels at which to draw a group stroke and fill.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeOpacity","comment":" Stroke opacity of a mark in the range 0 to 1.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maStrokeWidth","comment":" Stroke width of a mark in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maSymbol","comment":" A symbol shape that describes a symbol mark. For preset shapes, use\n[symbolValue](#symbolValue). For correct sizing of custom shape paths, define\ncoordinates within a square ranging from -1 to 1 along both the x and y dimensions.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maTension","comment":" The interpolation tension in the range 0 to 1 of a linear mark. Applies only\nto cardinal and catmull-rom interpolators.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maText","comment":" The text to display in a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maTheta","comment":" Polar coordinate angle in radians, relative to the origin determined by the\nx and y properties of a text mark.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maTooltip","comment":" The tooltip text to show upon mouse hover over a mark. This may be specified\ndirectly, via a field, a signal or any other text-generating value.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maUrl","comment":" The URL of an image file to be displayed as an image mark. This may be specified\ndirectly, via a field, a signal or any other text-generating value.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maWidth","comment":" The width of a mark in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maX","comment":" The primary x-coordinate of a mark in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maX2","comment":" The secondary x-coordinate of a mark in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maXC","comment":" The centre x-coordinate of a mark in pixels. This is an alternative to `maX`\nor `maX2`, not an addition.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maY","comment":" The primary y-coordinate of a mark in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maY2","comment":" The secondary y-coordinate of a mark in pixels.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maYC","comment":" The centre y-coordinate of a mark in pixels. This is an alternative to `maY`\nor `maY2`, not an addition.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"maZIndex","comment":" An integer z-index indicating the layering order of sibling mark items. The\ndefault value is 0. Higher values (1) will cause marks to be drawn on top of those\nwith lower z-index values. Setting the z-index as an encoding property only affects\nordering among sibling mark items; it will not change the layering relative to other\nmark definitions.\n","type":"List.List Vega.Value -> Vega.MarkProperty"},{"name":"mark","comment":" A mark definition. Marks form the visible components of a visualization.\nEach mark specification can include a list of mark properties (second parameter)\nthat customise the appearance of the mark and relate its appearance to data streams\nor signals.\n","type":"Vega.Mark -> List.List Vega.TopMarkProperty -> List.List Vega.Spec -> List.List Vega.Spec"},{"name":"markInterpolationValue","comment":" A convenience function for generating a value representing a given mark\ninterpolation type. Used instead of specifying an interpolation type\nas a literal string to avoid problems of mistyping the interpolation name.\n\n    signals\n        << signal \"interp\" [ siValue (markInterpolationValue miLinear) ]\n\n","type":"Vega.MarkInterpolation -> Vega.Value"},{"name":"marks","comment":" Create the marks used in the visualization. Multiple mark specifications are\ncommonly combined using the functional composition operator (`<<`). For example,\n\n      mk =\n          marks\n              << mark line\n                  [ mFrom [ srData (str \"myData\") ]\n                  , mEncode\n                      [ enEnter\n                          [ maX [ vScale \"xScale\", vField (field \"distance\") ]\n                          , maY [ vScale \"yScale\", vField (field \"energy\") ]\n                          , maStroke [ black ]\n                          ]\n                      ]\n                  ]\n              << mark symbol\n                  [ mFrom [ srData (str \"myData\") ]\n                  , mEncode\n                      [ enEnter\n                          [ maX [ vScale \"xScale\", vField (field \"distance\") ]\n                          , maY [ vScale \"yScale\", vField (field \"energy\") ]\n                          , maFill [ white ]\n                          , maStroke [ black ]\n                          ]\n                      ]\n                  ]\n\n","type":"List.List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"},{"name":"meCluster","comment":" A clustering tree layout method to be used in a tree transform.\n","type":"Vega.TreeMethod"},{"name":"meSignal","comment":" Tree layout method (`tidy` or `cluster`) referenced by the value in the named signal.\n","type":"String.String -> Vega.TreeMethod"},{"name":"meTidy","comment":" A tidy tree layout method to be used in a tree transform.\n","type":"Vega.TreeMethod"},{"name":"mercator","comment":" A Mercator map projection.\n","type":"Vega.Projection"},{"name":"miBasis","comment":" Cubic basis spline interpolation between points.\n","type":"Vega.MarkInterpolation"},{"name":"miBundle","comment":" Bundle curve interpolation between points.\n","type":"Vega.MarkInterpolation"},{"name":"miCardinal","comment":" Cubic cardinal spline interpolation between points.\n","type":"Vega.MarkInterpolation"},{"name":"miCatmullRom","comment":" Cubic Catmull-Rom spline interpolation between points.\n","type":"Vega.MarkInterpolation"},{"name":"miLinear","comment":" Linear (straight) interpolation between points.\n","type":"Vega.MarkInterpolation"},{"name":"miMonotone","comment":" Cubic spline interpolation that preserves monotonicity between points.\n","type":"Vega.MarkInterpolation"},{"name":"miNatural","comment":" Natural cubic spline interpolation between points.\n","type":"Vega.MarkInterpolation"},{"name":"miStepAfter","comment":" Piecewise (stepped) constant interpolation function after each point in a sequence.\n","type":"Vega.MarkInterpolation"},{"name":"miStepBefore","comment":" Piecewise (stepped) constant interpolation function before each point in a sequence.\n","type":"Vega.MarkInterpolation"},{"name":"miStepwise","comment":" Piecewise (stepped) constant interpolation function centred on each point in\na sequence.\n","type":"Vega.MarkInterpolation"},{"name":"millisecond","comment":" Indicate time unit is to specified as a millisecond of a second (0-999).\n","type":"Vega.TimeUnit"},{"name":"minute","comment":" Indicate time unit is to specified as a minute of the hour (0-59).\n","type":"Vega.TimeUnit"},{"name":"mixedcase","comment":" Leave text unchanged when pre-processing as part of a count pattern transformation.\n","type":"Vega.Case"},{"name":"mollweide","comment":" A mollweide global map projection.\n","type":"Vega.Projection"},{"name":"month","comment":" A month time unit.\n","type":"Vega.TimeUnit"},{"name":"naturalEarth1","comment":" A natural earth map projection.\n","type":"Vega.Projection"},{"name":"niDay","comment":" Nice time intervals that try to align with whole or rounded days.\n","type":"Vega.ScaleNice"},{"name":"niFalse","comment":" Disable nice scaling.\n","type":"Vega.ScaleNice"},{"name":"niHour","comment":" Nice time intervals that try to align with whole or rounded hours.\n","type":"Vega.ScaleNice"},{"name":"niInterval","comment":" 'Nice' temporal interval values when scaling.\n","type":"Vega.TimeUnit -> Basics.Int -> Vega.ScaleNice"},{"name":"niMillisecond","comment":" Nice time intervals that try to align with rounded milliseconds.\n","type":"Vega.ScaleNice"},{"name":"niMinute","comment":" Nice time intervals that try to align with whole or rounded minutes.\n","type":"Vega.ScaleNice"},{"name":"niMonth","comment":" Nice time intervals that try to align with whole or rounded months.\n","type":"Vega.ScaleNice"},{"name":"niSecond","comment":" Nice time intervals that try to align with whole or rounded seconds.\n","type":"Vega.ScaleNice"},{"name":"niSignal","comment":" 'nice' number-scaling type referenced by the value in the named signal.\n","type":"String.String -> Vega.ScaleNice"},{"name":"niTickCount","comment":" Desired number of tick marks in a 'nice' scaling.\n","type":"Basics.Int -> Vega.ScaleNice"},{"name":"niTrue","comment":" Enable nice scaling.\n","type":"Vega.ScaleNice"},{"name":"niWeek","comment":" Nice time intervals that try to align with whole or rounded weeks.\n","type":"Vega.ScaleNice"},{"name":"niYear","comment":" Nice time intervals that try to align with whole or rounded years.\n","type":"Vega.ScaleNice"},{"name":"num","comment":" A numeric literal.\n","type":"Basics.Float -> Vega.Num"},{"name":"numExpr","comment":" An expression that evaluates to a numeric value.\n","type":"Vega.Expr -> Vega.Num"},{"name":"numList","comment":" List of potentially mixed numeric types. Useful when a domain is\nspecified as being bounded by 0 and some signal:\n\n    scDomain (doNums (numList [ num 0, numSignal \"mySignal\" ]))\n\n","type":"List.List Vega.Num -> Vega.Num"},{"name":"numNull","comment":" An absence of a numeric value.\n","type":"Vega.Num"},{"name":"numSignal","comment":" Numeric value referenced by the value in the named signal.\n","type":"String.String -> Vega.Num"},{"name":"numSignals","comment":" List of numeric values referenced by the values in the named signals.\n","type":"List.List String.String -> Vega.Num"},{"name":"nums","comment":" A list of numeric literals. For lists that contain a mixture of numeric\nliterals and signals use [numList](#numList) instead.\n","type":"List.List Basics.Float -> Vega.Num"},{"name":"on","comment":" Add a list of triggers to the given data table.\n","type":"List.List Vega.Trigger -> Vega.DataTable -> Vega.DataTable"},{"name":"opArgMax","comment":" An input data object containing the maximum field value to be used in an\naggregation operation.\n","type":"Vega.Operation"},{"name":"opArgMin","comment":" An input data object containing the minimum field value to be used in an\naggregation operation.\n","type":"Vega.Operation"},{"name":"opCI0","comment":" Lower 95% confidence interval to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opCI1","comment":" Upper 95% confidence interval to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opCount","comment":" Total count of data objects to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opDistinct","comment":" Count of distinct data objects to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opMax","comment":" Maximum field value to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opMean","comment":" Mean value to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opMedian","comment":" Median field value to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opMin","comment":" Minimum field value to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opMissing","comment":" Count of null or undefined field value to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opProduct","comment":" Product of field values to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opQ1","comment":" Lower quartile boundary of field values to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opQ3","comment":" Upper quartile boundary of field values to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opSignal","comment":" Aggregation operation referenced by the value in the named signal.\n","type":"String.String -> Vega.Operation"},{"name":"opStderr","comment":" Standard error of field values to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opStdev","comment":" Sample standard deviation of field values to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opStdevP","comment":" Population standard deviation of field values to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opSum","comment":" Sum of field values to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opValid","comment":" Count of values that are not `null`, `undefined` or `NaN` to be used in an\naggregation operation.\n","type":"Vega.Operation"},{"name":"opVariance","comment":" Sample variance of field value to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"opVarianceP","comment":" Population variance of field value to be used in an aggregation operation.\n","type":"Vega.Operation"},{"name":"orHorizontal","comment":" Specify a horizontal orientation of a mark, legend or link path (e.g. horizontally or vertically\noriented bars).\n","type":"Vega.Orientation"},{"name":"orRadial","comment":" Specify a radial orientation of a mark or link path. Note that not all marks\ncan use a radial orientation.\n","type":"Vega.Orientation"},{"name":"orSignal","comment":" Orientation referenced by the value in the named signal.\n","type":"String.String -> Vega.Orientation"},{"name":"orVertical","comment":" Specify a vertical orientation of a mark, legend or link path (e.g. horizontally or vertically\noriented bars).\n","type":"Vega.Orientation"},{"name":"orderSignal","comment":" Sorting order referenced by the value in the named signal.\n","type":"String.String -> Vega.Order"},{"name":"orientationValue","comment":" A convenience function for generating a value representing a given mark\norientation type. Used instead of specifying an orientation type as\na literal string to avoid problems of mistyping its name.\n\n     maOrient [ orientationValue orHorizontal ]\n\n","type":"Vega.Orientation -> Vega.Value"},{"name":"orthographic","comment":" An orthographic map projection.\n","type":"Vega.Projection"},{"name":"osGreedy","comment":" Greedy overlap strategy to be applied when there is not space to show all items on an axis.\n","type":"Vega.OverlapStrategy"},{"name":"osNone","comment":" No overlap strategy to be applied when there is not space to show all items on an axis.\n","type":"Vega.OverlapStrategy"},{"name":"osParity","comment":" Give all items equal weight in overlap strategy to be applied when there is\nnot space to show them all on an axis.\n","type":"Vega.OverlapStrategy"},{"name":"osSignal","comment":" Overlap strategy referenced by the value in the named signal.\n","type":"String.String -> Vega.OverlapStrategy"},{"name":"paAs","comment":" The names to give the output fields of a packing transform. The default is\n[\"x\", \"y\", \"r\", \"depth\", \"children\"], where x and y are the layout coordinates,\nr is the node radius, depth is the tree depth, and children is the count of a\nnodeâs children in the tree.\n","type":"String.String -> String.String -> String.String -> String.String -> String.String -> Vega.PackProperty"},{"name":"paField","comment":" The data field corresponding to a numeric value for the node in a packing\ntransform. The sum of values for a node and all its descendants is available on\nthe node object as the value property. If radius is null, this field determines\nthe node size.\n","type":"Vega.Field -> Vega.PackProperty"},{"name":"paPadding","comment":" The approximate padding to include between packed circles.\n","type":"Vega.Num -> Vega.PackProperty"},{"name":"paRadius","comment":" Node radius to use in a packing transform. If `Nothing` (the\ndefault), the radius of each leaf circle is derived from the field value.\n","type":"Maybe.Maybe Vega.Field -> Vega.PackProperty"},{"name":"paSize","comment":" The size of a packing layout, provided as a two-element list in [width, height]\norder (or a signal that generates such a list).\n","type":"Vega.Num -> Vega.PackProperty"},{"name":"paSort","comment":" Packing transform sorting properties. The inputs to subject to sorting are\ntree node objects, not input data objects.\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.PackProperty"},{"name":"padding","comment":" Padding around the visualization in pixel units. The way padding is\ninterpreted will depend on the `autosize` properties.\n","type":"Basics.Float -> ( Vega.VProperty, Vega.Spec )"},{"name":"paddingSignal","comment":" Padding around the visualization in pixel units specified as a signal. The\nparameter is the name of a signal that can evluate either to a single number or\nan object with properties `left`, `top`, `right` and `bottom`.\n","type":"String.String -> ( Vega.VProperty, Vega.Spec )"},{"name":"paddings","comment":" Padding around the visualization in pixel units in _left_, _top_,\n_right_, _bottom_ order.\n","type":"Basics.Float -> Basics.Float -> Basics.Float -> Basics.Float -> ( Vega.VProperty, Vega.Spec )"},{"name":"parse","comment":" Data parsing rules as a list of tuples where each corresponds to a\nfield name paired with its desired data type. This is only necessary if there is\nsome ambiguity that could prevent correct type inference, such as time text:\n\n    dataSource\n        [ data \"timeData\"\n            [ daUrl (str \"data/timeSeries.json\")\n            , daFormat [ parse [ ( \"timestamp\", foDate \"%d/%m/%y %H:%M\" ) ] ]\n            ]\n        ]\n\n","type":"List.List ( String.String, Vega.DataType ) -> Vega.FormatProperty"},{"name":"parseAuto","comment":" Indicate automatic type inference on data types should be applied when parsing\na data source.\n","type":"Vega.FormatProperty"},{"name":"path","comment":" A path mark.\n","type":"Vega.Mark"},{"name":"piAs","comment":" Output fields for the computed start and end angles for each arc in a pie\ntransform.\n","type":"String.String -> String.String -> Vega.PieProperty"},{"name":"piEndAngle","comment":" End angle in radians in a pie chart transform. The default is 2 PI\nindicating the final slice ends 'north'.\n","type":"Vega.Num -> Vega.PieProperty"},{"name":"piField","comment":" The field to encode with angular spans in a pie chart transform.\n","type":"Vega.Field -> Vega.PieProperty"},{"name":"piGroupBy","comment":" Fields to group by when performing a pivot transform. If not specified,\na single group containing all data objects will be used.\n","type":"List.List Vega.Field -> Vega.PivotProperty"},{"name":"piLimit","comment":" Maximum number of fields to generate when performing a pivot transform\nor 0 for no limit.\n","type":"Vega.Num -> Vega.PivotProperty"},{"name":"piOp","comment":" Aggregation operation to use by when performing a pivot transform.\nIf not specified, fields will be aggregated by their sum.\n","type":"Vega.Operation -> Vega.PivotProperty"},{"name":"piSort","comment":" Indicate whether or not pie slices should be stored in angular size order.\n","type":"Vega.Boo -> Vega.PieProperty"},{"name":"piStartAngle","comment":" The starting angle in radians in a pie chart transform. The default is 0\nindicating that the first slice starts 'north'.\n","type":"Vega.Num -> Vega.PieProperty"},{"name":"prCenter","comment":" Map projectionâs centre as a two-element list of longitude and latitude\nin degrees.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prClipAngle","comment":" Map projectionâs clipping circle radius to the specified angle in degrees.\nA value of zero indicates antimeridian cutting should be applied rather than\nsmall-circle clipping.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prClipExtent","comment":" Map projectionâs viewport clip extent to the specified bounds in pixels.\nThe extent bounds should be specified as a list of four numbers in [x0, y0, x1, y1]\norder where x0 is the left-side of the viewport, y0 is the top, x1 is the right\nand y1 is the bottom.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prCoefficient","comment":" 'Hammer' map projection's coefficient (defaults to 2).\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prDistance","comment":" 'Satellite' map projection's distance value. Values are expressed as a\nproportion of the Earth's radius (defaults to 2).\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prExtent","comment":" Display region into which the projection should be automatically fit.\nUsed in conjunction with [prFit](#prFit). The region bounds should be specified\nin [x0, y0, x1, y1] order where x0 is the left-side, y0 is the top, x1 is the\nright and y1 is the bottom.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prFit","comment":" GeoJSON data to which a projection should attempt to automatically fit by setting\nits translate and scale values.\n\n    ds =\n        dataSource [ data \"mapData\" [ daUrl (str \"myGeoJson.json\") ] ]\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (feName \"mapData\")\n                ]\n\n","type":"Vega.Feature -> Vega.ProjectionProperty"},{"name":"prFraction","comment":" 'Bottomley' map projection's fraction parameter (defaults to 0.5).\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prLobes","comment":" Number of lobes in radial map projections such as the Berghaus Star.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prParallel","comment":" Parallel used for map projections such as the Armadillo (defaults\nto 20 degrees N).\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prPointRadius","comment":" Default radius (in pixels) to use when drawing projected GeoJSON\nPoint and MultiPoint geometries. The default value is 4.5.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prPrecision","comment":" Threshold for the projectionâs adaptive resampling in pixels. This\ncorresponds to the DouglasâPeucker distance. If precision is not specified, the\nprojectionâs current resampling precision which defaults to â0.5 â 0.70710 is used.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prRadius","comment":" Radius for the 'Gingery' map projection. Defaults to 30 degrees.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prRatio","comment":" 'Hill' map projection's ratio allowing it to vary continuously between\nMaurer 73 (0) and Eckert IV projections (infinity). Defaults to 1.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prReflectX","comment":" Whether or not to Reflect the x-coordinates when using an identity projection.\nThis creates a left-right mirror image of the geo features when subject to an\n[identityProjection](#identityProjection).\n","type":"Vega.Boo -> Vega.ProjectionProperty"},{"name":"prReflectY","comment":" Whether or not to Reflect the y-coordinates when using an identity projection.\nThis creates a top-bottom mirror image of the geo features when subject to an\n[identityProjection](#identityProjection).\n","type":"Vega.Boo -> Vega.ProjectionProperty"},{"name":"prRotate","comment":" Map projectionâs three-axis rotation angle. This should be a two- or\nthree-element list of numbers [lambda, phi, gamma] specifying the rotation angles\nin degrees about each spherical axis.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prScale","comment":" Map projectionâs scale factor. The default scale is projection-specific. It\ncorresponds linearly to the distance between projected points; however, scale\nfactor values are not equivalent across projections.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prSignal","comment":" Map projection referenced by the value in the named signal.\n","type":"String.String -> Vega.Projection"},{"name":"prSize","comment":" Width and height of the display region into which the projection should be\nautomatically fit. Used in conjunction with [prFit](#prFit) this is equivalent\nto calling [prExtent](#prExtent) with the top-left position set to (0,0). The region\nsize should be specified in [width, height] order (or a signal that generates such\na list).\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prSpacing","comment":" Spacing for a Lagrange conformal map projection (defaults to 0.5).\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prTilt","comment":" Tilt angle for a Satellite map projection (defaults to 0 degrees).\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prTranslate","comment":" Translation offset to the specified two-element list [tx, ty]. If\nnot specified as a two-element list, returns the current translation offset which\ndefaults to [480, 250]. The translation offset determines the pixel coordinates\nof the projectionâs centre. The default translation offset places (0Â°,0Â°) at the\ncentre of a 960Ã500 area.\n","type":"Vega.Num -> Vega.ProjectionProperty"},{"name":"prType","comment":" Type of map projection to use in a projection transformation.\n","type":"Vega.Projection -> Vega.ProjectionProperty"},{"name":"projection","comment":" Map projection for transforming geo data onto a plane.\n","type":"String.String -> List.List Vega.ProjectionProperty -> List.List Vega.Spec -> List.List Vega.Spec"},{"name":"projectionValue","comment":" Convenience function for generating a value representing a given projection\ntype. Useful when generating signals representing projection types.\n","type":"Vega.Projection -> Vega.Value"},{"name":"projections","comment":" Create the projections used to map geographic data onto a plane.\n\n    pr =\n        projections\n            << projection \"myProj\" [ prType orthographic ]\n            << projection \"myProj2\" [ prType albers, prRotate (nums [ -20, 15 ]) ]\n\n","type":"List.List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"},{"name":"ptAs","comment":" Output field names for the output of a partition layout transform.\nThe parameters correspond to the (default name) fields `x0`, `y0`, `x1`, `y1`,\n`depth` and `children`.\n","type":"String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> Vega.PartitionProperty"},{"name":"ptField","comment":" Data field corresponding to a numeric value for a partition node.\nThe sum of values for a node and all its descendants is available on the node object\nas the `value` property. This field determines the size of a node.\n","type":"Vega.Field -> Vega.PartitionProperty"},{"name":"ptPadding","comment":" Padding between adjacent nodes for a partition layout transform.\n","type":"Vega.Num -> Vega.PartitionProperty"},{"name":"ptRound","comment":" Whether or not node layout values should be rounded in a partition transform.\nThe default is false.\n","type":"Vega.Boo -> Vega.PartitionProperty"},{"name":"ptSize","comment":" Size of a partition layout as two-element list corresponding to\n[width, height] (or a signal that generates such a list).\n","type":"Vega.Num -> Vega.PartitionProperty"},{"name":"ptSort","comment":" Sorting properties of sibling nodes during a partition layout transform.\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.PartitionProperty"},{"name":"quAs","comment":" Name the output fields from a quantile transformation. The first parameter is\nthe name to give the quantile bin, the second the name of its associated value.\nDefault names are `prob` and `value`.\n","type":"String.String -> String.String -> Vega.QuantileProperty"},{"name":"quGroupBy","comment":" The data fields to group by when performing a quantile transformation. If not\nspecified, all data objects are used to create a single group.\n","type":"List.List Vega.Field -> Vega.QuantileProperty"},{"name":"quProbs","comment":" Quantile values to compute scaled as probabilties in the range (0, 1). For example,\n\n    quProbs [ 0.25, 0.5, 0.75 ]\n\nwill specify that quartiles are to be calculated.\n\nIf not provided the default step size of 0.01 or that specified via [quStep](#quStep)\nwill be used to provide the quantile probabilities.\n\n","type":"Vega.Num -> Vega.QuantileProperty"},{"name":"quStep","comment":" The probability step size to use when performing a quantile transformation.\nOnly used if [quProbs](#quProbs) is not specified. The default is 0.01.\n","type":"Vega.Num -> Vega.QuantileProperty"},{"name":"quarter","comment":" Indicate time unit is to specified as quarter (starting at one of January, April, July\nor October).\n","type":"Vega.TimeUnit"},{"name":"raCategory","comment":" Use default category range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"raCustomDefault","comment":" Custom range default scheme. Used when a new named default has been\ncreated as part of a config setting is required.\n","type":"String.String -> Vega.ScaleRange"},{"name":"raData","comment":" Scale range as a data reference object. This is used for specifying\nordinal scale ranges as a series of distinct field values.\n\n    scale \"myScale\"\n        [ scType scOrdinal\n        , scDomain (doData [ daDataset \"clusters\", daField (field \"id\") ])\n        , scRange (raData [ daDataset \"clusters\", daField (field \"name\") ])\n        ]\n\n","type":"List.List Vega.DataReference -> Vega.ScaleRange"},{"name":"raDiverging","comment":" Use default diverging range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"raHeatmap","comment":" Use default heatmap range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"raHeight","comment":" Use default height range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"raNums","comment":" Scale range as a list of numbers.\n","type":"List.List Basics.Float -> Vega.ScaleRange"},{"name":"raOrdinal","comment":" Use default ordinal range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"raRamp","comment":" Use default (continuous) ramp range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"raScheme","comment":" Scale range as a list of color schemes. The first parameter is\nthe name of the color scheme to use, the second any customising properties.\n","type":"Vega.Str -> List.List Vega.ColorSchemeProperty -> Vega.ScaleRange"},{"name":"raSignal","comment":" Default range scaling referenced by the value in the named signal.\n","type":"String.String -> Vega.ScaleRange"},{"name":"raStep","comment":" Step size for a band scale range.\n","type":"Vega.Value -> Vega.ScaleRange"},{"name":"raStrs","comment":" Scale range as a list of strings.\n","type":"List.List String.String -> Vega.ScaleRange"},{"name":"raSymbol","comment":" Use default (discrete) symbol range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"raValues","comment":" Scale range as a list of values.\n","type":"List.List Vega.Value -> Vega.ScaleRange"},{"name":"raWidth","comment":" Use default width range of scale output values.\n","type":"Vega.ScaleRange"},{"name":"reAs","comment":" Names of regression output fields representing the independent (predictor) and\ndependent (predicted) smoothed values. If not supplied, the names of the input\nindependent and dependent fields will be used.\n","type":"String.String -> String.String -> Vega.RegressionProperty"},{"name":"reExp","comment":" An exponential regression model (y = a + e^(bx)).\n","type":"Vega.RegressionMethod"},{"name":"reExtent","comment":" Start and end values of the regression line on the independent (predictor) axis\nexpressed as a two-element numeric list.\n","type":"Vega.Num -> Vega.RegressionProperty"},{"name":"reGroupBy","comment":" Group by a given set of fields when performing a regression transform. If not\nspecified, all data objects are used.\n","type":"List.List Vega.Field -> Vega.RegressionProperty"},{"name":"reIndependent","comment":" Indicate that multiple densities should be treated independently in a KDE transform.\n","type":"Vega.Resolution"},{"name":"reLinear","comment":" A linear regression model (y = a + bx).\n","type":"Vega.RegressionMethod"},{"name":"reLog","comment":" A log regression model (y = a + b.log(x)).\n","type":"Vega.RegressionMethod"},{"name":"reMethod","comment":" Type of regression model to use.\n","type":"Vega.RegressionMethod -> Vega.RegressionProperty"},{"name":"reMethodValue","comment":" Convenience function for generating a value representing a given regression\nmethod. Useful when generating signals representing method types.\n","type":"Vega.RegressionMethod -> Vega.Value"},{"name":"reOrder","comment":" The polynomial order for a [rePoly](#rePoly) regression model.\n","type":"Vega.Num -> Vega.RegressionProperty"},{"name":"reParams","comment":" Whether or not a regression transform should return the fit model parameters\n(one object per group), or the trend line points. If true, the resulting objects\ninclude a `coef` array of fitted coefficient values (starting with the intercept\nterm and then including terms of increasing order) and an `rSquared` value\n(indicating the total variance explained by the model).\n","type":"Vega.Boo -> Vega.RegressionProperty"},{"name":"rePoly","comment":" A polynomial regression model (y = a + bx + ... + kx^n). The order (n) of the\npolynomial can be set with [reOrder](#reOrder).\n","type":"Vega.RegressionMethod"},{"name":"rePow","comment":" A power regression model (y = ax^b).\n","type":"Vega.RegressionMethod"},{"name":"reQuad","comment":" A quadratic regression model (y = a + bx + cx^2).\n","type":"Vega.RegressionMethod"},{"name":"reShared","comment":" Indicate that multiple densities should be treated independently in a KDE or\nKDE2d transform.\n","type":"Vega.Resolution"},{"name":"reSignal","comment":" Regression model referenced by the value in the named signal.\n","type":"String.String -> Vega.RegressionMethod"},{"name":"rect","comment":" A rectangle mark.\n","type":"Vega.Mark"},{"name":"resolveSignal","comment":" Resolution type referenced by the value in the named signal.\n","type":"String.String -> Vega.Resolution"},{"name":"rgb","comment":" RGB color interpolation. The parameter is a gamma value to control the\nbrightness of the color trajectory.\n","type":"Basics.Float -> Vega.CInterpolate"},{"name":"rule","comment":" A rule (single line) mark.\n","type":"Vega.Mark"},{"name":"sbAny","comment":" Indicate that any DOM-signal bindings should be handled.\n","type":"Vega.SignalBind"},{"name":"sbContainer","comment":" Indicate that only DOM-signal bindings originating from the view container\nshould be handled.\n","type":"Vega.SignalBind"},{"name":"sbNone","comment":" Indicate that no DOM-signal bindings should be handled.\n","type":"Vega.SignalBind"},{"name":"scAlign","comment":" Alignment of elements within each step of a band scale, as a\nfraction of the step size. Should be in the range [0,1].\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scBand","comment":" A band scale.\n","type":"Vega.Scale"},{"name":"scBase","comment":" Base of the logorithm used in a logarithmic scale.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scBinOrdinal","comment":" An ordinal band scale.\n","type":"Vega.Scale"},{"name":"scBins","comment":" Specify the bins to be used when scaling into categories. For example the\nfollowing would specify a linear bin scaling between 100 and 160 in steps of 10.\n\n     scBins (bsBins (num 10) [ bsStart (num 100), bsStop (num 160) ])\n\n","type":"Vega.ScaleBins -> Vega.ScaleProperty"},{"name":"scClamp","comment":" Whether output values should be clamped when using a quantitative\nscale range (default false). If clamping is disabled and the scale is passed a\nvalue outside the domain, the scale may return a value outside the range through\nextrapolation. If clamping is enabled, the output value of the scale is always\nwithin the scaleâs range.\n","type":"Vega.Boo -> Vega.ScaleProperty"},{"name":"scConstant","comment":" The desired desired slope of the [scSymLog](#scSymLog) function at zero. If\nunspecified, the default is 1.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scCustom","comment":" Custom named scale.\n","type":"String.String -> Vega.Scale"},{"name":"scDomain","comment":" Domain of input data values for a scale.\n","type":"Vega.ScaleDomain -> Vega.ScaleProperty"},{"name":"scDomainImplicit","comment":" Whether or not ordinal domains should be implicitly extended with new\nvalues. If false, a scale will return `undefined` for values not included in the\ndomain; if true, new values will be appended to the domain and an updated range\nvalue will be returned.\n","type":"Vega.Boo -> Vega.ScaleProperty"},{"name":"scDomainMax","comment":" Maximum value of a scale domain, overriding a `scDomain` setting. Only intended\nfor scales with continuous domains.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scDomainMid","comment":" Insert a single mid-point value into a two-element scale domain. The mid-point\nvalue must lie between the domain minimum and maximum values. Useful for setting\na midpoint for diverging color scales. Only used with scales having continuous,\npiecewise domains.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scDomainMin","comment":" Minimum value of a scale domain, overriding a `scDomain` setting.\nThis is only used with scales having continuous domains.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scDomainRaw","comment":" List value that directly overrides the domain of a scale. Useful for\nsupporting interactions such as panning or zooming a scale. The scale may be\ninitially determined using a data-driven domain, then modified in response to user\ninput.\n\n    scales\n        << scale \"xDetail\"\n            [ scType scTime\n            , scRange raWidth\n            , scDomain (doData [ daDataset \"sp500\", daField (field \"date\") ])\n            , scDomainRaw (vSignal \"detailDomain\")\n            ]\n\n","type":"Vega.Value -> Vega.ScaleProperty"},{"name":"scExponent","comment":" Exponent to be used in power scale.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scInterpolate","comment":" Interpolation method for a quantitative scale.\n","type":"Vega.CInterpolate -> Vega.ScaleProperty"},{"name":"scLinear","comment":" A linear scale.\n","type":"Vega.Scale"},{"name":"scLog","comment":" A log scale.\n","type":"Vega.Scale"},{"name":"scNice","comment":" Extend the range of a scale domain so it starts and ends on 'nice' round\nvalues.\n","type":"Vega.ScaleNice -> Vega.ScaleProperty"},{"name":"scOrdinal","comment":" An ordinal scale.\n","type":"Vega.Scale"},{"name":"scPadding","comment":" Expand a scale domain to accommodate the specified number of pixels on each\nend of a quantitative scale range or the padding between bands in a band scale.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scPaddingInner","comment":" Expand a scale domain to accommodate the specified number of pixels\nbetween inner bands in a band scale.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scPaddingOuter","comment":" Expand a scale domain to accommodate the specified number of pixels\noutside the outer bands in a band scale.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scPoint","comment":" A point scale.\n","type":"Vega.Scale"},{"name":"scPow","comment":" A power scale.\n","type":"Vega.Scale"},{"name":"scQuantile","comment":" A quantile scale.\n","type":"Vega.Scale"},{"name":"scQuantize","comment":" A quantizing scale.\n","type":"Vega.Scale"},{"name":"scRange","comment":" Range of a scale representing the set of visual values.\n","type":"Vega.ScaleRange -> Vega.ScaleProperty"},{"name":"scRangeStep","comment":" Step size for band and point scales.\n","type":"Vega.Num -> Vega.ScaleProperty"},{"name":"scReverse","comment":" Reverse the order of a scale range.\n","type":"Vega.Boo -> Vega.ScaleProperty"},{"name":"scRound","comment":" Whether to round numeric output values to integers. Helpful for\nsnapping to the pixel grid.\n","type":"Vega.Boo -> Vega.ScaleProperty"},{"name":"scSequential","comment":" **Deprecated:** in favour of [scLinear](#scLinear).\n","type":"Vega.Scale"},{"name":"scSignal","comment":" Scaling referenced by the value in the named signal.\n","type":"String.String -> Vega.Scale"},{"name":"scSqrt","comment":" A square root scale.\n","type":"Vega.Scale"},{"name":"scSymLog","comment":" A [symmetrical log](https://www.researchgate.net/profile/John_Webber4/publication/233967063_A_bi-symmetric_log_transformation_for_wide-range_data/links/0fcfd50d791c85082e000000.pdf)\nscale. Similar to a log scale but supports zero and negative values. The slope of\nthe function at zero can be set with [scConstant](#scConstant).\n","type":"Vega.Scale"},{"name":"scThreshold","comment":" A threshold scale.\n","type":"Vega.Scale"},{"name":"scTime","comment":" A temporal scale.\n","type":"Vega.Scale"},{"name":"scType","comment":" Type of a named scale.\n","type":"Vega.Scale -> Vega.ScaleProperty"},{"name":"scUtc","comment":" A UTC temporal scale.\n","type":"Vega.Scale"},{"name":"scZero","comment":" Whether or not a scale domain should include zero. The default is\ntrue for linear, sqrt and power scales and false for all others.\n","type":"Vega.Boo -> Vega.ScaleProperty"},{"name":"scale","comment":" Scale to be used to map data values to visual properties.\n","type":"String.String -> List.List Vega.ScaleProperty -> List.List Vega.Spec -> List.List Vega.Spec"},{"name":"scales","comment":" Create the scales used to map data values to visual properties.\n\n    sc =\n        scales\n            << scale \"xScale\"\n                [ scType scLinear\n                , scDomain (doData [ daDataset \"myData\", daField (field \"x\") ])\n                , scRange raWidth\n                ]\n            << scale \"yScale\"\n                [ scType scLinear\n                , scDomain (doData [ daDataset \"myData\", daField (field \"y\") ])\n                , scRange raHeight\n                ]\n\n","type":"List.List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"},{"name":"second","comment":" Indicate time unit is to specified as a second of a minute (0-59).\n","type":"Vega.TimeUnit"},{"name":"shape","comment":" A shape mark.\n","type":"Vega.Mark"},{"name":"siBind","comment":" Bind a signal to an external input element such as a slider, selection list\nor radio button group.\n","type":"Vega.Bind -> Vega.SignalProperty"},{"name":"siBottom","comment":" Bottom side, used to specify an axis position.\n","type":"Vega.Side"},{"name":"siDescription","comment":" Text description of a signal, useful for inline documentation.\n","type":"String.String -> Vega.SignalProperty"},{"name":"siInit","comment":" Initialise a signal with an expression, which may include other signals.\nThis will occur only once, and cannot be used in parallel with `siUpdate`.\n","type":"String.String -> Vega.SignalProperty"},{"name":"siLeft","comment":" Left side, used to specify an axis position.\n","type":"Vega.Side"},{"name":"siName","comment":" A unique name to be given to a signal. Signal names should be contain only\nalphanumeric characters (or â$â, or â\\_â) and may not start with a digit. Reserved\nkeywords that may not be used as signal names are \"datum\", \"event\", \"item\", and\n\"parent\".\n","type":"String.String -> Vega.SignalProperty"},{"name":"siOn","comment":" Event stream handlers for updating a signal value in response to input events.\n","type":"List.List (List.List Vega.EventHandler) -> Vega.SignalProperty"},{"name":"siPushOuter","comment":" Make signal updates target a signal in an enclosing scope. Used when creating\nnested signals in a group mark.\n","type":"Vega.SignalProperty"},{"name":"siReact","comment":" Whether a signal update expression should be automatically re-evaluated\nwhen any upstream signal dependencies update. If false, the update expression will\nonly be run upon initialization.\n","type":"Vega.Boo -> Vega.SignalProperty"},{"name":"siRight","comment":" Right side, used to specify an axis position.\n","type":"Vega.Side"},{"name":"siSignal","comment":" Rectangular side referenced by the value in the named signal.\n","type":"String.String -> Vega.Side"},{"name":"siTop","comment":" Top side, used to specify an axis position.\n","type":"Vega.Side"},{"name":"siUpdate","comment":" Update expression for a signal which may include other signals, in which case\nthe signal will automatically update in response to upstream signal changes, so\nlong as its react property is not false. Cannot be used in parallel with `siInit`.\n","type":"String.String -> Vega.SignalProperty"},{"name":"siValue","comment":" Initial value of a signal. This value is assigned prior to the evaluation of\nany expressions specified via `siInit` or `siUpdate`.\n","type":"Vega.Value -> Vega.SignalProperty"},{"name":"signal","comment":" Signal to be used to add a dynamic component to a visualization.\n","type":"String.String -> List.List Vega.SignalProperty -> List.List Vega.Spec -> List.List Vega.Spec"},{"name":"signals","comment":" Create the signals used to add dynamism to the visualization.\n\n    si =\n        signals\n            << signal \"chartSize\" [ siValue (vNum 120) ]\n            << signal \"chartPad\" [ siValue (vNum 15) ]\n            << signal \"chartStep\" [ siUpdate \"chartSize + chartPad\" ]\n            << signal \"width\" [ siUpdate \"chartStep * 4\" ]\n\n","type":"List.List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"},{"name":"soAscending","comment":" Indicate sorting is to be applied from low to high.\n","type":"Vega.SortProperty"},{"name":"soByField","comment":" Field to be used when sorting.\n","type":"Vega.Str -> Vega.SortProperty"},{"name":"soDescending","comment":" Indicate sorting is to be applied from high to low.\n","type":"Vega.SortProperty"},{"name":"soOp","comment":" Sorting operation.\n","type":"Vega.Operation -> Vega.SortProperty"},{"name":"soSignal","comment":" Sorting type referenced by the value in the named signal.\n","type":"String.String -> Vega.SortProperty"},{"name":"spArchimedean","comment":" Archimedean spiralling for sequential positioning of words in a wordcloud.\n","type":"Vega.Spiral"},{"name":"spRectangular","comment":" Rectangular spiralling for sequential positioning of words in a wordcloud.\n","type":"Vega.Spiral"},{"name":"spSignal","comment":" Word cloud spiral type (`archimedean` or `rectangular`) referenced by the\nvalue in the named signal.\n","type":"String.String -> Vega.Spiral"},{"name":"srData","comment":" Name of the source for a set of marks.\n","type":"Vega.Str -> Vega.Source"},{"name":"srFacet","comment":" Create a facet directive for a set of marks. The first parameter is the name\nof the source dataset from which the facet partitions are to be generated. The\nsecond is the name to be given to the generated facet source. Marks defined with\nthe faceted `group` mark can reference this data source name to visualize the\nlocal data partition.\n\n    mark group\n        [ mFrom [ srFacet (str \"table\") \"facet\" [ faGroupBy [ field \"category\" ] ] ]\n        , mEncode [ enEnter [ maY [ vScale \"yScale\", vField (field \"category\") ] ] ]\n        , mGroup [ nestedMk [] ]\n        ]\n\n    nestedMk =\n        marks\n            << mark rect\n                [ mName \"bars\"\n                , mFrom [ srData (str \"facet\") ]\n                , mEncode\n                    [ enEnter\n                        [ maY [ vScale \"pos\", vField (field \"position\") ]\n                        , maHeight [ vScale \"pos\", vBand (num 1) ]\n                        , maX [ vScale \"xScale\", vField (field \"value\") ]\n                        , maX2 [ vScale \"xScale\", vBand (num 0) ]\n                        , maFill [ vScale \"cScale\", vField (field \"position\") ]\n                        ]\n                    ]\n                ]\n\n","type":"Vega.Str -> String.String -> List.List Vega.Facet -> Vega.Source"},{"name":"stAs","comment":" Names of the output fields for the computed start and end stack\nvalues of a stack transform.\n","type":"String.String -> String.String -> Vega.StackProperty"},{"name":"stCenter","comment":" Offset a stacked layout using a central stack baseline.\n","type":"Vega.StackOffset"},{"name":"stField","comment":" Field that determines the stack heights in a stack transform.\n","type":"Vega.Field -> Vega.StackProperty"},{"name":"stGroupBy","comment":" Grouping of fields with which to partition data into separate stacks\nin a stack transform.\n","type":"List.List Vega.Field -> Vega.StackProperty"},{"name":"stNormalize","comment":" Rescale a stacked layout to use a common height while preserving relative size\nof stacked quantities.\n","type":"Vega.StackOffset"},{"name":"stOffset","comment":" Baseline offset used in a stack transform.\n","type":"Vega.StackOffset -> Vega.StackProperty"},{"name":"stSignal","comment":" Stacking offset referenced by the value in the named signal.\n","type":"String.String -> Vega.StackOffset"},{"name":"stSort","comment":" Criteria for sorting values in a stack transform.\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.StackProperty"},{"name":"stZero","comment":" Offset a stacked layout using a baseline at the foot of a stack.\n","type":"Vega.StackOffset"},{"name":"stereographic","comment":" A stereographic map projection.\n","type":"Vega.Projection"},{"name":"str","comment":" A string literal.\n","type":"String.String -> Vega.Str"},{"name":"strExpr","comment":" Expression that when evaluated, is a string.\n","type":"Vega.Expr -> Vega.Str"},{"name":"strNull","comment":" An absence of a string value.\n","type":"Vega.Str"},{"name":"strSignal","comment":" String value referenced by the value in the named signal.\n","type":"String.String -> Vega.Str"},{"name":"strSignals","comment":" String values referenced by the values in the named signals.\n","type":"List.List String.String -> Vega.Str"},{"name":"strokeCapStr","comment":" Convenience function for generating a [Str](#Str) representing a given stroke cap type.\n","type":"Vega.StrokeCap -> Vega.Str"},{"name":"strokeCapValue","comment":" Convenience function for generating a value representing a given stroke cap type.\n","type":"Vega.StrokeCap -> Vega.Value"},{"name":"strokeJoinValue","comment":" Convenience function for generating a text string representing a given\nstroke join type. Used instead of specifying an stroke join type\nas a literal string to avoid problems of mistyping its name.\n","type":"Vega.StrokeJoin -> Vega.Value"},{"name":"strs","comment":" A list of string literals.\n","type":"List.List String.String -> Vega.Str"},{"name":"symArrow","comment":" Specify an arrow symbol for a shape mark. Useful when encoding symbol with a\ndirection.\n","type":"Vega.Symbol"},{"name":"symCircle","comment":" Specify a circular symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symCross","comment":" Specify a cross symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symDiamond","comment":" Specify a diamond symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symPath","comment":" A custom symbol shape as an\n[SVG path description](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n","type":"String.String -> Vega.Symbol"},{"name":"symSignal","comment":" Symbol type referenced by the value in the named signal.\n","type":"String.String -> Vega.Symbol"},{"name":"symSquare","comment":" Specify a square symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symStroke","comment":" Specify a stroke (line) symbol. Can be used, for example, to show legend\nsymbols as lines.\n","type":"Vega.Symbol"},{"name":"symTriangle","comment":" Specify a triangular symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symTriangleDown","comment":" Specify a downward triangular symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symTriangleLeft","comment":" Specify a left-pointing triangular symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symTriangleRight","comment":" Specify a right-pointing triangular symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symTriangleUp","comment":" Specify an upward triangular symbol for a shape mark.\n","type":"Vega.Symbol"},{"name":"symWedge","comment":" Specify a triangular wedge symbol for a shape mark. Useful when encoding\nsymbol with a direction.\n","type":"Vega.Symbol"},{"name":"symbol","comment":" A symbol mark.\n","type":"Vega.Mark"},{"name":"symbolValue","comment":" Convenience function for generating a value representing a given symbol type.\n","type":"Vega.Symbol -> Vega.Value"},{"name":"tbAs","comment":" Names to give the fields holding start and end boundaries for each temporal bin.\nIf not specified, these will be named `unit0` and `unit1`.\n","type":"String.String -> String.String -> Vega.TimeBinProperty"},{"name":"tbExtent","comment":" Minimum and maximum timestamps defining the full range of the time bins. Only\napplies if [tbUnits](#tbUnits) not specified.\n","type":"Vega.DateTime -> Vega.DateTime -> Vega.TimeBinProperty"},{"name":"tbInterval","comment":" Determines whether or not both the start and end unit values should be output.\nIf false, only the starting (floored) time unit value is written to the output.\n","type":"Vega.Boo -> Vega.TimeBinProperty"},{"name":"tbMaxBins","comment":" Maximum number of temporal bins to create (default 40). Applies only if\n[tbUnits](#tbUnits) is not specified.\n","type":"Vega.Num -> Vega.TimeBinProperty"},{"name":"tbSignal","comment":" Bind [trTimeUnit](#trTimeUnit) output to a signal with the given name. The\nbound signal has properies `unit` (smallest time unit), `units` (all time units),\n`step`, `start` and `stop` properties.\n","type":"String.String -> Vega.TimeBinProperty"},{"name":"tbStep","comment":" Number of steps between bins in terms of the smallest time unit provided to\n[tbUnits](#tbUnits) (ignored if not `tbUnits` not specified).\n","type":"Vega.Num -> Vega.TimeBinProperty"},{"name":"tbTimezone","comment":" Timezone to use when specifying dates and times.\n","type":"Vega.Timezone -> Vega.TimeBinProperty"},{"name":"tbUnits","comment":" Time units to determine the bins. If not specified, units will be inferred\nbased on the extent of values to be binned.\n","type":"List.List Vega.TimeUnit -> Vega.TimeBinProperty"},{"name":"tdLeftToRight","comment":" Left-to-right text render direction determining which end of a text string is\ntruncated if it cannot be displayed within a restricted space.\n","type":"Vega.TextDirection"},{"name":"tdRightToLeft","comment":" Right-to-left text render direction determining which end of a text string is\ntruncated if it cannot be displayed within a restricted space.\n","type":"Vega.TextDirection"},{"name":"tdSignal","comment":" Text direction (`ltr` or `rtl`) referenced by the value in the named signal.\n","type":"String.String -> Vega.TextDirection"},{"name":"teAs","comment":" Output field names within which to write the results of a tree\nlayout transform. The parameters represent the names to replace the defaults in\nthe following order: `x`, `y`, `depth` and `children`.\n","type":"String.String -> String.String -> String.String -> String.String -> Vega.TreeProperty"},{"name":"teField","comment":" Data corresponding to a numeric value to be associated with nodes\nin a tree transform.\n","type":"Vega.Field -> Vega.TreeProperty"},{"name":"teGroup","comment":" Indicates a title group (rectangular area containing title and optional subtitle).\n","type":"Vega.TitleElement"},{"name":"teMethod","comment":" Layout method used in a tree transform.\n","type":"Vega.TreeMethod -> Vega.TreeProperty"},{"name":"teNodeSize","comment":" Size of each node in a tree layout as a two-element [width,height]\nlist (or a signal that generates such a list).\n","type":"Vega.Num -> Vega.TreeProperty"},{"name":"teSeparation","comment":" Whether or not 'cousin' nodes should be placed further apart than 'sibling'\nnodes. If false, nodes will be uniformly separated as in a standard dendrogram.\n","type":"Vega.Boo -> Vega.TreeProperty"},{"name":"teSize","comment":" Size of of a tree layout as a two-element [width,height] list\n(or a signal that generates such a list).\n","type":"Vega.Num -> Vega.TreeProperty"},{"name":"teSort","comment":" Sorting properties of sibling nodes in a tree layout transform.\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.TreeProperty"},{"name":"teSubtitle","comment":" Indicates a subtitle text element within a title group.\n","type":"Vega.TitleElement"},{"name":"teTitle","comment":" Indicates a title text element within a title group.\n","type":"Vega.TitleElement"},{"name":"text","comment":" A text mark.\n","type":"Vega.Mark"},{"name":"textDirectionValue","comment":" Create a text direction value.\n","type":"Vega.TextDirection -> Vega.Value"},{"name":"tfBounds","comment":" Title anchor position calculation assuming text anchor is relative to the full\nbounding box.\n","type":"Vega.TitleFrame"},{"name":"tfGroup","comment":" Title anchor position calculation assuming text anchor is relative to the group\nwidth / height.\n","type":"Vega.TitleFrame"},{"name":"tfSignal","comment":" Title anchor calcuation type (`bounds` or `group`) referenced by the value in\nthe named signal.\n","type":"String.String -> Vega.TitleFrame"},{"name":"tgInsert","comment":" Expression that evaluates to data objects to insert as triggers. Insert\noperations are only applicable to datasets, not marks.\n","type":"String.String -> Vega.TriggerProperty"},{"name":"tgModifyValues","comment":" Data or mark modification trigger. The first parameter is an\nexpression that evaluates to data objects to modify and the second an expression\nthat evaluates to an object of name-value pairs, indicating the field values that\nshould be updated.\n\n    mark symbol\n        [ mFrom [ srData (str \"countries\") ]\n        , mOn\n            [ trigger \"myDragSignal\"\n                [ tgModifyValues \"dragged\" \"{fx: x(), fy: y()}\" ]\n            ]\n\nwould set the `fx` and `fy` properties on mark items referenced by `myDragSignal`\nto the current mouse pointer position.\n\n","type":"String.String -> String.String -> Vega.TriggerProperty"},{"name":"tgRemove","comment":" Expression that evaluates to data objects to remove. Remove operations are only\napplicable to datasets, not marks.\n","type":"String.String -> Vega.TriggerProperty"},{"name":"tgRemoveAll","comment":" Remove all data object triggers.\n","type":"Vega.TriggerProperty"},{"name":"tgToggle","comment":" Expression that evaluates to data objects to toggle. Toggled\nobjects are inserted or removed depending on whether they are already in the\ndataset. Applicable only to datasets, not marks.\n","type":"String.String -> Vega.TriggerProperty"},{"name":"tiAlign","comment":" Horizontal alignment of a title. If specified this will override\nthe [tiAnchor](#tiAnchor) setting (useful when aligning rotated title text).\n","type":"Vega.HAlign -> Vega.TitleProperty"},{"name":"tiAnchor","comment":" Anchor positioning of a title. Used for aligning title text.\n","type":"Vega.Anchor -> Vega.TitleProperty"},{"name":"tiAngle","comment":" Angle in degrees of a title.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiAria","comment":" Whether or not the title should be included as an\n[ARIA attribute](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)\nfor providing accessible SVG output associated with an axis.\n","type":"Vega.Boo -> Vega.TitleProperty"},{"name":"tiBaseline","comment":" Vertical title text baseline.\n","type":"Vega.VAlign -> Vega.TitleProperty"},{"name":"tiColor","comment":" Color of a title.\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiDx","comment":" Additional horizontal offset of a title's position.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiDy","comment":" Additional vertical offset of a title's position.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiEncode","comment":" Deprecated in favour of [tiEncodeElements](#tiEncodeElements).\n","type":"List.List Vega.EncodingProperty -> Vega.TitleProperty"},{"name":"tiEncodeElements","comment":" Specify the appearance of a title with a custom encoding. Should provide a list\nof tuples, each being the title element to encode (one of [teTitle](#teTitle),\n[teSubtitle](#teSubtitle) or [teGroup](#teGroup)) and the encodings to apply to it.\nThis can be useful when a part of a title needs more dynamic customization than that\noffered by simple title property functions ([tiColor](#tiColor), [tiFont](#tiFont) etc.).\nFor example,\n\n    enc =\n        [ enEnter [ maFill [ vStr \"firebrick\" ] ]\n        , enUpdate [ maFontStyle [ vStr \"normal\" ] ]\n        , enHover [ maFontStyle [ vStr \"italic\" ] ]\n        , enInteractive true\n        ]\n\n    tiEncodeElements [ ( teSubtitle, enc ) ]\n\n","type":"List.List ( Vega.TitleElement, List.List Vega.EncodingProperty ) -> Vega.TitleProperty"},{"name":"tiFont","comment":" Font name of a title.\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiFontSize","comment":" Font size of a title.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiFontStyle","comment":" Font style of a title such as `str \"normal\"` or `str \"italic\"`.\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiFontWeight","comment":" Font weight of a title (can be a number such as `vnum 300` or text\nsuch as `vStr \"bold\"`).\n","type":"Vega.Value -> Vega.TitleProperty"},{"name":"tiFrame","comment":" Reference frame for the anchor position of a title.\n","type":"Vega.TitleFrame -> Vega.TitleProperty"},{"name":"tiInteractive","comment":" Deprecated in favour of [tiEncodeElements](#tiEncodeElements).\n","type":"Vega.Boo -> Vega.TitleProperty"},{"name":"tiLimit","comment":" Maximim allowed length of a title in pixels.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiLineHeight","comment":" Line height in pixels of each line of text in a title.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiName","comment":" Deprecated in favour of [tiEncodeElements](#tiEncodeElements).\n","type":"String.String -> Vega.TitleProperty"},{"name":"tiOffset","comment":" Orthogonal offset in pixels by which to displace the title from\nits position along the edge of the chart.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiOrient","comment":" Position a title relative to the chart.\n","type":"Vega.Side -> Vega.TitleProperty"},{"name":"tiStyle","comment":" Deprecated in favour of [tiEncodeElements](#tiEncodeElements).\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiSubtitle","comment":" Subtitle text, placed beneath the primary title. For subtitles that span multiple\nlines, provide an array of strings ([strs](#strs)) rather than a single string ([str](#str)).\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiSubtitleColor","comment":" Color of a subtitle.\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiSubtitleFont","comment":" Font name of a subtitle.\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiSubtitleFontSize","comment":" Font size of a subtitle.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiSubtitleFontStyle","comment":" Font style of a subtitle such as `str \"normal\"` or `str \"italic\"`.\n","type":"Vega.Str -> Vega.TitleProperty"},{"name":"tiSubtitleFontWeight","comment":" Font weight of a subtitle (can be a number such as `vnum 300` or text\nsuch as `vStr \"bold\"`).\n","type":"Vega.Value -> Vega.TitleProperty"},{"name":"tiSubtitleLineHeight","comment":" Line height in pixels of each line of text in a subtitle.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiSubtitlePadding","comment":" Padding in pixels between title and subtitle text.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"tiZIndex","comment":" z-index indicating the layering of the title group relative to\nother axis, mark and legend groups.\n","type":"Vega.Num -> Vega.TitleProperty"},{"name":"title","comment":" Top-level title to be displayed as part of a visualization. The first parameter\nis the text of the title to display, the second any optional properties for customising\nthe title's appearance. For titles that span multiple lines, provide an array of\nstrings ([strs](#strs)) rather than a single string ([str](#str)).\n","type":"Vega.Str -> List.List Vega.TitleProperty -> ( Vega.VProperty, Vega.Spec )"},{"name":"tmAs","comment":" Output field names for the output of a treemap layout transform.\nThe parameters correspond to the (default name) fields `x0`, `y0`, `x1`, `y1`,\n`depth` and `children`.\n","type":"String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> Vega.TreemapProperty"},{"name":"tmBinary","comment":" A binary treemap layout method used in a treemap transform.\n","type":"Vega.TreemapMethod"},{"name":"tmDice","comment":" A dicing treemap layout method used in a treemap transform.\n","type":"Vega.TreemapMethod"},{"name":"tmField","comment":" Field corresponding to a numeric value for a treemap node.\nThe sum of values for a node and all its descendants is available on the node object\nas the `value` property. This field determines the size of a node.\n","type":"Vega.Field -> Vega.TreemapProperty"},{"name":"tmMethod","comment":" Layout method to use in a treemap transform.\n","type":"Vega.TreemapMethod -> Vega.TreemapProperty"},{"name":"tmPadding","comment":" Inner and outer padding values for a treemap layout transform.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmPaddingBottom","comment":" Padding between the bottom edge of a node and its children in a treemap\nlayout transform.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmPaddingInner","comment":" Inner padding values for a treemap layout transform.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmPaddingLeft","comment":" Padding between the left edge of a node and its children in a treemap\nlayout transform.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmPaddingOuter","comment":" Outer padding values for a treemap layout transform.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmPaddingRight","comment":" Padding between the right edge of a node and its children in a treemap\nlayout transform.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmPaddingTop","comment":" Padding between the top edge of a node and its children in a treemap\nlayout transform.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmRatio","comment":" Target aspect ratio for the [tmSquarify](#tmSquarify) or\n[tmResquarify](#tmResquarify) treemap layout trqnsformations. The default is the\ngolden ratio, Ï = (1 + sqrt(5)) / 2.\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmResquarify","comment":" A resquarifying treemap layout method used in a treemap transform.\n","type":"Vega.TreemapMethod"},{"name":"tmRound","comment":" Whether or not node layout values should be rounded in a treemap transform.\nThe default is false.\n","type":"Vega.Boo -> Vega.TreemapProperty"},{"name":"tmSignal","comment":" Treemap layout method referenced by the value in the named signal.\n","type":"String.String -> Vega.TreemapMethod"},{"name":"tmSize","comment":" Size of a treemap layout as two-element list (or signal) corresponding\nto [width, height].\n","type":"Vega.Num -> Vega.TreemapProperty"},{"name":"tmSlice","comment":" A slicing treemap layout method used in a treemap transform.\n","type":"Vega.TreemapMethod"},{"name":"tmSliceDice","comment":" A slice and dice treemap layout method used in a treemap transform.\n","type":"Vega.TreemapMethod"},{"name":"tmSort","comment":" Sorting properties of sibling nodes is in a treemap layout transform.\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.TreemapProperty"},{"name":"tmSquarify","comment":" A squarifying treemap layout method used in a treemap transform.\n","type":"Vega.TreemapMethod"},{"name":"toVega","comment":" Convert a list of Vega specifications into a single JSON object that may be\npassed to Vega for graphics generation. Recommended practice for top-level\nproperties that have more than a simple parameter is to create as a series of\ncompactly named functions (e.g. `ds` for the data source, `sc` for scales, `si`\nfor signals, `ax` for axes etc.) and construct a list of them. For example,\n\n    helloWorld : Spec\n    helloWorld =\n        let\n            table =\n                dataFromColumns \"table\" []\n                    << dataColumn \"label\" (vStrs [ \"Hello\", \"from\", \"elm-vega\" ])\n                    << dataColumn \"x\" (vNums [ 1, 2, 3 ])\n\n            ds =\n                dataSource [ table [] ]\n\n            sc =\n                scales\n                    << scale \"xScale\"\n                        [ scDomain (doData [ daDataset \"table\", daField (field \"x\") ])\n                        , scRange raWidth\n                        ]\n\n            mk =\n                marks\n                    << mark text\n                        [ mFrom [ srData (str \"table\") ]\n                        , mEncode\n                            [ enEnter\n                                [ maX [ vScale \"xScale\", vField (field \"x\") ]\n                                , maText [ vField (field \"label\") ]\n                                ]\n                            ]\n                        ]\n        in\n        toVega\n            [ width 100, ds, sc [], mk [] ]\n\n","type":"List.List ( Vega.VProperty, Vega.Spec ) -> Vega.Spec"},{"name":"topojsonFeature","comment":" TopoJSON feature format. The first parameter is the name of the feature object\nset to extract.\n","type":"Vega.Str -> Vega.FormatProperty"},{"name":"topojsonMesh","comment":" Create a single mesh instance from a named property in a topoJSON file. Unlike\n[topojsonFeature](#topojsonFeature), geo data are returned as a single unified\ninstance rather than individual GeoJSON features.\n","type":"Vega.Str -> Vega.FormatProperty"},{"name":"topojsonMeshExterior","comment":" Create a single mesh instance from a named property in a topoJSON file, storing\nthe exterior boundary only. Unlike [topojsonFeature](#topojsonFeature), geo data\nare returned as a single unified instance.\n","type":"Vega.Str -> Vega.FormatProperty"},{"name":"topojsonMeshInterior","comment":" Create a single mesh instance from a named property in a topoJSON file comprising\ninterior feature boundaries only. Unlike [topojsonFeature](#topojsonFeature),\ngeo data are returned as a single unified instance.\n","type":"Vega.Str -> Vega.FormatProperty"},{"name":"trAggregate","comment":" Ggroup and summarize an input data stream to produce a derived output stream.\nAggregate transforms can be used to compute counts, sums, averages and other\ndescriptive statistics over groups of data objects.\n","type":"List.List Vega.AggregateProperty -> Vega.Transform"},{"name":"trBin","comment":" Discretises numeric values into a set of bins. The first parameter is the\nfield to bin, the second a two-element numeric list representing the min/max\nextent of the bins. Optional binning properties can be provided in the final parameter.\nCommonly used to create frequency histograms by combining with [trAggregate](#trAggregate)\nto do the counting of field values in each bin.\n\n    transform\n        [ trBin (field \"examScore\") (nums [ 0, 100 ]) []\n        , trAggregate\n            [ agKey (field \"bin0\")\n            , agGroupBy [ field \"bin0\", field \"bin1\" ]\n            , agOps [ opCount ]\n            , agAs [ \"count\" ]\n            ]\n        ]\n\n","type":"Vega.Field -> Vega.Num -> List.List Vega.BinProperty -> Vega.Transform"},{"name":"trCollect","comment":" Collect all the objects in a data stream within a single list, allowing\nsorting by data field values.\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.Transform"},{"name":"trContour","comment":" **Deprecated in favour of the more flexible [trIsocontour](#trIsocontour).**\n\nGenerate a set of contour (iso) lines at a set of discrete levels. Commonly used\nto visualize density estimates for 2D point data.\n\nThe first two parameters are the width and height over which to compute the contours.\nThe third a list of optional contour properties. The transform generates a new\nstream of GeoJSON data as output which may be visualized using either the\n`trGeoShape` or `trGeoPath` transforms.\n\n","type":"Vega.Num -> Vega.Num -> List.List Vega.ContourProperty -> Vega.Transform"},{"name":"trCountPattern","comment":" Count the number of occurrences of a text pattern, as defined by a regular\nexpression. This transform will iterate through each data object and count all\nunique pattern matches found within the designated text field.\n\nThe first parameter is the field containing the text to count, the second a list\nof optional counting properties. The transform generates two fields named `text`\nand `count` unless renamed via `cpAs`.\n\n","type":"Vega.Field -> List.List Vega.CountPatternProperty -> Vega.Transform"},{"name":"trCross","comment":" Compute the cross-product of a data stream with itself.\n","type":"List.List Vega.CrossProperty -> Vega.Transform"},{"name":"trCrossFilter","comment":" Maintain a filter mask for multiple dimensional queries, using a set of\nsorted indices. The parameter is a list of (field,range) pairs indicating which\nfields to filter and the numeric range of values in the form of a `num` that\nshould resolve to a [min (inclusive), max (exclusive)] pair.\n","type":"List.List ( Vega.Field, Vega.Num ) -> Vega.Transform"},{"name":"trCrossFilterAsSignal","comment":" Perform a crossfilter transform. This version can be used with\n[trResolvefilter](#trResolveFilter) to enable fast interactive querying over large\ndatasets. The final parameter is the name of a new signal with which to bind the\nresults of the filter (which can then be referenced by [trResolveFilter](#trResolveFilter)).\n","type":"List.List ( Vega.Field, Vega.Num ) -> String.String -> Vega.Transform"},{"name":"trDensity","comment":" Compute a new data stream of uniformly-spaced samples drawn from a one-dimensional\nprobability density function (pdf) or cumulative distribution function (cdf).\nUseful for representing probability distributions and generating continuous\ndistributions from discrete samples through kernel density estimation.\n","type":"Vega.Distribution -> List.List Vega.DensityProperty -> Vega.Transform"},{"name":"trDotBin","comment":" Calculates bin positions for stacking dots in a [dot plot](#https://en.wikipedia.org/wiki/Dot_plot_%28statistics%29).\nThe first parameter is the filed to bin, the second a list of binning options. To\nstack the computed dot positions combine with [trStack](#trStack).\n","type":"Vega.Field -> List.List Vega.DotBinProperty -> Vega.Transform"},{"name":"trExtent","comment":" Compute the minimum and maximum values for a data field, producing a two-element\n[min, max] list.\n","type":"Vega.Field -> Vega.Transform"},{"name":"trExtentAsSignal","comment":" Compute the minimum and maximum values for a given data field and bind it to a\nsignal with the given name.\n","type":"Vega.Field -> String.String -> Vega.Transform"},{"name":"trFilter","comment":" Remove objects from a data stream based on the given filter expression.\n","type":"Vega.Expr -> Vega.Transform"},{"name":"trFlatten","comment":" Map list-valued fields to a set of individual data objects, one per list entry.\nThis version generates the output fields with names corresponding to the list field used.\n","type":"List.List Vega.Field -> Vega.Transform"},{"name":"trFlattenAs","comment":" Similar to [trFlatten](#trFlatten) but allowing the output fields to be named.\n","type":"List.List Vega.Field -> List.List String.String -> Vega.Transform"},{"name":"trFlattenWithIndex","comment":" Similar to [trFlatten](#trFlatten) except an addtional field with the name\ngiven by the first parameter is output containing zero-index of the original unflattened\ndata item. See the [Vega documentation](https://vega.github.io/vega/docs/transforms/flatten/)\nfor an example.\n","type":"String.String -> List.List Vega.Field -> Vega.Transform"},{"name":"trFlattenWithIndexAs","comment":" Similar to [trFlattenWithIndex](#trFlattenWithIndex) but allowing the output\nfields to be named.\n","type":"String.String -> List.List Vega.Field -> List.List String.String -> Vega.Transform"},{"name":"trFold","comment":" Perform a _gather_ operation to _tidy_ a table. Collapse multiple data fields\ninto two new data fields: `key` containing the original data field names and `value`\ncontaining the corresponding data values. This performs the same function as the\n[gather operation in R](https://tidyr.tidyverse.org/reference/gather.html) and in the\n[Tidy Elm package](https://package.elm-lang.org/packages/gicentre/tidy/latest/Tidy#gather).\n","type":"List.List Vega.Field -> Vega.Transform"},{"name":"trFoldAs","comment":" Similar to [trFold](#trFold) but allows the new output `key` and `value` fields\nto be given alternative names (second and third parameters respectively).\n","type":"List.List Vega.Field -> String.String -> String.String -> Vega.Transform"},{"name":"trForce","comment":" Compute a force-directed layout. This layout transformation uses a model in\nwhich data objects act as charged particles (or nodes), optionally connected by\na set of edges (or links). A set of forces is used to drive a physics simulation\nthat determines the node positions.\n","type":"List.List Vega.ForceSimulationProperty -> Vega.Transform"},{"name":"trFormula","comment":" Extend a data object with new values according to the given\n[Vega expression](https://vega.github.io/vega/docs/expressions/). The second\nparameter is a new field name to give the result of the evaluated expression.\nThis version will reapply the formula if the data changes. To perform a one-off\nformula calculation use [trFormulaInitOnly](#trFormulaInitOnly).\n\n    dataSource\n        [ data \"world\"\n            [ daUrl (str \"https://vega.github.io/vega/data/world-110m.json\")\n            , daFormat [ topojsonFeature \"countries\" ]\n            ]\n            |> transform\n                [ trFormula \"geoCentroid('myProj', datum)\" \"myCentroid\" ]\n        ]\n\n","type":"String.String -> String.String -> Vega.Transform"},{"name":"trFormulaInitOnly","comment":" Similar to [trFormula](#trFormula) but will apply the formula only once even\nif the data changes.\n","type":"String.String -> String.String -> Vega.Transform"},{"name":"trGeoJson","comment":" Consolidate geographic data into a single feature collection. This can be\ncaptured as a signal that will represent the consolidated feature collection. If\nan empty list is provided as the parameter, the data are not projected (identity projection).\n","type":"List.List Vega.GeoJsonProperty -> Vega.Transform"},{"name":"trGeoPath","comment":" Map GeoJSON features to SVG path strings. The first parameter can be the name\nof a projection to apply to the mapping, or an empty string if no map projection.\nSimilar to the [trGeoShape](#trGeoShape) but immediately generates SVG path strings.\n","type":"String.String -> List.List Vega.GeoPathProperty -> Vega.Transform"},{"name":"trGeoPoint","comment":" Project a longitude, latitude pair to (x,y) coordinates according to the given\nmap projection. The first parameter is the name of the map projection to use, the\nsecond and third the fields containing the longitude and latitude values respectively.\nThis version generates two new fields with the name `x` and `y` holding the\nprojected coordinates.\n","type":"String.String -> Vega.Field -> Vega.Field -> Vega.Transform"},{"name":"trGeoPointAs","comment":" Similar to [trGeoPoint](#trGeoPoint) but allowing the projected coordinates\nto be named (last two parameters).\n","type":"String.String -> Vega.Field -> Vega.Field -> String.String -> String.String -> Vega.Transform"},{"name":"trGeoShape","comment":" Generate a renderer instance that maps GeoJSON features to a shape instance\nfor use with the shape mark. Similar to the [trGeoPath](#trGeoPath), but rather than\ngenerate intermediate SVG path strings, this transform produces a shape instance\nthat directly generates drawing commands during rendering resulting in improved\nperformance when using canvas rendering for dynamic maps.\n","type":"String.String -> List.List Vega.GeoPathProperty -> Vega.Transform"},{"name":"trGraticule","comment":" Generate a reference grid of meridians (longitude) and parallels (latitude)\nfor cartographic maps. The default graticule has meridians and parallels every\n10Â° between Â±80Â° latitude; for the polar regions meridians are every 90Â°.\n\nIt generates a new data stream containing a single GeoJSON data object\nfor the graticule, which can subsequently be drawn using the geopath or geoshape\ntransform.\n\n","type":"List.List Vega.GraticuleProperty -> Vega.Transform"},{"name":"trHeatmap","comment":" Generate a raster image from a raster grid that can be rendered with an\n[image](#image) mark.\n","type":"List.List Vega.HeatmapProperty -> Vega.Transform"},{"name":"trIdentifier","comment":" Extend a data object with a globally unique key value. Identifier values are\nassigned using an internal counter. This counter is shared across all instances\nof this transform within a single Vega view, including different data sources,\nbut not across different Vega views.\n","type":"String.String -> Vega.Transform"},{"name":"trImpute","comment":" Generate new values for missing data. The first parameter is the data field\nfor which missing values should be imputed. The second is a key field that uniquely\nidentifies the data objects within a group and so allows missing values to be\nidentified. The third is a list of optional properties for customising the imputation.\n","type":"Vega.Field -> Vega.Field -> List.List Vega.ImputeProperty -> Vega.Transform"},{"name":"trIsocontour","comment":" Generate geoJSON representing contours threaded through a given raster surface.\nSee the [Vega Isocontour documentation](https://vega.github.io/vega/docs/transforms/isocontour/)\nfor details.\n","type":"List.List Vega.IsocontourProperty -> Vega.Transform"},{"name":"trJoinAggregate","comment":" Group and summarize an input data stream in a similar way to [trAggregate](#trAggregate)\nbut which is then joined back to the input stream. Helpful for creating derived\nvalues that combine both raw data and aggregate calculations, such as percentages\nof group totals.\n","type":"List.List Vega.JoinAggregateProperty -> Vega.Transform"},{"name":"trKde","comment":" Perform a one-dimensional kernel density estimation over an input data stream\nand generate uniformly spaced samples of the estimated densities. Unlike [trDensity](#trDensity),\nthis supports the abilty to group by a set of fields and the scaling of densities\nas probabilities or smoothed counts.\n","type":"Vega.Field -> List.List Vega.KdeProperty -> Vega.Transform"},{"name":"trKde2d","comment":" Perform a two-dimensional kernel density estimation over an input data stream\nand generates one or more raster grids of density estimates. The first two parameters\nare the width and height over which to perform the estimation. The next two parameters\nare the x and y fields holding the 2d data over which to perform the KDE.\n","type":"Vega.Num -> Vega.Num -> Vega.Field -> Vega.Field -> List.List Vega.Kde2Property -> Vega.Transform"},{"name":"trLinkPath","comment":" Route a visual link between two nodes to draw edges in a tree or network layout.\nWrites one property to each datum, providing an SVG path string for the link path.\n","type":"List.List Vega.LinkPathProperty -> Vega.Transform"},{"name":"trLoess","comment":" Create a trend line via [locally estimated regression](https://en.wikipedia.org/wiki/Local_regression).\nThis creates the smoothed line via a moving window in contrast to the parametric\nregression lines generated via [trRegression](#trRegression). The first two parameters\nare the names of the independent (predictor) and dependent (predicted) fields respectively.\nThe third is a list of optional customisation functions.\n","type":"Vega.Field -> Vega.Field -> List.List Vega.LoessProperty -> Vega.Transform"},{"name":"trLookup","comment":" Extend a primary data stream by looking up values on a secondary data stream.\nThe first parameter is the name of the secondary data stream upon which to perform\nthe lookup. The second is the key field in that secondary stream. The third is the\nset of key fields from the primary data stream, each of which are then searched\nfor in a single key field of the secondary data stream. Optional customisation\nprovided as a list of properties in the final parameter.\n","type":"String.String -> Vega.Field -> List.List Vega.Field -> List.List Vega.LookupProperty -> Vega.Transform"},{"name":"trNest","comment":" Generate a tree data structure from input data objects by dividing children\ninto groups based on distinct field values. This can provide input to tree layout\nmethods such as [trTree](#trTree), [trTreemap](#trTreemap), [trPack](#trPack) and\n[trPartition](#trPartition).\n","type":"List.List Vega.Field -> Vega.Boo -> Vega.Transform"},{"name":"trPack","comment":" Compute an enclosure diagram that uses containment (nesting) to represent a\nhierarchy. The size of the leaf circles encodes a quantitative dimension of the\ndata. The enclosing circles show the approximate cumulative size of each subtree,\nbut due to wasted space there is some distortion; only the leaf nodes can be\ncompared accurately.\n","type":"List.List Vega.PackProperty -> Vega.Transform"},{"name":"trPartition","comment":" Compute the layout for an adjacency diagram: a space-filling variant of a node-link\ntree diagram. Nodes are drawn as solid areas (either arcs or rectangles) sized by\nsome quantitative field, and their placement relative to other nodes reveals their\nposition in the hierarchy.\n","type":"List.List Vega.PartitionProperty -> Vega.Transform"},{"name":"trPie","comment":" Calculates the angular extents of arc segments laid out in a circle, for example\nto create a pie chart. Writes two properties to each datum, indicating the starting\nand ending angles (in radians) of an arc.\n","type":"List.List Vega.PieProperty -> Vega.Transform"},{"name":"trPivot","comment":" Map unique values from a field to new aggregated fields in the output stream.\nThe first parameter is the field to pivot on (providing new field names). The second\nis the field containing values to aggregate to populate new values. The third allows\nthe transform to be customised.\n","type":"Vega.Field -> Vega.Field -> List.List Vega.PivotProperty -> Vega.Transform"},{"name":"trProject","comment":" Perform a relational algebra projection transform resulting in a new stream\nof derived data objects that include one or more fields from the input stream.\nThe parameter is a list of field-name pairs where the fields are those fields to\nbe copied over in the projection and the names are the new names to give the\nprojected fields.\n","type":"List.List ( Vega.Field, String.String ) -> Vega.Transform"},{"name":"trQuantile","comment":" Calculate quantile values from an input data stream. Useful for examining\ndistributional properties of a data stream and for creating\n[Q-Q plots](https://en.wikipedia.org/wiki/QâQ_plot).\n","type":"Vega.Field -> List.List Vega.QuantileProperty -> Vega.Transform"},{"name":"trRegression","comment":" Create a two-dimensional regression model. The first two parameters\nare the names of the independent (predictor) and dependent (predicted) fields respectively.\nThe third is a list of optional customisation functions. See the\n[Vega regression documentation](https://vega.github.io/vega/docs/transforms/regression/)\n","type":"Vega.Field -> Vega.Field -> List.List Vega.RegressionProperty -> Vega.Transform"},{"name":"trResolveFilter","comment":" Use a filter mask generated by a crossfilter transform to generate filtered\ndata streams efficiently. The first parameter is the signal created by\n[trCrossFilterAsSignal](#trCrossFilterAsSignal) and the second a bit mask indicating\nwhich fields in the crossfilter should be ignored. Each bit corresponds to a field\nand query in the crossfilter transformâs fields and query lists. If the corresponding\nbit is on, that field and query will be ignored when resolving the filter. All other\nqueries must pass the filter for a tuple to be included downstream.\n","type":"String.String -> Vega.Num -> Vega.Transform"},{"name":"trSample","comment":" Generate a random sample from a data stream to generate a smaller stream. The\nparameter determines the maximum number of data items to sample.\n","type":"Vega.Num -> Vega.Transform"},{"name":"trSequence","comment":" Generate a data stream of numbers between a start (first parameter) and end\n(second parameter) inclusive in increments specified by the third parameter. If\nthe end value is less than the start value, the third parameter should be negative.\nThe resulting output field will be called `data`.\n\nSequences can be used to feed other transforms to generate data to create random\n(x,y) coordinates:\n\n    dataSource\n        [ data \"randomData\" []\n            |> transform\n                [ trSequence (num 1) (num 1000) (num 1)\n                , trFormula \"random()\" \"x\"\n                , trFormula \"random()\" \"y\"\n                ]\n        ]\n\n","type":"Vega.Num -> Vega.Num -> Vega.Num -> Vega.Transform"},{"name":"trSequenceAs","comment":" Similar to [trSequence](#trSequence) but allowing the resulting sequence to\nbe named (fourth parameter).\n","type":"Vega.Num -> Vega.Num -> Vega.Num -> String.String -> Vega.Transform"},{"name":"trStack","comment":" Compute a layout by stacking groups of values. The most common use case is to\ncreate stacked graphs, including stacked bar charts and stream graphs. This\ntransform writes two properties to each datum, indicating the starting and ending\nstack values.\n","type":"List.List Vega.StackProperty -> Vega.Transform"},{"name":"trStratify","comment":" Generate a hierarchical (tree) data structure from input data objects, based\non key fields that match an id for each node (first parameter) and their parent's\nkey (second parameter) nodes. Internally, this transform generates a set of tree\nnode objects that can then be transformed with tree layout functions such as\n[trTree](#trTree), [trTreemap](#trTreemap), [trPack](#trPack), and\n[trPartition](#trPartition).\n","type":"Vega.Field -> Vega.Field -> Vega.Transform"},{"name":"trTimeUnit","comment":" Bin a temporal field into discrete time units. For example, to aggregate points\nin time into weekly groups. The first parameter is the field to bin, the second a\nlist of optional temporal binning properties. The result will be two new fields\n`unit0` and `unit1` that contain the lower and upper boundaries of each temporal bin.\n","type":"Vega.Field -> List.List Vega.TimeBinProperty -> Vega.Transform"},{"name":"trTree","comment":" Compute a node-link diagram layout for hierarchical data. Supports both cluster\nlayouts (for example, to create dendrograms) and tidy layouts.\n","type":"List.List Vega.TreeProperty -> Vega.Transform"},{"name":"trTreeLinks","comment":" Generate a new stream of data objects representing links between nodes in a\ntree. This transform must occur downstream of a tree-generating transform such as\n[trNest](#trNest) or [trStratify](#trStratify). The generated link objects will\nhave `source` and `target` fields that reference input data objects corresponding\nto parent (source) and child (target) nodes.\n","type":"Vega.Transform"},{"name":"trTreemap","comment":" Recursively subdivide an area into rectangles with areas proportional to each\nnodeâs associated value.\n","type":"List.List Vega.TreemapProperty -> Vega.Transform"},{"name":"trVoronoi","comment":" Compute a voronoi diagram for a set of input points and return the computed\ncell paths.\n","type":"Vega.Field -> Vega.Field -> List.List Vega.VoronoiProperty -> Vega.Transform"},{"name":"trWindow","comment":" Performs calculations such as ranking, lead/lag analysis and running sums over\nsorted groups of data objects . Calculated values are written back to the input\ndata stream.\n\n    transform\n        [ trWindow [ wnOperation woRowNumber \"rank\" ]\n            [ wnSort [ ( field \"myField\", descend ) ] ]\n        ]\n\n","type":"List.List Vega.WindowOperation -> List.List Vega.WindowProperty -> Vega.Transform"},{"name":"trWordcloud","comment":" Compute a word cloud layour similar to a 'wordle'. Useful for visualising the\nrelative frequency of words or phrases.\n\n    mark text\n        [ mTransform\n            [ trWordcloud\n                [ wcSize (nums [ 800, 400 ])\n                , wcText (field \"text\")\n                , wcRotate (numExpr (exField \"datum.angle\"))\n                , wcFontSize (numExpr (exField \"datum.count\"))\n                , wcFontWeight (strExpr (exField \"datum.weight\"))\n                , wcFontSizeRange (nums [ 12, 56 ])\n                ]\n            ]\n        ]\n\n","type":"List.List Vega.WordcloudProperty -> Vega.Transform"},{"name":"trail","comment":" A trail mark (line with variable width).\n","type":"Vega.Mark"},{"name":"transform","comment":" Apply the given ordered list of transforms to the given data stream. Transform\nexamples include filtering, creating new data fields from expressions and creating\nnew data fields suitable for a range of visualization and layout types.\n","type":"List.List Vega.Transform -> Vega.DataTable -> Vega.DataTable"},{"name":"transparent","comment":" Convenience function for specifying a transparent setting for marks that can\nbe colored (e.g. with [maFill](#maFill))\n","type":"Vega.Value"},{"name":"transverseMercator","comment":" A transverse Mercator map projection.\n","type":"Vega.Projection"},{"name":"trigger","comment":" Creates a trigger that may be applied to a data table or mark.\nThe first parameter is the name of the trigger and the second\na list of trigger actions.\n","type":"String.String -> List.List Vega.TriggerProperty -> Vega.Trigger"},{"name":"true","comment":" A Boolean true value.\n","type":"Vega.Boo"},{"name":"tsv","comment":" Indicate a TSV (tab-separated) format when parsing a data source.\n","type":"Vega.FormatProperty"},{"name":"tuSignal","comment":" Time unit referenced by the value in the named signal.\n","type":"String.String -> Vega.TimeUnit"},{"name":"tzLocal","comment":" Indicates a local timezone (as opposed to UTC).\n","type":"Vega.Timezone"},{"name":"tzSignal","comment":" Indicates timezone to be set via the named signal.\n","type":"String.String -> Vega.Timezone"},{"name":"tzUtc","comment":" Indicates a UTC timezone (as opposed to using local timezone).\n","type":"Vega.Timezone"},{"name":"uppercase","comment":" Make text uppercase when pre-processing as part of a count pattern transformation.\n","type":"Vega.Case"},{"name":"userMeta","comment":" Provide a metadata description to be associated with the specification. The\nargument should be a list of the desired metadata keys and values. For example,\n\n    userMeta\n        [ ( \"Org\", vStr \"giCentre\" )\n        , ( \"Date\", vStr \"2019-10-29\" )\n        , ( \"Version\", vNum 3.2 )\n        ]\n\n","type":"List.List ( String.String, Vega.Value ) -> ( Vega.VProperty, Vega.Spec )"},{"name":"vAlphabetic","comment":" Convenience function for indicating an alphabetic vertical alignment.\n","type":"Vega.Value"},{"name":"vBand","comment":" Band number or fraction of a band number. Band scales are used when\naggregating data into discrete categories such as in a frequency histogram.\n","type":"Vega.Num -> Vega.Value"},{"name":"vBoos","comment":" A list of Boolean values.\n","type":"List.List Basics.Bool -> Vega.Value"},{"name":"vBottom","comment":" Convenience function for indicating a bottom vertical alignment.\n","type":"Vega.Value"},{"name":"vColor","comment":" A color value.\n","type":"Vega.ColorValue -> Vega.Value"},{"name":"vExponent","comment":" An exponential value modifier.\n","type":"Vega.Value -> Vega.Value"},{"name":"vFalse","comment":" A 'false' value.\n","type":"Vega.Value"},{"name":"vField","comment":" A data or signal field.\n","type":"Vega.Field -> Vega.Value"},{"name":"vGradient","comment":" A literal color gradient value. The first parameter indicates whether the scale\nshould be linear or radial. The second is a set of customisation options for the\ncolors, positioning and rate of change of the gradient. For example, to set a radial\nred-blue color gradient as a fill for a mark:\n\n    maFill\n        [ vGradient grRadial\n            [ grStops [ ( num 0, \"red\" ), ( num 1, \"blue\" ) ] ]\n        ]\n\nTo set a color gradient based on a color scale, use [vGradientScale](#vGradientScale)\ninstead.\n\n","type":"Vega.ColorGradient -> List.List Vega.GradientProperty -> Vega.Value"},{"name":"vGradientScale","comment":" A color gradient value based on a color scale. The first parameter should be\nthe color scale to use. The second parameter is a set of customisation options\nfor projecting the color scale onto the mark area. For example:\n\n    maFill\n        [ vGradientScale (vScale \"cScale\")\n            [ grStart (nums [ 1, 0 ]), grStop (nums [ 1, 1 ]) ]\n        ]\n\nTo set a literal color gradient without a color scale, use [vGradient](#vGradient)\ninstead.\n\n","type":"Vega.Value -> List.List Vega.GradientScaleProperty -> Vega.Value"},{"name":"vLineBottom","comment":" Convenience function for indicating a line-bottom vertical alignment.\n","type":"Vega.Value"},{"name":"vLineTop","comment":" Convenience function for indicating a line-top vertical alignment.\n","type":"Vega.Value"},{"name":"vMiddle","comment":" Convenience function for indicating a middle vertical alignment.\n","type":"Vega.Value"},{"name":"vMultiply","comment":" A multiplication value modifier.\n","type":"Vega.Value -> Vega.Value"},{"name":"vNull","comment":" An absence of a value.\n","type":"Vega.Value"},{"name":"vNum","comment":" A numeric value.\n","type":"Basics.Float -> Vega.Value"},{"name":"vNums","comment":" A list of numbers.\n","type":"List.List Basics.Float -> Vega.Value"},{"name":"vObject","comment":" Object containing a list of [key-value](#keyValue) pairs.\n","type":"List.List Vega.Value -> Vega.Value"},{"name":"vOffset","comment":" An additive value modifier.\n","type":"Vega.Value -> Vega.Value"},{"name":"vRound","comment":" A rounding value modifier. Rounding is applied after all other modifiers.\n","type":"Vega.Boo -> Vega.Value"},{"name":"vScale","comment":" Name of a scale.\n","type":"String.String -> Vega.Value"},{"name":"vScaleField","comment":" A scale field used to dynamically look up a scale name.\n","type":"Vega.Field -> Vega.Value"},{"name":"vSignal","comment":" A named signal.\n","type":"String.String -> Vega.Value"},{"name":"vStr","comment":" A string value.\n","type":"String.String -> Vega.Value"},{"name":"vStrs","comment":" A list of string values.\n","type":"List.List String.String -> Vega.Value"},{"name":"vTop","comment":" Convenience function for indicating a top vertical alignment.\n","type":"Vega.Value"},{"name":"vTrue","comment":" A 'true' value.\n","type":"Vega.Value"},{"name":"vValues","comment":" List of values. Useful for nesting collections of possibly mixed types.\n","type":"List.List Vega.Value -> Vega.Value"},{"name":"vaAlphabetic","comment":" 'Alphabetic' vertical alignment aligning font baseline. Applies to text\nmarks only.\n","type":"Vega.VAlign"},{"name":"vaBottom","comment":" Bottom vertical text alignment.\n","type":"Vega.VAlign"},{"name":"vaLineBottom","comment":" Bottom vertical text alignment calculated relative to line height rather than\njust font size.\n","type":"Vega.VAlign"},{"name":"vaLineTop","comment":" Top vertical text alignment calculated relative to line height rather than\njust font size.\n","type":"Vega.VAlign"},{"name":"vaMiddle","comment":" Middle vertical text alignment.\n","type":"Vega.VAlign"},{"name":"vaSignal","comment":" Vertical text alignment referenced by the value in the named signal.\n","type":"String.String -> Vega.VAlign"},{"name":"vaTop","comment":" Top vertical text alignment.\n","type":"Vega.VAlign"},{"name":"voAs","comment":" Name of the output field of a voronoi transform. If not specified, the default\nis `path`.\n","type":"String.String -> Vega.VoronoiProperty"},{"name":"voExtent","comment":" Extent of the voronoi cells in a voronoi transform. The two parameters\nshould each evaluate to a list of two numbers representing the coordinates of the\ntop-left and bottom-right of the extent respectively.\n","type":"Vega.Num -> Vega.Num -> Vega.VoronoiProperty"},{"name":"voSize","comment":" Extent of the voronoi cells in a voronoi transform. The single parameter\nshould evaluate to a list of two numbers representing the bottom-right of the extent.\nThe top-left is assumed to be [0,0].\n","type":"Vega.Num -> Vega.VoronoiProperty"},{"name":"wcAs","comment":" Name output fields created by a word cloud transform. The parameters\nmap to the following default values: `x`, `y`, `font`, `fontSize`, `fontStyle`,\n`fontWeight` and `angle`.\n","type":"String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> Vega.WordcloudProperty"},{"name":"wcFont","comment":" Font family to use for a word in a wordcloud.\n","type":"Vega.Str -> Vega.WordcloudProperty"},{"name":"wcFontSize","comment":" Font size to use for a word in a wordcloud.\n","type":"Vega.Num -> Vega.WordcloudProperty"},{"name":"wcFontSizeRange","comment":" Font size range to use for words in a wordcloud. The parameter should\nresolve to a two-element list [min, max]. The size of words in a wordcloud will be\nscaled to lie in the given range according to the square root scale.\n","type":"Vega.Num -> Vega.WordcloudProperty"},{"name":"wcFontStyle","comment":" Font style to use for words in a wordcloud.\n","type":"Vega.Str -> Vega.WordcloudProperty"},{"name":"wcFontWeight","comment":" Font weights to use for words in a wordcloud.\n","type":"Vega.Str -> Vega.WordcloudProperty"},{"name":"wcPadding","comment":" Padding, in pixels, to be placed around words in a wordcloud.\n","type":"Vega.Num -> Vega.WordcloudProperty"},{"name":"wcRotate","comment":" Angle in degrees of words in a wordcloud layout.\n","type":"Vega.Num -> Vega.WordcloudProperty"},{"name":"wcSize","comment":" Size of layout created by a wordcloud transform. The parameter should\nresolve to a two-element list [width, height] in pixels.\n","type":"Vega.Num -> Vega.WordcloudProperty"},{"name":"wcSpiral","comment":" Spiral layout method for a wordcloud transform.\n","type":"Vega.Spiral -> Vega.WordcloudProperty"},{"name":"wcText","comment":" Data field with the input word text for a wordcloud transform.\n","type":"Vega.Field -> Vega.WordcloudProperty"},{"name":"week","comment":" Indicate time unit is to specified as a week.\n","type":"Vega.TimeUnit"},{"name":"white","comment":" Convenience function for specifying a white color setting for marks that can\nbe colored (e.g. with [maStroke](#maStroke))\n","type":"Vega.Value"},{"name":"width","comment":" Override the default width of the visualization. If not specified, the width\nwill be calculated based on the content of the visualization.\n","type":"Basics.Float -> ( Vega.VProperty, Vega.Spec )"},{"name":"widthSignal","comment":" Override the default width of the visualization. This requires a signal expression\nto be used representing the width.\n","type":"String.String -> ( Vega.VProperty, Vega.Spec )"},{"name":"wnAggOperation","comment":" Aggregate operation to be applied during a window transformation.\nThis version is suitable for operations without parameters (e.g. `woRowNumber`)\nand that are not applied to a specific field.\n\nThe parameters are the operation to apply, the input field (or `Nothing` if no input\nfield) and the name to give to the field that will contain the results of the calculation.\n\nThe example below calculates the average over an unbounded window:\n\n    transform\n        [ trWindow [ wnAggOperation opMean (Just (field \"IMDB_Rating\")) \"avScore\" ]\n            [ wnFrame numNull ]\n        ]\n\n","type":"Vega.Operation -> Maybe.Maybe Vega.Field -> String.String -> Vega.WindowOperation"},{"name":"wnFrame","comment":" Two-element list indicating how a sliding window should proceed during a window\ntransform. The list entries should either be a number indicating the offset from\nthe current data object, or [numNull](#numNull) to indicate unbounded rows preceding\nor following the current data object.\n","type":"Vega.Num -> Vega.WindowProperty"},{"name":"wnGroupBy","comment":" Data fields by which to partition data objects into separate windows\nduring a window transform. If not specified, a single group containing all data\nobjects will be used.\n","type":"List.List Vega.Field -> Vega.WindowProperty"},{"name":"wnIgnorePeers","comment":" Whether or not a sliding frame in a window transform should ignore\npeer values.\n","type":"Vega.Boo -> Vega.WindowProperty"},{"name":"wnOperation","comment":" Window-specific operation to be applied during a window transformation.\nThis version is suitable for operations without parameters (e.g. `woRowNumber`) and\nthat are not applied to a specific field.\n\nThe parameters are the operation to apply and the name to give to the field which\nwill contain the results of the calculation.\n\n    transform\n        [ trWindow [ wnOperation woRank \"order\" ]\n            [ wnSort [ ( field \"Gross\", descend ) ] ]\n        ]\n\n","type":"Vega.WOperation -> String.String -> Vega.WindowOperation"},{"name":"wnOperationOn","comment":" Window-specific operation to be applied during a window transformation.\nThis version is suitable for operations that have a parameter (e.g. `woLag` or\n`woLead`) and/or operations that require a specific field as input (e.g.\n`woLastValue`). The parameters are in order: the type of operation, a possible\noperation parameter, the field to apply it to and its output field name.\n\n    transform\n        [ trWindow\n            [ wnOperationOn woLag\n                (Just (num 5))\n                (Just (field \"temperature\"))\n                \"oldTemp\"\n            ]\n            []\n        ]\n\n","type":"Vega.WOperation -> Maybe.Maybe Vega.Num -> Maybe.Maybe Vega.Field -> String.String -> Vega.WindowOperation"},{"name":"wnSort","comment":" Indicate how sorting data objects is applied within a window transform.\n\n    transform\n        [ trWindow [ wnOperation woRowNumber \"order\" ]\n            [ wnSort [ ( field \"score\", ascend ) ] ]\n        ]\n\nIf two objects are equal in terms of sorting field datum by they are considered\n'peers'. If no sorting comparator is specified, data objects are processed in the\norder they are observed.\n\n","type":"List.List ( Vega.Field, Vega.Order ) -> Vega.WindowProperty"},{"name":"woCumeDist","comment":" Cumulative distribution function to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woDenseRank","comment":" Dense rank function to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woFirstValue","comment":" First value in a sliding window to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woLag","comment":" Value preceding the current object in a sliding window to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woLastValue","comment":" Last value in a sliding window to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woLead","comment":" Value following the current object in a sliding window to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woNextValue","comment":" If the current field value is not null and not undefined, it is returned.\nOtherwise, the next non-mising value in the sorted group is returned.\nThis operation is performed relative to the sorted group, not the window frame.\n","type":"Vega.WOperation"},{"name":"woNthValue","comment":" Nth value in a sliding window to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woPercentRank","comment":" Percentile of values in a sliding window to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woPercentile","comment":" Value preceding the current object in a sliding window to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woPrevValue","comment":" If the current field value is not null and not undefined, it is returned.\nOtherwise, the nearest previous non-mising value in the sorted group is returned.\nThis operation is performed relative to the sorted group, not the window frame.\n","type":"Vega.WOperation"},{"name":"woRank","comment":" Rank function to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woRowNumber","comment":" Assign consecutive row number to values in a data object to be applied in a window transform.\n","type":"Vega.WOperation"},{"name":"woSignal","comment":" Window operation referenced by the value in the named signal. For names of\nvalid window operations see the\n[Vega window operation documentation](https://vega.github.io/vega/docs/transforms/window/#ops)\n","type":"String.String -> Vega.WOperation"},{"name":"year","comment":" Indicate time unit is to specified as a year.\n","type":"Vega.TimeUnit"}],"binops":[]}]